schema {
  query: query_root
  mutation: mutation_root
}

"Marks the field, argument, input field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Indicates an Input Object is a OneOf Input Object."
directive @oneOf on INPUT_OBJECT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

type AcceptItemResult {
  id: uuid!
}

type AddListingUserActionResult {
  user_action_timestamp: String!
}

type AddVariantOptionsToSkuOutput {
  affected_rows: Int!
}

type Address {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  country: String
  locality: String!
  name: String!
  phone_number: String
  postal_code: String!
}

type AdminSearchResult {
  result: jsonb!
}

type AggregateCreditResult {
  credit_type: String
  currency_code: String
  currency_value: Int
  shipping_cost: Int
  subtotal_currency_value: Int
}

type AssociateListingResult {
  listing_id: uuid!
}

type Attribute {
  display: String!
  id: String!
  metadata: jsonb
  type: String!
}

type AttributeOption {
  attribute: Attribute!
  subAttributes: [AttributeOption!]
}

type BulkCreateListingsResult {
  listings: [CreateListingResult!]!
}

type CalculateCartEstimatesV2Result {
  cart_fulfillment_groups: [CartFulfillmentOption!]!
  cart_fulfillment_options: [CartFulfillmentOption!]
  cost: CostBreakdown!
  discounts: [Discount!]!
  items: [CartItemV2!]!
}

type CalculateCartEstimatesV3Result {
  cart_fulfillment_options: [CartFulfillmentOptionV3!]!
  cost: CostBreakdown!
  discounts: [DiscountV2!]!
  items: [CartItemV3!]!
}

type CancelOrderItemResult {
  status: String!
}

type CancelOrderResult {
  status: String!
}

type CancelReaderPaymentActionResult {
  reader_action_status: String
  reader_action_type: String
  reader_status: String!
}

type CancelStoreTakebackResult {
  id: uuid!
}

type CartFulfillmentOption {
  cost: DiscountableMoney!
  group_id: uuid!
}

type CartFulfillmentOptionV3 {
  cost: DiscountableMoney
  fulfillment_option_id: uuid!
  group_id: uuid!
  no_shipping_reason: String
  properties: jsonb
  type: String!
}

type CartItemV2 {
  fulfillment_group_id: uuid!
  listing_id: uuid!
  storefront_id: uuid!
  tax: Money
}

type CartItemV3 {
  fulfillment_group_options: [uuid!]!
  listing_id: uuid!
  price: DiscountableMoney!
  selected_fulfillment_group_id: uuid!
  storefront_id: uuid!
  tax: Money
}

type CheckBrandPasswordResult {
  error: String
  ok: Boolean!
}

type CheckPostalCodeResult {
  in_region: Boolean!
}

type ConfirmImageEnhancementOutput {
  image_id: String!
}

type CostBreakdown {
  shipping: DiscountableMoney
  subtotal: DiscountableMoney!
  tax: Money
  total: DiscountableMoney!
}

type CreateCollectionResponse {
  collection: collections
  collection_id: uuid!
}

type CreateCreditCardHoldResult {
  client_secret: String!
}

type CreateDirectChatResult {
  channel_id: String
  user_id: String!
}

type CreateDirectMessageResult {
  channel_id: String
  user_id: String!
}

type CreateDonationResult {
  donation_id: uuid!
  label_url: String
  shipping_label_id: uuid!
}

type CreateFormSubmissionResult {
  form_submission_id: uuid
}

type CreateListingResult {
  error: String
  error_codes: [String!]
  listing_id: String
}

type CreateMailTakebackResult {
  estimate_credit: CreditResult
  shipping_label_id: uuid!
  takeback_items: [TakebackItemCredit!]!
  takeback_number: String!
}

type CreateManualCollectionResponse {
  affected_rows: Int!
  attribute_type_option: attribute_type_options
  attribute_type_option_id: uuid!
  collection: collections
  collection_id: uuid!
}

type CreateOrUpdateStorefrontResult {
  storefront_id: uuid
}

type CreatePaymentIntentResult {
  client_secret: String!
}

type CreateProductImagesOutput {
  product_image_ids: [uuid!]!
}

type CreateProductStyleOutput {
  product_style_id: uuid!
}

type CreateProductStyleResult {
  product_style_id: uuid!
}

type CreateProductStyleVariantMediaGroupsResult {
  media_group_ids: [uuid!]!
  product_style_variant: product_style_variants
  product_style_variant_id: uuid!
}

type CreateProductStyleVariantResult {
  product_style_variant_id: uuid!
}

type CreateProductsOutput {
  product_ids: [uuid!]!
}

type CreateReturnResult {
  label_metadata: jsonb
  label_url: String
  manual_review_required: Boolean!
  return_id: uuid
  shipping_label_id: uuid
}

type CreateSearchPageResponse {
  id: uuid!
  search_page: search_pages
}

type CreateShippingLabelResult {
  shipping_label: shipping_labels
  shipping_label_id: uuid!
}

type CreateSingleSkuOutput {
  product_color_id: String
  product_id: String
  product_style_id: String
  sku_id: String
}

type CreateSkuImagesOutput {
  sku_image_ids: [uuid!]!
}

type CreateSkusOutput {
  sku_ids: [uuid!]!
}

type CreateStoreDonationResult {
  donation_id: uuid!
}

type CreateStoreTakebackResult {
  takeback_items: [StoreTakebackItem!]!
  takeback_number: String!
}

type CreateStripeAccountResult {
  account_id: String!
  url: String!
}

type CreateVariantSkusOutput {
  sku_ids: [uuid!]!
}

type CreateVariantTypeOptionResult {
  variant_type_option_id: uuid!
}

type CreateVerificationSessionResult {
  client_secret: String!
}

type CreditResult {
  credit_type: String!
  currency_code: String
  currency_value: Int
}

type DeleteCollectionResponse {
  affected_rows: Int!
}

type DeleteProductImagesOutput {
  affected_rows: Int!
}

type DeleteProductStyleVariantsResult {
  affected_rows: Int!
}

type DeleteProductsOutput {
  affected_rows: Int!
}

type DeleteSearchPageResponse {
  id: uuid!
}

type DeleteSkuImagesOutput {
  affected_rows: Int!
}

type DeleteSkusOutput {
  affected_rows: Int!
}

type DeleteVariantOptionFromSkuOutput {
  affected_rows: Int!
}

type DetectLanguageResponse {
  languageCode: String
}

type Discount {
  amount: Int
  code: String!
  discount_code_id: uuid
  error_code: DiscountErrorCode
  valid: Boolean!
}

type DiscountV2 {
  amount: Int
  code: String!
  error_code: DiscountErrorCode
  valid: Boolean!
}

type DiscountableMoney {
  discounted: Money!
  original: Money!
}

type DisputeItemResult {
  id: uuid!
}

type DropOffLocation {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  locality: String!
  name: String!
  option_id: String!
  postal_code: String!
}

type EditListingImageOrderResult {
  images: jsonb!
  listing_id: uuid!
}

type EnhancePhotoResult {
  photo_enhancement_request_id: uuid!
}

type EnhancePhotoStatusResult {
  id: uuid!
  photo_enhancement_request: photo_enhancement_requests
}

type EntityDistance {
  distance: Int!
  id: uuid!
  latitude: Float!
  longitude: Float!
}

type EntityDistanceResult {
  distances: [EntityDistance!]!
}

type FormSubmissionResult {
  id: uuid!
  submission_data: jsonb!
  user_display_name: String
  user_id: uuid!
}

type FulfillmentOption {
  brand_id: uuid!
  constraints: jsonb
  fulfillment_service_id: uuid!
  id: uuid!
  service_type: String!
  settings: jsonb
}

type GenerateTestEmailResult {
  html: String!
  subject: String!
}

type GetAttributeOptionsResponse {
  attribute_options: [AttributeOption!]!
}

type GetBrandSortResult {
  rule_priorities: [jsonb!]!
  search_sort_id: uuid
}

type GetCheckoutFulfillmentOptionsResult {
  fulfillment_options: [FulfillmentOption!]!
}

type GetCollectionDefinitionResponse {
  collection: collections
  collection_id: uuid!
  definition: jsonb
}

type GetFormSubmissionResult {
  form_submission: FormSubmissionResult
}

type GetFormSubmissionsResult {
  submissions: [FormSubmissionResult]!
  total: Int!
}

type GetInStoreFulfillmentOptionsForStorefrontResult {
  in_store_fulfillment_options: [DropOffLocation!]!
}

type GetInStorePickupsForCodesResult {
  in_store_pickups: [InStorePickup!]!
}

type GetItemFulfillmentOption {
  cost: Money
  fulfillment_option_id: uuid!
  type: String!
}

type GetItemFulfillmentOptionsResponse {
  fulfillmentOptions: [GetItemFulfillmentOption!]!
}

type GetManualCollectionItemsResponse {
  items: ManualCollectionItems!
}

type GetOrCreateStreamChatUserResult {
  stream_chat_user_id: String!
  stream_chat_user_token: String!
}

type GetProductStyleSkusResult {
  skus: [SkuResult!]!
}

type GetProductsXmlSitemapResult {
  content: String!
}

type GetReaderStatusResult {
  reader_action_status: String
  reader_action_type: String
  reader_status: String!
}

type GetReturnEstimateResponse {
  additional_charges: [ReturnCharge!]!
  discounts: Int!
  items: [ReturnLineItem!]!
  manual_review_required: Boolean!
  shipping: Int!
  subtotal: Int!
  tax: Int!
  total: Int!
}

type GetSearchPageSortResponse {
  custom_priorities: [SortPriority!]!
  rule_priorities: [jsonb!]!
  search_page_id: uuid!
}

type GetStoreTakebackBalance {
  gift_card_external_id: String!
  remaining_balance: Int
}

type GetStoreTakebackConfirmationDetailsResult {
  id: uuid!
  takeback: TakebackGetStoreTakebackConfirmationDetailsResult!
}

type GetStoreTakebackCredit {
  credit_type: String!
  currency_code: String!
  currency_value: Int!
}

type GetStoreTakebackCustomer {
  email: String!
  first_name: String!
  id: String!
  last_name: String
}

type GetStoreTakebackItem {
  credit: GetStoreTakebackCredit
  itemId: String!
  product_id: String!
}

type GetStoreTakebackMetadata {
  schema: GetStoreTakebackMetadataSchemas!
  value: jsonb!
}

type GetStoreTakebackResult {
  balance: GetStoreTakebackBalance
  created_at: timestamptz!
  credit: GetStoreTakebackCredit
  customer: GetStoreTakebackCustomer!
  items: [GetStoreTakebackItem!]!
  metadata: GetStoreTakebackMetadata
  retail_associate: GetStoreTakebackRetailAssociate
  retail_store: GetStoreTakebackRetailStore
  takeback_id: uuid!
  takeback_number: String!
  takeback_status: String!
}

type GetStoreTakebackRetailAssociate {
  first_name: String!
  id: String!
  last_name: String
}

type GetStoreTakebackRetailStore {
  name: String
}

type GetStripeAccountLinkResult {
  url: String!
}

type GetStripeAccountResult {
  enabled: Boolean!
  last4: String
  name: String
  type: String
}

type GetTakebackEstimateResult {
  estimate_credit: AggregateCreditResult
  takeback_items: [TakebackItemCredit!]!
}

type GetTakebackItemEstimatesResult {
  results: [TakebackItemEstimateCredit!]!
}

type GetTakebackRequestInfoResult {
  customer_email: String
  customer_first_name: String
  customer_last_name: String
  customer_user_id: String
  takeback_id: uuid!
  transaction_id: uuid
}

type GetUserEmailVerifiedResponse {
  emailVerified: Boolean!
}

type GetUserPreferredLanguageResult {
  error: String
  language: String
  success: Boolean!
}

type GetVariantTypeOptionsResult {
  options: [VariantOptionResult!]!
}

type GetVariantsResult {
  variants: [VariantResult!]!
}

type GetWorkflowDefinitionV1Result {
  created_at: timestamptz!
  id: uuid!
  schema: jsonb!
  type: String!
  updated_at: timestamptz!
}

type GetWorkflowItemResult {
  data: jsonb!
  id: uuid!
  state: String!
  workflow_definition_id: String!
  workflow_id: String!
}

type GetWorkflowItemsResult {
  result: jsonb!
}

type InStorePickup {
  identifier: String!
  in_store_pickup_id: uuid!
  in_store_pickup_status: String
  listing_ids: [uuid!]!
}

type LinkExternalAccountResponse {
  error: String
  success: Boolean!
}

type LookupOrderResult {
  order: orders
  order_id: String
}

type LookupTakebacksObject {
  id: String!
}

type LookupTakebacksResult {
  count: Int!
  results: [LookupTakebacksObject!]!
}

type ManualCollectionItems {
  listing_ids: [uuid!]!
  product_ids: [uuid!]!
  product_style_ids: [uuid!]!
  product_style_variant_ids: [uuid!]!
}

type Money {
  amount: Int!
  currency: String!
}

type MoveTempImagesResult {
  error: String
  ok: Boolean!
}

type PostiPickupPoint {
  name: String!
  pup_code: String!
  street_address: String!
}

type ProcessCartCheckoutResult {
  errors: [ProcessCartCheckoutResultError!]
  order_intent_id: uuid
  payment_intent_client_secret: String
}

type ProcessCartCheckoutResultError {
  code: String!
  payload: jsonb
  type: String
}

type ProcessCartCheckoutResultErrorV2 {
  code: String!
  payload: jsonb
  type: String
}

type ProcessCartCheckoutResultV2 {
  errors: [ProcessCartCheckoutResultErrorV2!]
  order_intent_id: uuid
  payment_intent_client_secret: String
}

type ProcessReaderPaymentIntentResult {
  reader_action_status: String
  reader_action_type: String
  reader_status: String!
}

type ProvisionUserResult {
  user_id: String
}

type RecommendPriceResult {
  result: jsonb
}

type RecommendationsResult {
  result: jsonb
}

type RefreshStreamChatTokenResult {
  stream_chat_user_token: String!
}

type ReissueStoreTakebackCreditResult {
  id: uuid!
}

type RequestEmailVerificationEmailResult {
  sent: Boolean!
}

type RequestPasswordResetEmailResult {
  ok: Boolean!
}

type RequestPasswordResetEmailResultV2 {
  ok: Boolean!
}

type RequestStoreCreditResult {
  amount_withdrawn: Int!
  current_balance: Int!
  transaction_id: String!
}

type RequestTakebackOutput {
  takeback_id: String
}

type ResetPasswordResult {
  ok: Boolean!
}

type ResolveExternalIdResult {
  result: jsonb!
}

type ResolveExternalOrderResult {
  sku: skus
  sku_id: String!
}

type ReturnCharge {
  amount: Int!
  type: ReturnChargeType!
}

type ReturnLineItem {
  amount: Int!
  order_item_id: uuid!
  return_reason: String
  tax: Int!
}

type RevokeRefreshTokenResult {
  ok: Boolean!
}

type SearchResult {
  result: jsonb!
}

type SellerCloneListingResult {
  id: uuid!
}

type SetBrandSortResult {
  search_sort_id: uuid!
}

type SetListingImagesResult {
  listing_image_ids: [uuid!]!
}

type SetUserMetadataResponse {
  results: [UserMetadata!]!
}

type SetUserPreferredLanguageResult {
  error: String
  success: Boolean!
}

type SetupRetailAssociateOutput {
  success: Boolean!
}

type ShowHideListingResult {
  id: uuid!
  listing: listings
}

type SkuResult {
  sku_id: uuid!
  variant_values: [VariantValueResult!]!
}

type SortPriority {
  object_id: uuid!
  priority: Int!
}

type StoreTakebackItem {
  credit: CreditResult
  item_id: uuid!
}

type StorefrontsForUserResult {
  address_id: String
  address_line_1: String
  address_line_2: String
  address_name: String
  address_phone_number: String
  administrative_area: String
  bio: String
  building_access: String
  country: String
  email: String!
  enabled_in_store_fulfillment_options: [DropOffLocation!]
  floors: Int
  hide_address: Boolean
  links: jsonb
  locality: String
  logo_alt: String
  logo_href: String
  logo_id: uuid
  logo_path: String
  name: String!
  phone_number: String
  postal_code: String
  slug: String!
  storefront_id: uuid
  type: String
  verified: Boolean
}

type SubmitListingReviewResult {
  listing_review_id: uuid!
}

type SubmitWorkflowItemResult {
  data: jsonb!
  state: String!
  workflow_item_id: uuid!
}

type TakebackGetStoreTakebackConfirmationDetailsResult {
  credit: CreditResult
  id: uuid!
  status: String!
  takeback_items: [StoreTakebackItem!]!
  takeback_number: String!
}

type TakebackItemCredit {
  estimate_credit: CreditResult
  item_id: uuid!
}

type TakebackItemEstimateCredit {
  item_id: TakebackItemId!
  max_value: CreditResult!
}

type TakebackItemId {
  id: String!
  id_type: TakebackItemIdType!
}

type TakebackRequestStoreCreditResult {
  result: RequestStoreCreditResult
  status: TakebackRequestStoreCreditStatus
}

type TranslateResponse {
  translatedText: String!
}

type TranslationResult {
  display: String!
  lang: String!
}

type UnlistListingsResult {
  listing_ids: [String!]!
}

type UpdateCollectionResponse {
  collection_id: uuid!
  collections: collections
}

type UpdateFormSubmissionResult {
  form_submission_id: uuid
  submission_data: jsonb
}

type UpdateInStorePickupStatusResult {
  in_store_pickup_ids: [uuid!]!
}

type UpdateManualCollectionItemsResponse {
  affected_rows: Int!
  attribute_type_option: attribute_type_options
  attribute_type_option_id: uuid!
  collection: collections
  collection_id: uuid!
}

type UpdateMediaGroupResult {
  media_group_id: uuid!
  media_groups: media_groups
}

type UpdateProductImagesOutput {
  product_image_ids: [uuid!]!
}

type UpdateProductOutput {
  product_id: uuid!
}

type UpdateProductStyleOutput {
  product_style_id: String!
}

type UpdateProductStyleV2Result {
  product_style_id: String!
}

type UpdateProductStyleVariantsResult {
  product_style_variant_id: uuid!
}

type UpdateSearchPageResponse {
  id: uuid!
  search_page: search_pages
}

type UpdateSkuImagesOutput {
  sku_image_ids: [uuid!]!
}

type UpdateSkusOutput {
  affected_rows: Int!
}

type UpdateStoreTakebackUserResult {
  id: uuid!
}

type UserMetadata {
  id: uuid!
  key: String!
  value: jsonb
}

type ValidateAddressResult {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  error: String
  isValid: Boolean!
  locality: String
  name: String
  objectId: String
  postal_code: String
}

type ValidateAddressV2Result {
  address: ValidateAddressV2ResultAddress
  metadata: ValidateAddressV2ResultMetadata
  responseId: String!
  validation: ValidateAddressV2ResultValidation!
}

type ValidateAddressV2ResultAddress {
  recommended_address: Address
}

type ValidateAddressV2ResultMetadata {
  address_type: ValidateAddressV2AddressType
  po_box: Boolean
}

type ValidateAddressV2ResultValidation {
  reasons: [ValidateAddressV2ResultValidationReason!]!
  result: ValidateAddressV2ResultValidationResult!
}

type ValidateAddressV2ResultValidationReason {
  code: ValidateAddressV2ResultValidationReasonCode!
  description: String
  relevant_field: AddressField
  type: ValidateAddressV2ResultValidationReasonType!
}

type ValidateAuthActionTokenResult {
  isValid: Boolean!
}

type VariantOptionResult {
  option: String!
  option_id: uuid!
  options: [TranslationResult!]!
}

type VariantResult {
  type: String!
  type_id: uuid!
  types: [TranslationResult!]!
}

type VariantValueResult {
  option_id: uuid!
  option_translations: [TranslationResult!]
  type_id: uuid!
  type_translations: [TranslationResult!]
}

type VerifyEmailResult {
  ok: Boolean!
}

type WithdrawBalanceResult {
  amount_withdrawn: Int!
  current_balance: Int!
}

type WmsPreviewListing {
  existing_listing_id: uuid
  listing: json
}

"columns and relationships of \"addresses\""
type addresses {
  administrative_area: String
  country: String!
  id: uuid!
  locality: String!
  longlat_pub: geography
}

"response of any mutation on the table \"addresses\""
type addresses_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [addresses!]!
}

"columns and relationships of \"annual_sales_totals\""
type annual_sales_totals {
  country: String
  "An object relationship"
  storefront: storefronts
  storefront_id: uuid
  tax_year: float8
  total: bigint
  total_sales_count: bigint
  "An object relationship"
  user: users
  user_id: String
}

"aggregated selection of \"annual_sales_totals\""
type annual_sales_totals_aggregate {
  aggregate: annual_sales_totals_aggregate_fields
  nodes: [annual_sales_totals!]!
}

"aggregate fields of \"annual_sales_totals\""
type annual_sales_totals_aggregate_fields {
  avg: annual_sales_totals_avg_fields
  count(columns: [annual_sales_totals_select_column!], distinct: Boolean): Int!
  max: annual_sales_totals_max_fields
  min: annual_sales_totals_min_fields
  stddev: annual_sales_totals_stddev_fields
  stddev_pop: annual_sales_totals_stddev_pop_fields
  stddev_samp: annual_sales_totals_stddev_samp_fields
  sum: annual_sales_totals_sum_fields
  var_pop: annual_sales_totals_var_pop_fields
  var_samp: annual_sales_totals_var_samp_fields
  variance: annual_sales_totals_variance_fields
}

"aggregate avg on columns"
type annual_sales_totals_avg_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate max on columns"
type annual_sales_totals_max_fields {
  country: String
  storefront_id: uuid
  tax_year: float8
  total: bigint
  total_sales_count: bigint
  user_id: String
}

"aggregate min on columns"
type annual_sales_totals_min_fields {
  country: String
  storefront_id: uuid
  tax_year: float8
  total: bigint
  total_sales_count: bigint
  user_id: String
}

"aggregate stddev on columns"
type annual_sales_totals_stddev_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate stddev_pop on columns"
type annual_sales_totals_stddev_pop_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate stddev_samp on columns"
type annual_sales_totals_stddev_samp_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate sum on columns"
type annual_sales_totals_sum_fields {
  tax_year: float8
  total: bigint
  total_sales_count: bigint
}

"aggregate var_pop on columns"
type annual_sales_totals_var_pop_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate var_samp on columns"
type annual_sales_totals_var_samp_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"aggregate variance on columns"
type annual_sales_totals_variance_fields {
  tax_year: Float
  total: Float
  total_sales_count: Float
}

"columns and relationships of \"applied_discount_codes\""
type applied_discount_codes {
  discount_amount: numeric!
  id: uuid!
  "An object relationship"
  order: orders!
  order_id: uuid!
}

"columns and relationships of \"attempted_discount_codes\""
type attempted_discount_codes {
  discount_amount: numeric!
  id: uuid!
  "An object relationship"
  order_intent: order_intents!
  order_intent_id: uuid!
}

"response of any mutation on the table \"attempted_discount_codes\""
type attempted_discount_codes_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [attempted_discount_codes!]!
}

"columns and relationships of \"attribute_type_options\""
type attribute_type_options {
  "An object relationship"
  attribute_type: attribute_types!
  attribute_type_id: uuid!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "A computed field, executes function \"ato_content\""
  content(
    "distinct select on columns"
    distinct_on: [attribute_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_translations_order_by!],
    "filter the rows returned"
    where: attribute_type_options_translations_bool_exp
  ): [attribute_type_options_translations!]
  created_at: timestamptz!
  id: uuid!
  option: String!
  "An array relationship"
  translations(
    "distinct select on columns"
    distinct_on: [attribute_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_translations_order_by!],
    "filter the rows returned"
    where: attribute_type_options_translations_bool_exp
  ): [attribute_type_options_translations!]!
  updated_at: timestamptz!
}

"columns and relationships of \"attribute_type_options_translations\""
type attribute_type_options_translations {
  attribute_type_option_id: uuid!
  display: String!
  id: Int!
  lang: String!
}

"columns and relationships of \"attribute_types\""
type attribute_types {
  "An array relationship"
  attribute_type_options(
    "distinct select on columns"
    distinct_on: [attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_order_by!],
    "filter the rows returned"
    where: attribute_type_options_bool_exp
  ): [attribute_type_options!]!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "A computed field, executes function \"at_content\""
  content(
    "distinct select on columns"
    distinct_on: [attribute_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_translations_order_by!],
    "filter the rows returned"
    where: attribute_types_translations_bool_exp
  ): [attribute_types_translations!]
  id: uuid!
  "An array relationship"
  translations(
    "distinct select on columns"
    distinct_on: [attribute_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_translations_order_by!],
    "filter the rows returned"
    where: attribute_types_translations_bool_exp
  ): [attribute_types_translations!]!
  type: String!
}

"columns and relationships of \"attribute_types_translations\""
type attribute_types_translations {
  attribute_type_id: uuid!
  display: String!
  id: Int!
  lang: String!
}

"columns and relationships of \"auction_bids\""
type auction_bids {
  "An object relationship"
  address: addresses
  address_id: uuid
  amount: bigint!
  "An object relationship"
  auction: auctions!
  auction_id: uuid!
  created_at: timestamptz!
  id: uuid!
  order: Int!
  payment_intent_id: String!
  "An object relationship"
  user: users!
  user_id: String!
}

"columns and relationships of \"auction_bids_history\""
type auction_bids_history {
  amount: bigint!
  "An object relationship"
  auction: auctions!
  auction_id: uuid!
  created_at: timestamptz!
  id: uuid!
  order: Int!
  "An object relationship"
  user: users!
  user_id: String!
}

"response of any mutation on the table \"auction_bids\""
type auction_bids_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [auction_bids!]!
}

"columns and relationships of \"auctions\""
type auctions {
  "An array relationship"
  bids(
    "distinct select on columns"
    distinct_on: [auction_bids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_order_by!],
    "filter the rows returned"
    where: auction_bids_bool_exp
  ): [auction_bids!]!
  "An array relationship"
  bids_histories(
    "distinct select on columns"
    distinct_on: [auction_bids_history_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_history_order_by!],
    "filter the rows returned"
    where: auction_bids_history_bool_exp
  ): [auction_bids_history!]!
  end: timestamptz!
  id: uuid!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  max_price: Int
  start: timestamptz!
}

"columns and relationships of \"brand_categories\""
type brand_categories {
  "An object relationship"
  brand: brands!
  "An array relationship"
  brand_categories(
    "distinct select on columns"
    distinct_on: [brand_categories_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_order_by!],
    "filter the rows returned"
    where: brand_categories_bool_exp
  ): [brand_categories!]!
  "An object relationship"
  brand_category: brand_categories
  brand_id: uuid!
  "An array relationship"
  category_translations(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): [brand_categories_translations!]!
  "An aggregate relationship"
  category_translations_aggregate(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): brand_categories_translations_aggregate!
  "A computed field, executes function \"bc_content\""
  content(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): [brand_categories_translations!]
  created_at: timestamptz!
  default_price_multiplier: numeric
  id: uuid!
  name: String!
  parent_id: uuid
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An array relationship"
  productsBySuperCategoryId(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  productsBySuperCategoryId_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  singular: String
  uid: String!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_categories_translations\""
type brand_categories_translations {
  category_id: uuid!
  id: Int!
  lang: String!
  name: String!
  singular: String!
}

"aggregated selection of \"brand_categories_translations\""
type brand_categories_translations_aggregate {
  aggregate: brand_categories_translations_aggregate_fields
  nodes: [brand_categories_translations!]!
}

"aggregate fields of \"brand_categories_translations\""
type brand_categories_translations_aggregate_fields {
  avg: brand_categories_translations_avg_fields
  count(columns: [brand_categories_translations_select_column!], distinct: Boolean): Int!
  max: brand_categories_translations_max_fields
  min: brand_categories_translations_min_fields
  stddev: brand_categories_translations_stddev_fields
  stddev_pop: brand_categories_translations_stddev_pop_fields
  stddev_samp: brand_categories_translations_stddev_samp_fields
  sum: brand_categories_translations_sum_fields
  var_pop: brand_categories_translations_var_pop_fields
  var_samp: brand_categories_translations_var_samp_fields
  variance: brand_categories_translations_variance_fields
}

"aggregate avg on columns"
type brand_categories_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type brand_categories_translations_max_fields {
  category_id: uuid
  id: Int
  lang: String
  name: String
  singular: String
}

"aggregate min on columns"
type brand_categories_translations_min_fields {
  category_id: uuid
  id: Int
  lang: String
  name: String
  singular: String
}

"aggregate stddev on columns"
type brand_categories_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type brand_categories_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type brand_categories_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type brand_categories_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type brand_categories_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type brand_categories_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type brand_categories_translations_variance_fields {
  id: Float
}

"columns and relationships of \"brand_fulfillment_in_store_options\""
type brand_fulfillment_in_store_options {
  brand_fulfillment_in_store_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  retail_store: retail_stores!
  retail_store_id: uuid!
  shipping_fee: Int!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_fulfillment_in_store_settings\""
type brand_fulfillment_in_store_settings {
  brand_fulfillment_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_options_bool_exp
  ): [brand_fulfillment_in_store_options!]!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_fulfillment_postal_options\""
type brand_fulfillment_postal_options {
  brand_fulfillment_postal_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  postal_options_id: uuid!
  shipping_fee: Int!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_fulfillment_postal_settings\""
type brand_fulfillment_postal_settings {
  brand_fulfillment_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_options_bool_exp
  ): [brand_fulfillment_postal_options!]!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_fulfillment_settings\""
type brand_fulfillment_settings {
  brand_id: uuid!
  created_at: timestamptz!
  fulfillment_type: fulfillment_types_enum!
  id: uuid!
  "An array relationship"
  in_store_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_settings_bool_exp
  ): [brand_fulfillment_in_store_settings!]!
  name: String!
  "An array relationship"
  postal_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_settings_bool_exp
  ): [brand_fulfillment_postal_settings!]!
  updated_at: timestamptz!
}

"columns and relationships of \"brand_passwords\""
type brand_passwords {
  brand_id: uuid!
  enabled: Boolean!
}

"columns and relationships of \"brands\""
type brands {
  "An array relationship"
  attribute_type_options(
    "distinct select on columns"
    distinct_on: [attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_order_by!],
    "filter the rows returned"
    where: attribute_type_options_bool_exp
  ): [attribute_type_options!]!
  "An array relationship"
  attribute_types(
    "distinct select on columns"
    distinct_on: [attribute_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_order_by!],
    "filter the rows returned"
    where: attribute_types_bool_exp
  ): [attribute_types!]!
  "An array relationship"
  categories(
    "distinct select on columns"
    distinct_on: [brand_categories_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_order_by!],
    "filter the rows returned"
    where: brand_categories_bool_exp
  ): [brand_categories!]!
  "An array relationship"
  condition_questions(
    "distinct select on columns"
    distinct_on: [condition_questions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_order_by!],
    "filter the rows returned"
    where: condition_questions_bool_exp
  ): [condition_questions!]!
  content(
    "JSON select path"
    path: String
  ): jsonb
  created_at: timestamptz!
  "An array relationship"
  fulfillment_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_settings_bool_exp
  ): [brand_fulfillment_settings!]!
  id: uuid!
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  name: String!
  "An array relationship"
  passwords(
    "distinct select on columns"
    distinct_on: [brand_passwords_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_passwords_order_by!],
    "filter the rows returned"
    where: brand_passwords_bool_exp
  ): [brand_passwords!]!
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "An array relationship"
  searchable_products_results(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "An aggregate relationship"
  searchable_products_results_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  settings(
    "JSON select path"
    path: String
  ): jsonb!
  "An array relationship"
  skus(
    "distinct select on columns"
    distinct_on: [skus_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_order_by!],
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  slug: String!
  updated_at: timestamptz!
}

"columns and relationships of \"chat_channels\""
type chat_channels {
  brand_id: uuid!
  channel_external_identifier: String!
  channel_type: chat_channel_types_enum!
  created_at: timestamptz!
  key: String!
  updated_at: timestamptz!
}

"columns and relationships of \"collapsed_product_results\""
type collapsed_product_results {
  part_id: String
  "An object relationship"
  product: products
  product_id: uuid
}

"aggregated selection of \"collapsed_product_results\""
type collapsed_product_results_aggregate {
  aggregate: collapsed_product_results_aggregate_fields
  nodes: [collapsed_product_results!]!
}

"aggregate fields of \"collapsed_product_results\""
type collapsed_product_results_aggregate_fields {
  count(columns: [collapsed_product_results_select_column!], distinct: Boolean): Int!
  max: collapsed_product_results_max_fields
  min: collapsed_product_results_min_fields
}

"aggregate max on columns"
type collapsed_product_results_max_fields {
  part_id: String
  product_id: uuid
}

"aggregate min on columns"
type collapsed_product_results_min_fields {
  part_id: String
  product_id: uuid
}

"columns and relationships of \"collection_media_groups\""
type collection_media_groups {
  collection_id: uuid!
  created_at: timestamptz!
  media_group_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"collections\""
type collections {
  active: Boolean!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "A computed field, executes function \"c_content\""
  content(
    "distinct select on columns"
    distinct_on: [collections_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_translations_order_by!],
    "filter the rows returned"
    where: collections_translations_bool_exp
  ): [collections_translations!]
  created_at: timestamptz!
  id: uuid!
  read_only: Boolean!
  slug: String!
  "An array relationship"
  translations(
    "distinct select on columns"
    distinct_on: [collections_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_translations_order_by!],
    "filter the rows returned"
    where: collections_translations_bool_exp
  ): [collections_translations!]!
  type: collection_types_enum!
  updated_at: timestamptz!
}

"columns and relationships of \"collections_translations\""
type collections_translations {
  collection_id: uuid!
  description: String
  display_name: String!
  id: Int!
  locale: String!
}

"columns and relationships of \"condition_questions\""
type condition_questions {
  addl_info_comment: Boolean!
  addl_info_comment_required: Boolean!
  addl_info_images: Boolean!
  addl_info_images_required: Boolean!
  addl_info_on_response_value: Boolean!
  addl_info_prompt: String
  "An object relationship"
  brand: brands
  brand_id: uuid
  "A computed field, executes function \"cq_content\""
  content(
    "distinct select on columns"
    distinct_on: [condition_questions_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_translations_order_by!],
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): [condition_questions_translations!]
  "An object relationship"
  depends_on_question: condition_questions
  depends_on_question_id: uuid
  depends_on_response_value: Boolean
  fail_description: String
  fail_on_response_value: Boolean
  help_text: String
  hidden: Boolean!
  id: uuid!
  index: Int!
  listing_description_false: String
  listing_description_true: String
  question_set_id: uuid
  score_false: Int!
  score_true: Int!
  severity: Boolean!
  severity_on_response_value: Boolean
  severity_text: String
  text: String!
}

"columns and relationships of \"condition_questions_translations\""
type condition_questions_translations {
  addl_info_prompt: String
  condition_question_id: uuid!
  fail_description: String
  help_text: String
  id: Int!
  lang: String!
  listing_description_false: String
  listing_description_true: String
  severity_text: String
  text: String!
}

"aggregated selection of \"condition_questions_translations\""
type condition_questions_translations_aggregate {
  aggregate: condition_questions_translations_aggregate_fields
  nodes: [condition_questions_translations!]!
}

"aggregate fields of \"condition_questions_translations\""
type condition_questions_translations_aggregate_fields {
  avg: condition_questions_translations_avg_fields
  count(columns: [condition_questions_translations_select_column!], distinct: Boolean): Int!
  max: condition_questions_translations_max_fields
  min: condition_questions_translations_min_fields
  stddev: condition_questions_translations_stddev_fields
  stddev_pop: condition_questions_translations_stddev_pop_fields
  stddev_samp: condition_questions_translations_stddev_samp_fields
  sum: condition_questions_translations_sum_fields
  var_pop: condition_questions_translations_var_pop_fields
  var_samp: condition_questions_translations_var_samp_fields
  variance: condition_questions_translations_variance_fields
}

"aggregate avg on columns"
type condition_questions_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type condition_questions_translations_max_fields {
  addl_info_prompt: String
  condition_question_id: uuid
  fail_description: String
  help_text: String
  id: Int
  lang: String
  listing_description_false: String
  listing_description_true: String
  severity_text: String
  text: String
}

"aggregate min on columns"
type condition_questions_translations_min_fields {
  addl_info_prompt: String
  condition_question_id: uuid
  fail_description: String
  help_text: String
  id: Int
  lang: String
  listing_description_false: String
  listing_description_true: String
  severity_text: String
  text: String
}

"aggregate stddev on columns"
type condition_questions_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type condition_questions_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type condition_questions_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type condition_questions_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type condition_questions_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type condition_questions_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type condition_questions_translations_variance_fields {
  id: Float
}

"columns and relationships of \"condition_responses\""
type condition_responses {
  comment: String
  "An object relationship"
  condition_question: condition_questions!
  condition_question_id: uuid!
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [listing_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_images_order_by!],
    "filter the rows returned"
    where: listing_images_bool_exp
  ): [listing_images!]!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  response: Boolean!
  score: Int!
  severity: Int!
  user_id: String!
}

"response of any mutation on the table \"condition_responses\""
type condition_responses_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [condition_responses!]!
}

"columns and relationships of \"credit\""
type credit {
  "An array relationship"
  credit_takeback(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): [takebacks!]!
  "An aggregate relationship"
  credit_takeback_aggregate(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): takebacks_aggregate!
  "An array relationship"
  credit_takeback_item(
    "distinct select on columns"
    distinct_on: [takeback_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takeback_items_order_by!],
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  credit_type: credit_types_enum
  currency_code: String
  currency_value: Int
  "An array relationship"
  estimated_credit_takeback(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): [takebacks!]!
  "An aggregate relationship"
  estimated_credit_takeback_aggregate(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): takebacks_aggregate!
  "An array relationship"
  estimated_credit_takeback_item(
    "distinct select on columns"
    distinct_on: [takeback_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takeback_items_order_by!],
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  id: uuid!
}

"columns and relationships of \"dac7_verified_storefronts\""
type dac7_verified_storefronts {
  "An object relationship"
  storefront: storefronts
  storefront_id: uuid
}

"response of any mutation on the table \"email_signups\""
type email_signups_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
}

"columns and relationships of \"external_sku_ids\""
type external_sku_ids {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  external_id: String!
  external_id_type: String!
  id: uuid!
  "An object relationship"
  sku: skus!
  sku_id: uuid!
}

"columns and relationships of \"form_submissions\""
type form_submissions {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  "An object relationship"
  form: forms!
  form_id: uuid!
  id: uuid!
  submission_data(
    "JSON select path"
    path: String
  ): jsonb!
  "An object relationship"
  user: users
  user_id: String
}

"aggregated selection of \"form_submissions\""
type form_submissions_aggregate {
  aggregate: form_submissions_aggregate_fields
  nodes: [form_submissions!]!
}

"aggregate fields of \"form_submissions\""
type form_submissions_aggregate_fields {
  count(columns: [form_submissions_select_column!], distinct: Boolean): Int!
  max: form_submissions_max_fields
  min: form_submissions_min_fields
}

"aggregate max on columns"
type form_submissions_max_fields {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  user_id: String
}

"aggregate min on columns"
type form_submissions_min_fields {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  user_id: String
}

"response of any mutation on the table \"form_submissions\""
type form_submissions_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [form_submissions!]!
}

"columns and relationships of \"forms\""
type forms {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  id: uuid!
  schema(
    "JSON select path"
    path: String
  ): jsonb!
  type: String!
}

"columns and relationships of \"fulfillment_intents\""
type fulfillment_intents {
  "An object relationship"
  fulfillment_service: fulfillment_services!
  id: uuid!
}

"columns and relationships of \"fulfillment_services\""
type fulfillment_services {
  id: uuid!
  type: fulfillment_types_v2_enum!
}

"columns and relationships of \"fulfillments\""
type fulfillments {
  "An object relationship"
  brand: brands!
  "An object relationship"
  fulfillment_intent: fulfillment_intents
  "An object relationship"
  fulfillment_service: fulfillment_services
  fulfillment_service_id: uuid
  id: uuid!
  "An array relationship"
  order_items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  order_items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  "An object relationship"
  shipping_label: shipping_labels
  "An object relationship"
  storefront: storefronts!
}

"columns and relationships of \"gift_cards\""
type gift_cards {
  external_id: String!
  id: uuid!
  status: gift_card_statuses_enum!
  "An object relationship"
  transaction: transactions!
  transaction_id: uuid!
}

"aggregated selection of \"gift_cards\""
type gift_cards_aggregate {
  aggregate: gift_cards_aggregate_fields
  nodes: [gift_cards!]!
}

"aggregate fields of \"gift_cards\""
type gift_cards_aggregate_fields {
  count(columns: [gift_cards_select_column!], distinct: Boolean): Int!
  max: gift_cards_max_fields
  min: gift_cards_min_fields
}

"aggregate max on columns"
type gift_cards_max_fields {
  external_id: String
  id: uuid
  transaction_id: uuid
}

"aggregate min on columns"
type gift_cards_min_fields {
  external_id: String
  id: uuid
  transaction_id: uuid
}

"columns and relationships of \"images\""
type images {
  alt: String
  created_at: timestamptz!
  href: String!
  id: uuid!
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  updated_at: timestamptz!
}

"columns and relationships of \"in_store_pickups\""
type in_store_pickups {
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  identifier: String!
  "An object relationship"
  shipping_information: shipping_information!
  shipping_information_id: uuid!
  status: in_store_pickup_statuses_enum!
  updated_at: timestamptz!
}

"columns and relationships of \"listing_auto_price_reduce\""
type listing_auto_price_reduce {
  created_at: timestamptz!
  id: uuid!
  interval_days: Int!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  min_price: Int!
  percent: Int!
  price_updated_at: timestamptz
  updated_at: timestamptz!
  user_id: String!
}

"response of any mutation on the table \"listing_auto_price_reduce\""
type listing_auto_price_reduce_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [listing_auto_price_reduce!]!
}

"columns and relationships of \"listing_channels\""
type listing_channels {
  brand_id: uuid!
  display: String!
  id: uuid!
  "An object relationship"
  platform: listing_platforms!
  platform_id: uuid!
}

"columns and relationships of \"listing_event_types\""
type listing_event_types {
  type: String!
}

"columns and relationships of \"listing_events\""
type listing_events {
  event_type: listing_event_types_enum!
  id: uuid!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  listing_status: listing_statuses_enum
  payload(
    "JSON select path"
    path: String
  ): jsonb
  timestamp: timestamptz!
  "An object relationship"
  updated_by_user: users
  value: String!
}

"columns and relationships of \"listing_images\""
type listing_images {
  alt: String
  "An object relationship"
  condition_response: condition_responses
  condition_response_id: uuid
  created_at: timestamptz!
  hidden: Boolean!
  id: uuid!
  index: Int
  "An object relationship"
  listing: listings
  listing_id: uuid
  path: String
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  src: String!
  updated_at: timestamptz!
  user_id: String!
}

"response of any mutation on the table \"listing_images\""
type listing_images_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [listing_images!]!
}

"columns and relationships of \"listing_metadata\""
type listing_metadata {
  id: uuid!
  key: String!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  value(
    "JSON select path"
    path: String
  ): jsonb!
}

"response of any mutation on the table \"listing_metadata\""
type listing_metadata_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [listing_metadata!]!
}

"columns and relationships of \"listing_platforms\""
type listing_platforms {
  id: uuid!
  type: listing_platform_types_enum!
}

"columns and relationships of \"listing_relistings\""
type listing_relistings {
  new_listing_id: uuid!
  previous_listing_id: uuid!
}

"response of any mutation on the table \"listing_reviews\""
type listing_reviews_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
}

"columns and relationships of \"listing_statuses\""
type listing_statuses {
  status: String!
}

"columns and relationships of \"listing_user_action_timestamp\""
type listing_user_action_timestamp {
  id: uuid!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  user_action_timestamp: timestamptz!
}

"columns and relationships of \"listings\""
type listings {
  "An array relationship"
  auctions(
    "distinct select on columns"
    distinct_on: [auctions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auctions_order_by!],
    "filter the rows returned"
    where: auctions_bool_exp
  ): [auctions!]!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  bumped_at: timestamptz!
  "An object relationship"
  channel: listing_channels
  channel_id: uuid
  "An array relationship"
  condition_responses(
    "distinct select on columns"
    distinct_on: [condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_responses_order_by!],
    "filter the rows returned"
    where: condition_responses_bool_exp
  ): [condition_responses!]!
  condition_score: Int!
  confidence_score: Int!
  created_at: timestamptz!
  "An array relationship"
  events(
    "distinct select on columns"
    distinct_on: [listing_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_events_order_by!],
    "filter the rows returned"
    where: listing_events_bool_exp
  ): [listing_events!]!
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [listing_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_images_order_by!],
    "filter the rows returned"
    where: listing_images_bool_exp
  ): [listing_images!]!
  "An object relationship"
  listing_auto_price_reduce: listing_auto_price_reduce
  "An array relationship"
  listing_metadata(
    "distinct select on columns"
    distinct_on: [listing_metadata_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_metadata_order_by!],
    "filter the rows returned"
    where: listing_metadata_bool_exp
  ): [listing_metadata!]!
  "An object relationship"
  listing_user_action_timestamp: listing_user_action_timestamp
  "An array relationship"
  order_items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  order_items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  original_price: Int
  price: Int!
  "An object relationship"
  product: products
  product_id: uuid
  "An object relationship"
  relisted_listing: listing_relistings
  "An object relationship"
  return_shipping_label: shipping_labels
  return_shipping_label_id: uuid
  seller_comment: String
  "An object relationship"
  shipping_label: shipping_labels
  shipping_label_id: uuid
  "An array relationship"
  shipping_labels(
    "distinct select on columns"
    distinct_on: [shipping_labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_labels_order_by!],
    "filter the rows returned"
    where: shipping_labels_bool_exp
  ): [shipping_labels!]!
  "An object relationship"
  sku: skus
  sku_id: uuid
  status: listing_statuses_enum!
  "An object relationship"
  storefront: storefronts
  storefront_id: uuid
  "An object relationship"
  unassociated_listing_data: unassociated_listing_data
  unassociated_listing_data_id: uuid
  updated_at: timestamptz!
  "An object relationship"
  user: users!
  user_id: String!
  visibility: listing_visibilities_enum!
  "An array relationship"
  wms_items(
    "distinct select on columns"
    distinct_on: [wms_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [wms_items_order_by!],
    "filter the rows returned"
    where: wms_items_bool_exp
  ): [wms_items!]!
}

"aggregated selection of \"listings\""
type listings_aggregate {
  aggregate: listings_aggregate_fields
  nodes: [listings!]!
}

"aggregate fields of \"listings\""
type listings_aggregate_fields {
  avg: listings_avg_fields
  count(columns: [listings_select_column!], distinct: Boolean): Int!
  max: listings_max_fields
  min: listings_min_fields
  stddev: listings_stddev_fields
  stddev_pop: listings_stddev_pop_fields
  stddev_samp: listings_stddev_samp_fields
  sum: listings_sum_fields
  var_pop: listings_var_pop_fields
  var_samp: listings_var_samp_fields
  variance: listings_variance_fields
}

"aggregate avg on columns"
type listings_avg_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate max on columns"
type listings_max_fields {
  brand_id: uuid
  bumped_at: timestamptz
  channel_id: uuid
  condition_score: Int
  confidence_score: Int
  created_at: timestamptz
  id: uuid
  original_price: Int
  price: Int
  product_id: uuid
  return_shipping_label_id: uuid
  seller_comment: String
  shipping_label_id: uuid
  sku_id: uuid
  storefront_id: uuid
  unassociated_listing_data_id: uuid
  updated_at: timestamptz
  user_id: String
}

"aggregate min on columns"
type listings_min_fields {
  brand_id: uuid
  bumped_at: timestamptz
  channel_id: uuid
  condition_score: Int
  confidence_score: Int
  created_at: timestamptz
  id: uuid
  original_price: Int
  price: Int
  product_id: uuid
  return_shipping_label_id: uuid
  seller_comment: String
  shipping_label_id: uuid
  sku_id: uuid
  storefront_id: uuid
  unassociated_listing_data_id: uuid
  updated_at: timestamptz
  user_id: String
}

"response of any mutation on the table \"listings\""
type listings_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [listings!]!
}

"aggregate stddev on columns"
type listings_stddev_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate stddev_pop on columns"
type listings_stddev_pop_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate stddev_samp on columns"
type listings_stddev_samp_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate sum on columns"
type listings_sum_fields {
  condition_score: Int
  confidence_score: Int
  original_price: Int
  price: Int
}

"aggregate var_pop on columns"
type listings_var_pop_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate var_samp on columns"
type listings_var_samp_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"aggregate variance on columns"
type listings_variance_fields {
  condition_score: Float
  confidence_score: Float
  original_price: Float
  price: Float
}

"columns and relationships of \"mail_takebacks\""
type mail_takebacks {
  id: uuid!
  "An object relationship"
  return_address: addresses!
  return_shipping_address_id: uuid!
  "An object relationship"
  shipping_label: shipping_labels
  shipping_label_id: uuid
  "An object relationship"
  takeback: takebacks!
  takeback_id: uuid!
}

"columns and relationships of \"media_group_items\""
type media_group_items {
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  image: images!
  image_id: uuid!
  media_group_id: uuid!
  position: Int!
  updated_at: timestamptz!
}

"columns and relationships of \"media_groups\""
type media_groups {
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  items(
    "distinct select on columns"
    distinct_on: [media_group_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [media_group_items_order_by!],
    "filter the rows returned"
    where: media_group_items_bool_exp
  ): [media_group_items!]!
  type: String!
  updated_at: timestamptz!
}

"columns and relationships of \"mobile_uploads\""
type mobile_uploads {
  created_at: timestamptz!
  id: uuid!
  path: String!
  session_id: String!
}

"response of any mutation on the table \"mobile_uploads\""
type mobile_uploads_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [mobile_uploads!]!
}

"mutation root"
type mutation_root {
  acceptItem(listing_id: uuid!, seller_id: String!, storefront_id: String, user_id: String): AcceptItemResult
  addListingUserAction(listing_id: String!): AddListingUserActionResult!
  addVariantOptionsToSku(input: AddVariantOptionsToSkuInput): AddVariantOptionsToSkuOutput
  associateListing(brand_id: uuid!, listing_id: uuid!, product_id: uuid!, sku_id: uuid!): AssociateListingResult
  bulkCreateListings(input: BulkCreateListingsInput!): BulkCreateListingsResult!
  cancelOrder(input: CancelOrderInput!): CancelOrderResult
  cancelOrderItem(listing_id: uuid!): CancelOrderItemResult
  cancelReaderPaymentAction(brand_id: uuid!, pos_station_id: uuid!): CancelReaderPaymentActionResult
  cancelStoreTakeback(brand_id: uuid!, input: CancelStoreTakebackInput!): CancelStoreTakebackResult
  confirmImageEnhancement(action: String!, brand_id: String!, photo_enhancement_request_id: String!, target: String!, target_type: String!): ConfirmImageEnhancementOutput
  createCollection(input: CreateCollectionInput!): CreateCollectionResponse
  createCreditCardHold(paymentDetails: CreateCreditCardHoldInput!): CreateCreditCardHoldResult
  createDirectChat(input: CreateDirectChatInput!): CreateDirectChatResult!
  createDirectMessage(input: CreateDirectMessageInput!): CreateDirectMessageResult!
  createDonation(address: AddressInput!, brand_id: uuid!, donation_items: [DonationItemInput!]!, email: String!, mass_unit: String, preferred_language: String, user_id: String, weight: String): CreateDonationResult
  createFormSubmission(input: CreateFormSubmissionInput!): CreateFormSubmissionResult
  createListing(auto_price_reduce_input: String, listing_input: String!): CreateListingResult
  createMailTakeback(brand_id: uuid!, input: CreateMailTakebackInput!): CreateMailTakebackResult
  createManualCollection(input: CreateManualCollectionInput!): CreateManualCollectionResponse!
  createOrUpdateStorefront(create_or_update_storefront_input: CreateOrUpdateStorefrontInput!): CreateOrUpdateStorefrontResult
  createPaymentIntent(paymentDetails: CreatePaymentIntentInput!): CreatePaymentIntentResult
  createProductImages(input: CreateProductImagesInput): CreateProductImagesOutput
  createProductStyle(input: CreateProductStyleInput): CreateProductStyleOutput
  createProductStyleV2(input: CreateProductStyleV2Input): CreateProductStyleResult
  createProductStyleVariant(input: CreateProductStyleVariantInput!): CreateProductStyleVariantResult
  createProductStyleVariantMediaGroups(input: CreateProductStyleVariantMediaGroupsInput!): CreateProductStyleVariantMediaGroupsResult
  createProducts(input: CreateProductsInput): CreateProductsOutput
  createReturn(email: String!, preferred_language: String, return_address_id: uuid, return_items: [ReturnItemInput!]!): CreateReturnResult
  createReturnShippingLabel(listing_id: uuid!, return_address_id: uuid): CreateShippingLabelResult
  createSearchPage(input: CreateSearchPageInput!): CreateSearchPageResponse!
  createShippingLabel(listing_id: uuid!): CreateShippingLabelResult
  createShippingLabelv2(distance_units: String, height: String, length: String, listing_ids: [uuid!]!, mass_units: String, packing_station_id: uuid, weight: String, width: String): CreateShippingLabelResult
  createSingleSku(input: CreateSingleSkuInput!): CreateSingleSkuOutput
  createSkuImages(input: CreateSkuImagesInput): CreateSkuImagesOutput
  createSkus(input: CreateSkusInput): CreateSkusOutput
  createStoreDonation(brand_id: uuid!, input: CreateStoreDonationInput!): CreateStoreDonationResult
  createStoreTakeback(brand_id: uuid!, input: CreateStoreTakebackInput!): CreateStoreTakebackResult
  createStripeAccount(input: CreateStripeAccountInput!): CreateStripeAccountResult
  createVariantSkus(input: CreateVariantSkusInput): CreateVariantSkusOutput
  createVariantTypeOption(input: CreateVariantTypeOptionInput!): CreateVariantTypeOptionResult
  createVerificationSession(verificationSessionInput: CreateVerificationSessionInput!): CreateVerificationSessionResult
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionResponse
  deleteProductImages(input: DeleteProductImagesInput): DeleteProductImagesOutput
  deleteProductStyleVariants(input: DeleteProductStyleVariantsInput!): DeleteProductStyleVariantsResult
  deleteProducts(input: DeleteProductsInput): DeleteProductsOutput
  deleteSearchPage(input: DeleteSearchPageInput!): DeleteSearchPageResponse!
  deleteSkuImages(input: DeleteSkuImagesInput): DeleteSkuImagesOutput
  deleteSkus(input: DeleteSkusInput): DeleteSkusOutput
  deleteVariantOptionFromSku(input: DeleteVariantOptionFromSkuInput): DeleteVariantOptionFromSkuOutput
  "delete data from the table: \"condition_responses\""
  delete_condition_responses(
    "filter the rows which have to be deleted"
    where: condition_responses_bool_exp!
  ): condition_responses_mutation_response
  "delete single row from the table: \"condition_responses\""
  delete_condition_responses_by_pk(id: uuid!): condition_responses
  "delete data from the table: \"form_submissions\""
  delete_form_submissions(
    "filter the rows which have to be deleted"
    where: form_submissions_bool_exp!
  ): form_submissions_mutation_response
  "delete single row from the table: \"form_submissions\""
  delete_form_submissions_by_pk(id: uuid!): form_submissions
  "delete data from the table: \"listing_auto_price_reduce\""
  delete_listing_auto_price_reduce(
    "filter the rows which have to be deleted"
    where: listing_auto_price_reduce_bool_exp!
  ): listing_auto_price_reduce_mutation_response
  "delete single row from the table: \"listing_auto_price_reduce\""
  delete_listing_auto_price_reduce_by_pk(id: uuid!): listing_auto_price_reduce
  "delete data from the table: \"listing_images\""
  delete_listing_images(
    "filter the rows which have to be deleted"
    where: listing_images_bool_exp!
  ): listing_images_mutation_response
  "delete single row from the table: \"listing_images\""
  delete_listing_images_by_pk(id: uuid!): listing_images
  "delete data from the table: \"listing_metadata\""
  delete_listing_metadata(
    "filter the rows which have to be deleted"
    where: listing_metadata_bool_exp!
  ): listing_metadata_mutation_response
  "delete single row from the table: \"listing_metadata\""
  delete_listing_metadata_by_pk(id: uuid!): listing_metadata
  "delete data from the table: \"listings\""
  delete_listings(
    "filter the rows which have to be deleted"
    where: listings_bool_exp!
  ): listings_mutation_response
  "delete single row from the table: \"listings\""
  delete_listings_by_pk(id: uuid!): listings
  "delete data from the table: \"mobile_uploads\""
  delete_mobile_uploads(
    "filter the rows which have to be deleted"
    where: mobile_uploads_bool_exp!
  ): mobile_uploads_mutation_response
  "delete single row from the table: \"mobile_uploads\""
  delete_mobile_uploads_by_pk(id: uuid!): mobile_uploads
  "delete data from the table: \"user_addresses\""
  delete_user_addresses(
    "filter the rows which have to be deleted"
    where: user_addresses_bool_exp!
  ): user_addresses_mutation_response
  "delete single row from the table: \"user_addresses\""
  delete_user_addresses_by_pk(id: uuid!): user_addresses
  "delete data from the table: \"user_alerts\""
  delete_user_alerts(
    "filter the rows which have to be deleted"
    where: user_alerts_bool_exp!
  ): user_alerts_mutation_response
  "delete single row from the table: \"user_alerts\""
  delete_user_alerts_by_pk(id: uuid!): user_alerts
  "delete data from the table: \"user_favorites\""
  delete_user_favorites(
    "filter the rows which have to be deleted"
    where: user_favorites_bool_exp!
  ): user_favorites_mutation_response
  "delete single row from the table: \"user_favorites\""
  delete_user_favorites_by_pk(id: uuid!): user_favorites
  disputeItem(listing_id: uuid!): DisputeItemResult
  editListing(auto_price_reduce_input: String, condition_responses_input: String!, id: uuid!, images_input: String!, listing_input: String!, listing_metadata_input: String): CreateListingResult
  editListingImageOrder(input: EditListingImageOrderInput!): EditListingImageOrderResult!
  enhancePhoto(brand_id: uuid!, fk_id: uuid, fk_type: String, photo_enhancement_type: String!, src: String!): EnhancePhotoResult
  "insert data into the table: \"addresses\""
  insert_addresses(
    "the rows to be inserted"
    objects: [addresses_insert_input!]!,
    "upsert condition"
    on_conflict: addresses_on_conflict
  ): addresses_mutation_response
  "insert a single row into the table: \"addresses\""
  insert_addresses_one(
    "the row to be inserted"
    object: addresses_insert_input!,
    "upsert condition"
    on_conflict: addresses_on_conflict
  ): addresses
  "insert data into the table: \"attempted_discount_codes\""
  insert_attempted_discount_codes(
    "the rows to be inserted"
    objects: [attempted_discount_codes_insert_input!]!,
    "upsert condition"
    on_conflict: attempted_discount_codes_on_conflict
  ): attempted_discount_codes_mutation_response
  "insert a single row into the table: \"attempted_discount_codes\""
  insert_attempted_discount_codes_one(
    "the row to be inserted"
    object: attempted_discount_codes_insert_input!,
    "upsert condition"
    on_conflict: attempted_discount_codes_on_conflict
  ): attempted_discount_codes
  "insert data into the table: \"auction_bids\""
  insert_auction_bids(
    "the rows to be inserted"
    objects: [auction_bids_insert_input!]!,
    "upsert condition"
    on_conflict: auction_bids_on_conflict
  ): auction_bids_mutation_response
  "insert a single row into the table: \"auction_bids\""
  insert_auction_bids_one(
    "the row to be inserted"
    object: auction_bids_insert_input!,
    "upsert condition"
    on_conflict: auction_bids_on_conflict
  ): auction_bids
  "insert data into the table: \"condition_responses\""
  insert_condition_responses(
    "the rows to be inserted"
    objects: [condition_responses_insert_input!]!,
    "upsert condition"
    on_conflict: condition_responses_on_conflict
  ): condition_responses_mutation_response
  "insert a single row into the table: \"condition_responses\""
  insert_condition_responses_one(
    "the row to be inserted"
    object: condition_responses_insert_input!,
    "upsert condition"
    on_conflict: condition_responses_on_conflict
  ): condition_responses
  "insert data into the table: \"email_signups\""
  insert_email_signups(
    "the rows to be inserted"
    objects: [email_signups_insert_input!]!,
    "upsert condition"
    on_conflict: email_signups_on_conflict
  ): email_signups_mutation_response
  "insert data into the table: \"form_submissions\""
  insert_form_submissions(
    "the rows to be inserted"
    objects: [form_submissions_insert_input!]!,
    "upsert condition"
    on_conflict: form_submissions_on_conflict
  ): form_submissions_mutation_response
  "insert a single row into the table: \"form_submissions\""
  insert_form_submissions_one(
    "the row to be inserted"
    object: form_submissions_insert_input!,
    "upsert condition"
    on_conflict: form_submissions_on_conflict
  ): form_submissions
  "insert data into the table: \"listing_auto_price_reduce\""
  insert_listing_auto_price_reduce(
    "the rows to be inserted"
    objects: [listing_auto_price_reduce_insert_input!]!,
    "upsert condition"
    on_conflict: listing_auto_price_reduce_on_conflict
  ): listing_auto_price_reduce_mutation_response
  "insert a single row into the table: \"listing_auto_price_reduce\""
  insert_listing_auto_price_reduce_one(
    "the row to be inserted"
    object: listing_auto_price_reduce_insert_input!,
    "upsert condition"
    on_conflict: listing_auto_price_reduce_on_conflict
  ): listing_auto_price_reduce
  "insert data into the table: \"listing_images\""
  insert_listing_images(
    "the rows to be inserted"
    objects: [listing_images_insert_input!]!,
    "upsert condition"
    on_conflict: listing_images_on_conflict
  ): listing_images_mutation_response
  "insert a single row into the table: \"listing_images\""
  insert_listing_images_one(
    "the row to be inserted"
    object: listing_images_insert_input!,
    "upsert condition"
    on_conflict: listing_images_on_conflict
  ): listing_images
  "insert data into the table: \"listing_metadata\""
  insert_listing_metadata(
    "the rows to be inserted"
    objects: [listing_metadata_insert_input!]!,
    "upsert condition"
    on_conflict: listing_metadata_on_conflict
  ): listing_metadata_mutation_response
  "insert a single row into the table: \"listing_metadata\""
  insert_listing_metadata_one(
    "the row to be inserted"
    object: listing_metadata_insert_input!,
    "upsert condition"
    on_conflict: listing_metadata_on_conflict
  ): listing_metadata
  "insert data into the table: \"listing_reviews\""
  insert_listing_reviews(
    "the rows to be inserted"
    objects: [listing_reviews_insert_input!]!,
    "upsert condition"
    on_conflict: listing_reviews_on_conflict
  ): listing_reviews_mutation_response
  "insert data into the table: \"mobile_uploads\""
  insert_mobile_uploads(
    "the rows to be inserted"
    objects: [mobile_uploads_insert_input!]!,
    "upsert condition"
    on_conflict: mobile_uploads_on_conflict
  ): mobile_uploads_mutation_response
  "insert a single row into the table: \"mobile_uploads\""
  insert_mobile_uploads_one(
    "the row to be inserted"
    object: mobile_uploads_insert_input!,
    "upsert condition"
    on_conflict: mobile_uploads_on_conflict
  ): mobile_uploads
  "insert data into the table: \"order_addresses\""
  insert_order_addresses(
    "the rows to be inserted"
    objects: [order_addresses_insert_input!]!,
    "upsert condition"
    on_conflict: order_addresses_on_conflict
  ): order_addresses_mutation_response
  "insert a single row into the table: \"order_addresses\""
  insert_order_addresses_one(
    "the row to be inserted"
    object: order_addresses_insert_input!,
    "upsert condition"
    on_conflict: order_addresses_on_conflict
  ): order_addresses
  "insert data into the table: \"order_intent_items\""
  insert_order_intent_items(
    "the rows to be inserted"
    objects: [order_intent_items_insert_input!]!,
    "upsert condition"
    on_conflict: order_intent_items_on_conflict
  ): order_intent_items_mutation_response
  "insert a single row into the table: \"order_intent_items\""
  insert_order_intent_items_one(
    "the row to be inserted"
    object: order_intent_items_insert_input!,
    "upsert condition"
    on_conflict: order_intent_items_on_conflict
  ): order_intent_items
  "insert data into the table: \"order_intents\""
  insert_order_intents(
    "the rows to be inserted"
    objects: [order_intents_insert_input!]!,
    "upsert condition"
    on_conflict: order_intents_on_conflict
  ): order_intents_mutation_response
  "insert a single row into the table: \"order_intents\""
  insert_order_intents_one(
    "the row to be inserted"
    object: order_intents_insert_input!,
    "upsert condition"
    on_conflict: order_intents_on_conflict
  ): order_intents
  "insert data into the table: \"order_items\""
  insert_order_items(
    "the rows to be inserted"
    objects: [order_items_insert_input!]!,
    "upsert condition"
    on_conflict: order_items_on_conflict
  ): order_items_mutation_response
  "insert a single row into the table: \"order_items\""
  insert_order_items_one(
    "the row to be inserted"
    object: order_items_insert_input!,
    "upsert condition"
    on_conflict: order_items_on_conflict
  ): order_items
  "insert data into the table: \"orders\""
  insert_orders(
    "the rows to be inserted"
    objects: [orders_insert_input!]!,
    "upsert condition"
    on_conflict: orders_on_conflict
  ): orders_mutation_response
  "insert a single row into the table: \"orders\""
  insert_orders_one(
    "the row to be inserted"
    object: orders_insert_input!,
    "upsert condition"
    on_conflict: orders_on_conflict
  ): orders
  "insert data into the table: \"orphan_condition_responses\""
  insert_orphan_condition_responses(
    "the rows to be inserted"
    objects: [orphan_condition_responses_insert_input!]!,
    "upsert condition"
    on_conflict: orphan_condition_responses_on_conflict
  ): orphan_condition_responses_mutation_response
  "insert a single row into the table: \"orphan_condition_responses\""
  insert_orphan_condition_responses_one(
    "the row to be inserted"
    object: orphan_condition_responses_insert_input!,
    "upsert condition"
    on_conflict: orphan_condition_responses_on_conflict
  ): orphan_condition_responses
  "insert data into the table: \"orphan_listings\""
  insert_orphan_listings(
    "the rows to be inserted"
    objects: [orphan_listings_insert_input!]!,
    "upsert condition"
    on_conflict: orphan_listings_on_conflict
  ): orphan_listings_mutation_response
  "insert data into the table: \"orphan_listings_images\""
  insert_orphan_listings_images(
    "the rows to be inserted"
    objects: [orphan_listings_images_insert_input!]!,
    "upsert condition"
    on_conflict: orphan_listings_images_on_conflict
  ): orphan_listings_images_mutation_response
  "insert a single row into the table: \"orphan_listings_images\""
  insert_orphan_listings_images_one(
    "the row to be inserted"
    object: orphan_listings_images_insert_input!,
    "upsert condition"
    on_conflict: orphan_listings_images_on_conflict
  ): orphan_listings_images
  "insert a single row into the table: \"orphan_listings\""
  insert_orphan_listings_one(
    "the row to be inserted"
    object: orphan_listings_insert_input!,
    "upsert condition"
    on_conflict: orphan_listings_on_conflict
  ): orphan_listings
  "insert data into the table: \"pos_events\""
  insert_pos_events(
    "the rows to be inserted"
    objects: [pos_events_insert_input!]!,
    "upsert condition"
    on_conflict: pos_events_on_conflict
  ): pos_events_mutation_response
  "insert data into the table: \"return_items\""
  insert_return_items(
    "the rows to be inserted"
    objects: [return_items_insert_input!]!,
    "upsert condition"
    on_conflict: return_items_on_conflict
  ): return_items_mutation_response
  "insert a single row into the table: \"return_items\""
  insert_return_items_one(
    "the row to be inserted"
    object: return_items_insert_input!,
    "upsert condition"
    on_conflict: return_items_on_conflict
  ): return_items
  "insert data into the table: \"returns\""
  insert_returns(
    "the rows to be inserted"
    objects: [returns_insert_input!]!,
    "upsert condition"
    on_conflict: returns_on_conflict
  ): returns_mutation_response
  "insert a single row into the table: \"returns\""
  insert_returns_one(
    "the row to be inserted"
    object: returns_insert_input!,
    "upsert condition"
    on_conflict: returns_on_conflict
  ): returns
  "insert data into the table: \"seller_ratings\""
  insert_seller_ratings(
    "the rows to be inserted"
    objects: [seller_ratings_insert_input!]!,
    "upsert condition"
    on_conflict: seller_ratings_on_conflict
  ): seller_ratings_mutation_response
  "insert a single row into the table: \"seller_ratings\""
  insert_seller_ratings_one(
    "the row to be inserted"
    object: seller_ratings_insert_input!,
    "upsert condition"
    on_conflict: seller_ratings_on_conflict
  ): seller_ratings
  "insert data into the table: \"shipping_information\""
  insert_shipping_information(
    "the rows to be inserted"
    objects: [shipping_information_insert_input!]!,
    "upsert condition"
    on_conflict: shipping_information_on_conflict
  ): shipping_information_mutation_response
  "insert a single row into the table: \"shipping_information\""
  insert_shipping_information_one(
    "the row to be inserted"
    object: shipping_information_insert_input!,
    "upsert condition"
    on_conflict: shipping_information_on_conflict
  ): shipping_information
  "insert data into the table: \"storefront_reviews\""
  insert_storefront_reviews(
    "the rows to be inserted"
    objects: [storefront_reviews_insert_input!]!,
    "upsert condition"
    on_conflict: storefront_reviews_on_conflict
  ): storefront_reviews_mutation_response
  "insert a single row into the table: \"storefront_reviews\""
  insert_storefront_reviews_one(
    "the row to be inserted"
    object: storefront_reviews_insert_input!,
    "upsert condition"
    on_conflict: storefront_reviews_on_conflict
  ): storefront_reviews
  "insert data into the table: \"user_addresses\""
  insert_user_addresses(
    "the rows to be inserted"
    objects: [user_addresses_insert_input!]!,
    "upsert condition"
    on_conflict: user_addresses_on_conflict
  ): user_addresses_mutation_response
  "insert a single row into the table: \"user_addresses\""
  insert_user_addresses_one(
    "the row to be inserted"
    object: user_addresses_insert_input!,
    "upsert condition"
    on_conflict: user_addresses_on_conflict
  ): user_addresses
  "insert data into the table: \"user_alerts\""
  insert_user_alerts(
    "the rows to be inserted"
    objects: [user_alerts_insert_input!]!,
    "upsert condition"
    on_conflict: user_alerts_on_conflict
  ): user_alerts_mutation_response
  "insert a single row into the table: \"user_alerts\""
  insert_user_alerts_one(
    "the row to be inserted"
    object: user_alerts_insert_input!,
    "upsert condition"
    on_conflict: user_alerts_on_conflict
  ): user_alerts
  "insert data into the table: \"user_favorites\""
  insert_user_favorites(
    "the rows to be inserted"
    objects: [user_favorites_insert_input!]!,
    "upsert condition"
    on_conflict: user_favorites_on_conflict
  ): user_favorites_mutation_response
  "insert a single row into the table: \"user_favorites\""
  insert_user_favorites_one(
    "the row to be inserted"
    object: user_favorites_insert_input!,
    "upsert condition"
    on_conflict: user_favorites_on_conflict
  ): user_favorites
  "insert data into the table: \"user_verification_checks\""
  insert_user_verification_checks(
    "the rows to be inserted"
    objects: [user_verification_checks_insert_input!]!,
    "upsert condition"
    on_conflict: user_verification_checks_on_conflict
  ): user_verification_checks_mutation_response
  "insert a single row into the table: \"user_verification_checks\""
  insert_user_verification_checks_one(
    "the row to be inserted"
    object: user_verification_checks_insert_input!,
    "upsert condition"
    on_conflict: user_verification_checks_on_conflict
  ): user_verification_checks
  "insert data into the table: \"users\""
  insert_users(
    "the rows to be inserted"
    objects: [users_insert_input!]!,
    "upsert condition"
    on_conflict: users_on_conflict
  ): users_mutation_response
  "insert a single row into the table: \"users\""
  insert_users_one(
    "the row to be inserted"
    object: users_insert_input!,
    "upsert condition"
    on_conflict: users_on_conflict
  ): users
  linkExternalAccount(input: LinkExternalAccountInput!): LinkExternalAccountResponse
  processCartCheckout(input: ProcessCartCheckoutInput!): ProcessCartCheckoutResult
  processCartCheckoutV2(input: ProcessCartCheckoutInputV2!): ProcessCartCheckoutResultV2
  processReaderPaymentIntent(brand_id: uuid!, payment_intent_id: String!, pos_station_id: uuid!): ProcessReaderPaymentIntentResult
  provisionUser(input: ProvisionUserInput!): ProvisionUserResult
  "Intended to be used in-store. For admins, reissueGiftCard has less checks and is more appropriate."
  reissueStoreTakebackCredit(brand_id: uuid!, input: ReissueStoreTakebackCreditInput!): ReissueStoreTakebackCreditResult
  requestPasswordResetEmailV2(brand_id: uuid!, input: RequestPasswordResetEmailInputV2!): RequestPasswordResetEmailResultV2
  requestStoreCredit(amount: Int!, brand_id: uuid!, email: String!, storefront_id: uuid): RequestStoreCreditResult
  requestStoreCreditRetailTakeback(amount: Int!, brand_id: uuid!, takeback_id: uuid!): TakebackRequestStoreCreditResult
  requestTakeback(brand_id: uuid!, email: String!, first_name: String, last_name: String): RequestTakebackOutput
  resetPassword(input: ResetPasswordInput!): ResetPasswordResult
  sellerCloneListing(input: SellerCloneListingInput!): SellerCloneListingResult!
  setBrandSort(brand_id: uuid!, input: SetBrandSortInput!): SetBrandSortResult!
  setListingImages(input: SetListingImagesInput): SetListingImagesResult
  setRetailAssociatePin(brand_id: uuid!, current_pin: String!, new_pin: String!, store_number: String!): SetupRetailAssociateOutput
  setUserMetadata(input: SetUserMetadataInput!): SetUserMetadataResponse
  setUserPreferredLanguage(input: SetUserPreferredLanguageInput!): SetUserPreferredLanguageResult!
  showHideListing(id: uuid!, status: String!): ShowHideListingResult
  submitListingReview(brand_id: uuid!, listing_id: uuid!, review: ListingReviewInput!): SubmitListingReviewResult
  submitWorkflowItem(input: SubmitWorkflowItemInput!): SubmitWorkflowItemResult!
  unlistListings(brand_id: String!, listing_ids: [String!]!, put_in_review: Boolean): UnlistListingsResult!
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionResponse
  updateFormSubmission(input: UpdateFormSubmissionInput!): UpdateFormSubmissionResult
  updateInStorePickupStatus(brand_id: uuid!, in_store_pickup_ids: [uuid!]!, status: String): UpdateInStorePickupStatusResult
  updateManualCollectionItems(input: UpdateManualCollectionItemsInput!): UpdateManualCollectionItemsResponse
  updateMediaGroup(input: UpdateMediaGroupInput!): UpdateMediaGroupResult
  updateProduct(input: UpdateProductInput): UpdateProductOutput
  updateProductImages(input: UpdateProductImagesInput): UpdateProductImagesOutput
  updateProductStyle(input: UpdateProductStyleInput): UpdateProductStyleOutput
  updateProductStyleV2(input: UpdateProductStyleV2Input): UpdateProductStyleV2Result
  updateProductStyleVariant(input: UpdateProductStyleVariantInput!): UpdateProductStyleVariantsResult
  updateSearchPage(input: UpdateSearchPageInput!): UpdateSearchPageResponse!
  updateSkuImages(input: UpdateSkuImagesInput): UpdateSkuImagesOutput
  updateSkus(input: UpdateSkusInput): UpdateSkusOutput
  updateStoreTakebackUser(brand_id: uuid!, input: UpdateStoreTakebackUserInput!): UpdateStoreTakebackUserResult
  "update data of the table: \"email_signups\""
  update_email_signups(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: email_signups_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: email_signups_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: email_signups_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: email_signups_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: email_signups_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: email_signups_set_input,
    "filter the rows which have to be updated"
    where: email_signups_bool_exp!
  ): email_signups_mutation_response
  "update multiples rows of table: \"email_signups\""
  update_email_signups_many(
    "updates to execute, in order"
    updates: [email_signups_updates!]!
  ): [email_signups_mutation_response]
  "update data of the table: \"listing_auto_price_reduce\""
  update_listing_auto_price_reduce(
    "increments the numeric columns with given value of the filtered values"
    _inc: listing_auto_price_reduce_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: listing_auto_price_reduce_set_input,
    "filter the rows which have to be updated"
    where: listing_auto_price_reduce_bool_exp!
  ): listing_auto_price_reduce_mutation_response
  "update single row of the table: \"listing_auto_price_reduce\""
  update_listing_auto_price_reduce_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: listing_auto_price_reduce_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: listing_auto_price_reduce_set_input,
    pk_columns: listing_auto_price_reduce_pk_columns_input!
  ): listing_auto_price_reduce
  "update multiples rows of table: \"listing_auto_price_reduce\""
  update_listing_auto_price_reduce_many(
    "updates to execute, in order"
    updates: [listing_auto_price_reduce_updates!]!
  ): [listing_auto_price_reduce_mutation_response]
  "update data of the table: \"listing_metadata\""
  update_listing_metadata(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: listing_metadata_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: listing_metadata_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: listing_metadata_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: listing_metadata_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: listing_metadata_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: listing_metadata_set_input,
    "filter the rows which have to be updated"
    where: listing_metadata_bool_exp!
  ): listing_metadata_mutation_response
  "update single row of the table: \"listing_metadata\""
  update_listing_metadata_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: listing_metadata_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: listing_metadata_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: listing_metadata_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: listing_metadata_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: listing_metadata_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: listing_metadata_set_input,
    pk_columns: listing_metadata_pk_columns_input!
  ): listing_metadata
  "update multiples rows of table: \"listing_metadata\""
  update_listing_metadata_many(
    "updates to execute, in order"
    updates: [listing_metadata_updates!]!
  ): [listing_metadata_mutation_response]
  "update data of the table: \"seller_ratings\""
  update_seller_ratings(
    "increments the numeric columns with given value of the filtered values"
    _inc: seller_ratings_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: seller_ratings_set_input,
    "filter the rows which have to be updated"
    where: seller_ratings_bool_exp!
  ): seller_ratings_mutation_response
  "update single row of the table: \"seller_ratings\""
  update_seller_ratings_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: seller_ratings_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: seller_ratings_set_input,
    pk_columns: seller_ratings_pk_columns_input!
  ): seller_ratings
  "update multiples rows of table: \"seller_ratings\""
  update_seller_ratings_many(
    "updates to execute, in order"
    updates: [seller_ratings_updates!]!
  ): [seller_ratings_mutation_response]
  "update data of the table: \"shipping_information\""
  update_shipping_information(
    "sets the columns of the filtered rows to the given values"
    _set: shipping_information_set_input,
    "filter the rows which have to be updated"
    where: shipping_information_bool_exp!
  ): shipping_information_mutation_response
  "update single row of the table: \"shipping_information\""
  update_shipping_information_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: shipping_information_set_input,
    pk_columns: shipping_information_pk_columns_input!
  ): shipping_information
  "update multiples rows of table: \"shipping_information\""
  update_shipping_information_many(
    "updates to execute, in order"
    updates: [shipping_information_updates!]!
  ): [shipping_information_mutation_response]
  "update data of the table: \"storefronts\""
  update_storefronts(
    "sets the columns of the filtered rows to the given values"
    _set: storefronts_set_input,
    "filter the rows which have to be updated"
    where: storefronts_bool_exp!
  ): storefronts_mutation_response
  "update single row of the table: \"storefronts\""
  update_storefronts_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: storefronts_set_input,
    pk_columns: storefronts_pk_columns_input!
  ): storefronts
  "update multiples rows of table: \"storefronts\""
  update_storefronts_many(
    "updates to execute, in order"
    updates: [storefronts_updates!]!
  ): [storefronts_mutation_response]
  "update data of the table: \"user_addresses\""
  update_user_addresses(
    "increments the numeric columns with given value of the filtered values"
    _inc: user_addresses_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_addresses_set_input,
    "filter the rows which have to be updated"
    where: user_addresses_bool_exp!
  ): user_addresses_mutation_response
  "update single row of the table: \"user_addresses\""
  update_user_addresses_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: user_addresses_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_addresses_set_input,
    pk_columns: user_addresses_pk_columns_input!
  ): user_addresses
  "update multiples rows of table: \"user_addresses\""
  update_user_addresses_many(
    "updates to execute, in order"
    updates: [user_addresses_updates!]!
  ): [user_addresses_mutation_response]
  "update data of the table: \"user_alerts\""
  update_user_alerts(
    "sets the columns of the filtered rows to the given values"
    _set: user_alerts_set_input,
    "filter the rows which have to be updated"
    where: user_alerts_bool_exp!
  ): user_alerts_mutation_response
  "update single row of the table: \"user_alerts\""
  update_user_alerts_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: user_alerts_set_input,
    pk_columns: user_alerts_pk_columns_input!
  ): user_alerts
  "update multiples rows of table: \"user_alerts\""
  update_user_alerts_many(
    "updates to execute, in order"
    updates: [user_alerts_updates!]!
  ): [user_alerts_mutation_response]
  "update data of the table: \"user_favorites\""
  update_user_favorites(
    "sets the columns of the filtered rows to the given values"
    _set: user_favorites_set_input,
    "filter the rows which have to be updated"
    where: user_favorites_bool_exp!
  ): user_favorites_mutation_response
  "update single row of the table: \"user_favorites\""
  update_user_favorites_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: user_favorites_set_input,
    pk_columns: user_favorites_pk_columns_input!
  ): user_favorites
  "update multiples rows of table: \"user_favorites\""
  update_user_favorites_many(
    "updates to execute, in order"
    updates: [user_favorites_updates!]!
  ): [user_favorites_mutation_response]
  "update data of the table: \"users\""
  update_users(
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input,
    "filter the rows which have to be updated"
    where: users_bool_exp!
  ): users_mutation_response
  "update single row of the table: \"users\""
  update_users_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input,
    pk_columns: users_pk_columns_input!
  ): users
  "update multiples rows of table: \"users\""
  update_users_many(
    "updates to execute, in order"
    updates: [users_updates!]!
  ): [users_mutation_response]
  "update data of the table: \"workflow_items\""
  update_workflow_items(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: workflow_items_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: workflow_items_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: workflow_items_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: workflow_items_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: workflow_items_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: workflow_items_set_input,
    "filter the rows which have to be updated"
    where: workflow_items_bool_exp!
  ): workflow_items_mutation_response
  "update single row of the table: \"workflow_items\""
  update_workflow_items_by_pk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: workflow_items_append_input,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _delete_at_path: workflow_items_delete_at_path_input,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _delete_elem: workflow_items_delete_elem_input,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _delete_key: workflow_items_delete_key_input,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: workflow_items_prepend_input,
    "sets the columns of the filtered rows to the given values"
    _set: workflow_items_set_input,
    pk_columns: workflow_items_pk_columns_input!
  ): workflow_items
  "update multiples rows of table: \"workflow_items\""
  update_workflow_items_many(
    "updates to execute, in order"
    updates: [workflow_items_updates!]!
  ): [workflow_items_mutation_response]
  verifyEmail(input: VerifyEmailInput!): VerifyEmailResult!
  withdrawBalance(account_id: String!, amount: Int!, brand_id: uuid!, fee: Int!, storefront_id: uuid): WithdrawBalanceResult
}

"columns and relationships of \"order_addresses\""
type order_addresses {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  country: String!
  id: uuid!
  locality: String!
  name: String!
  organization: String
  phone_number: String
  postal_code: String!
  user_id: String
}

"response of any mutation on the table \"order_addresses\""
type order_addresses_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [order_addresses!]!
}

"columns and relationships of \"order_intent_items\""
type order_intent_items {
  "An object relationship"
  fulfillment_intent: fulfillment_intents
  id: uuid!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  "An object relationship"
  order_intent: order_intents!
  order_intent_id: uuid!
  price: Int!
  "An object relationship"
  shipping_information: shipping_information
  shipping_information_id: uuid
  tax: Int!
  updated_at: timestamptz!
  "An object relationship"
  user: users
  user_id: String
}

"response of any mutation on the table \"order_intent_items\""
type order_intent_items_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [order_intent_items!]!
}

"columns and relationships of \"order_intents\""
type order_intents {
  "An array relationship"
  attempted_discount_codes(
    "distinct select on columns"
    distinct_on: [attempted_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attempted_discount_codes_order_by!],
    "filter the rows returned"
    where: attempted_discount_codes_bool_exp
  ): [attempted_discount_codes!]!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  items(
    "distinct select on columns"
    distinct_on: [order_intent_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_intent_items_order_by!],
    "filter the rows returned"
    where: order_intent_items_bool_exp
  ): [order_intent_items!]!
  order_number: String!
  preferred_language: String
  shipping: Int!
  "An object relationship"
  shipping_address: order_addresses
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_intent_statuses_enum!
  stripe_payment_id: String
  subtotal: Int!
  tax: Int!
  total: Int!
  updated_at: timestamptz!
  "An object relationship"
  user: users
  user_id: String
}

"response of any mutation on the table \"order_intents\""
type order_intents_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [order_intents!]!
}

"columns and relationships of \"order_items\""
type order_items {
  "An object relationship"
  fulfillment: fulfillments
  "An object relationship"
  fulfillment_intent: fulfillment_intents
  id: uuid!
  "An object relationship"
  listing: listings!
  listing_id: uuid!
  "An object relationship"
  order: orders!
  order_id: uuid!
  price: Int!
  "An array relationship"
  return_items(
    "distinct select on columns"
    distinct_on: [return_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [return_items_order_by!],
    "filter the rows returned"
    where: return_items_bool_exp
  ): [return_items!]!
  "An object relationship"
  shipping_information: shipping_information
  tax: Int!
  "An object relationship"
  user: users
  user_id: String
}

"aggregated selection of \"order_items\""
type order_items_aggregate {
  aggregate: order_items_aggregate_fields
  nodes: [order_items!]!
}

"aggregate fields of \"order_items\""
type order_items_aggregate_fields {
  avg: order_items_avg_fields
  count(columns: [order_items_select_column!], distinct: Boolean): Int!
  max: order_items_max_fields
  min: order_items_min_fields
  stddev: order_items_stddev_fields
  stddev_pop: order_items_stddev_pop_fields
  stddev_samp: order_items_stddev_samp_fields
  sum: order_items_sum_fields
  var_pop: order_items_var_pop_fields
  var_samp: order_items_var_samp_fields
  variance: order_items_variance_fields
}

"aggregate avg on columns"
type order_items_avg_fields {
  price: Float
  tax: Float
}

"aggregate max on columns"
type order_items_max_fields {
  id: uuid
  listing_id: uuid
  order_id: uuid
  price: Int
  tax: Int
  user_id: String
}

"aggregate min on columns"
type order_items_min_fields {
  id: uuid
  listing_id: uuid
  order_id: uuid
  price: Int
  tax: Int
  user_id: String
}

"response of any mutation on the table \"order_items\""
type order_items_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [order_items!]!
}

"aggregate stddev on columns"
type order_items_stddev_fields {
  price: Float
  tax: Float
}

"aggregate stddev_pop on columns"
type order_items_stddev_pop_fields {
  price: Float
  tax: Float
}

"aggregate stddev_samp on columns"
type order_items_stddev_samp_fields {
  price: Float
  tax: Float
}

"aggregate sum on columns"
type order_items_sum_fields {
  price: Int
  tax: Int
}

"aggregate var_pop on columns"
type order_items_var_pop_fields {
  price: Float
  tax: Float
}

"aggregate var_samp on columns"
type order_items_var_samp_fields {
  price: Float
  tax: Float
}

"aggregate variance on columns"
type order_items_variance_fields {
  price: Float
  tax: Float
}

"columns and relationships of \"order_statuses\""
type order_statuses {
  status: String!
}

"columns and relationships of \"orders\""
type orders {
  "An array relationship"
  applied_discount_codes(
    "distinct select on columns"
    distinct_on: [applied_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [applied_discount_codes_order_by!],
    "filter the rows returned"
    where: applied_discount_codes_bool_exp
  ): [applied_discount_codes!]!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  order_number: String!
  preferred_language: String
  shipping: Int!
  "An object relationship"
  shipping_address: order_addresses
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_statuses_enum!
  stripe_payment_id: String
  subtotal: Int!
  tax: Int!
  total: Int!
  updated_at: timestamptz!
  "An object relationship"
  user: users
  user_id: String
}

"aggregated selection of \"orders\""
type orders_aggregate {
  aggregate: orders_aggregate_fields
  nodes: [orders!]!
}

"aggregate fields of \"orders\""
type orders_aggregate_fields {
  avg: orders_avg_fields
  count(columns: [orders_select_column!], distinct: Boolean): Int!
  max: orders_max_fields
  min: orders_min_fields
  stddev: orders_stddev_fields
  stddev_pop: orders_stddev_pop_fields
  stddev_samp: orders_stddev_samp_fields
  sum: orders_sum_fields
  var_pop: orders_var_pop_fields
  var_samp: orders_var_samp_fields
  variance: orders_variance_fields
}

"aggregate avg on columns"
type orders_avg_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate max on columns"
type orders_max_fields {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"aggregate min on columns"
type orders_min_fields {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"response of any mutation on the table \"orders\""
type orders_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [orders!]!
}

"aggregate stddev on columns"
type orders_stddev_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate stddev_pop on columns"
type orders_stddev_pop_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate stddev_samp on columns"
type orders_stddev_samp_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate sum on columns"
type orders_sum_fields {
  shipping: Int
  shipping_tax: Int
  subtotal: Int
  tax: Int
  total: Int
}

"aggregate var_pop on columns"
type orders_var_pop_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate var_samp on columns"
type orders_var_samp_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"aggregate variance on columns"
type orders_variance_fields {
  shipping: Float
  shipping_tax: Float
  subtotal: Float
  tax: Float
  total: Float
}

"columns and relationships of \"orphan_condition_responses\""
type orphan_condition_responses {
  comment: String
  "An object relationship"
  condition_question: condition_questions!
  condition_question_id: uuid!
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [orphan_listings_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_images_order_by!],
    "filter the rows returned"
    where: orphan_listings_images_bool_exp
  ): [orphan_listings_images!]!
  listing_id: uuid!
  "An object relationship"
  orphan_listing: orphan_listings!
  response: Boolean!
  score: Int!
  severity: Int!
  "An object relationship"
  user: users!
  user_id: String!
}

"response of any mutation on the table \"orphan_condition_responses\""
type orphan_condition_responses_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [orphan_condition_responses!]!
}

"columns and relationships of \"orphan_listings\""
type orphan_listings {
  brand_id: uuid!
  color: String!
  "An array relationship"
  condition_responses(
    "distinct select on columns"
    distinct_on: [orphan_condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_condition_responses_order_by!],
    "filter the rows returned"
    where: orphan_condition_responses_bool_exp
  ): [orphan_condition_responses!]!
  created_at: timestamptz!
  description: String!
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [orphan_listings_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_images_order_by!],
    "filter the rows returned"
    where: orphan_listings_images_bool_exp
  ): [orphan_listings_images!]!
  product_link: String
  size: String
  title: String!
  updated_at: timestamptz!
  user_id: String!
}

"aggregated selection of \"orphan_listings\""
type orphan_listings_aggregate {
  aggregate: orphan_listings_aggregate_fields
  nodes: [orphan_listings!]!
}

"aggregate fields of \"orphan_listings\""
type orphan_listings_aggregate_fields {
  count(columns: [orphan_listings_select_column!], distinct: Boolean): Int!
  max: orphan_listings_max_fields
  min: orphan_listings_min_fields
}

"columns and relationships of \"orphan_listings_images\""
type orphan_listings_images {
  alt: String
  "An object relationship"
  condition_response: orphan_condition_responses
  created_at: timestamptz!
  id: uuid!
  index: Int
  listing_id: uuid
  path: String
  src: String!
  updated_at: timestamptz!
  user_id: String!
}

"response of any mutation on the table \"orphan_listings_images\""
type orphan_listings_images_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [orphan_listings_images!]!
}

"aggregate max on columns"
type orphan_listings_max_fields {
  brand_id: uuid
  color: String
  created_at: timestamptz
  description: String
  id: uuid
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"aggregate min on columns"
type orphan_listings_min_fields {
  brand_id: uuid
  color: String
  created_at: timestamptz
  description: String
  id: uuid
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"response of any mutation on the table \"orphan_listings\""
type orphan_listings_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [orphan_listings!]!
}

"columns and relationships of \"photo_enhancement_requests\""
type photo_enhancement_requests {
  brand_id: uuid!
  created_at: timestamptz!
  external_id: String
  id: uuid!
  image_id: uuid
  listing_image_id: uuid
  original_src: String!
  product_image_id: uuid
  sku_image_id: uuid
  src: String
  status: photo_enhancement_request_statuses_enum!
  type: photo_enhancement_types_enum!
  updated_at: timestamptz!
  user_id: String!
}

"response of any mutation on the table \"pos_events\""
type pos_events_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
}

"columns and relationships of \"pos_stations\""
type pos_stations {
  active: Boolean!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  name: String!
  "An object relationship"
  retail_store: retail_stores!
  retail_store_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"postal_options\""
type postal_options {
  carrier: shipping_carriers_enum!
  created_at: timestamptz!
  id: uuid!
  method: shipping_methods_enum!
  service: shipping_services_enum!
  updated_at: timestamptz!
}

"columns and relationships of \"product_attribute_type_options\""
type product_attribute_type_options {
  "An object relationship"
  attribute_type: attribute_types!
  attribute_type_id: uuid!
  "An object relationship"
  attribute_type_option: attribute_type_options!
  attribute_type_option_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  product: products!
  product_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"product_colors\""
type product_colors {
  color: String!
  "A computed field, executes function \"pc_content\""
  content(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): [product_colors_translations!]
  id: uuid!
  "An object relationship"
  product: products!
  "An array relationship"
  product_colors_translations(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): [product_colors_translations!]!
  "An aggregate relationship"
  product_colors_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): product_colors_translations_aggregate!
  product_id: uuid!
  uid: String!
}

"columns and relationships of \"product_colors_translations\""
type product_colors_translations {
  color: String!
  id: Int!
  lang: String!
  product_color_id: uuid!
}

"aggregated selection of \"product_colors_translations\""
type product_colors_translations_aggregate {
  aggregate: product_colors_translations_aggregate_fields
  nodes: [product_colors_translations!]!
}

"aggregate fields of \"product_colors_translations\""
type product_colors_translations_aggregate_fields {
  avg: product_colors_translations_avg_fields
  count(columns: [product_colors_translations_select_column!], distinct: Boolean): Int!
  max: product_colors_translations_max_fields
  min: product_colors_translations_min_fields
  stddev: product_colors_translations_stddev_fields
  stddev_pop: product_colors_translations_stddev_pop_fields
  stddev_samp: product_colors_translations_stddev_samp_fields
  sum: product_colors_translations_sum_fields
  var_pop: product_colors_translations_var_pop_fields
  var_samp: product_colors_translations_var_samp_fields
  variance: product_colors_translations_variance_fields
}

"aggregate avg on columns"
type product_colors_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type product_colors_translations_max_fields {
  color: String
  id: Int
  lang: String
  product_color_id: uuid
}

"aggregate min on columns"
type product_colors_translations_min_fields {
  color: String
  id: Int
  lang: String
  product_color_id: uuid
}

"aggregate stddev on columns"
type product_colors_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type product_colors_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type product_colors_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type product_colors_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type product_colors_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type product_colors_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type product_colors_translations_variance_fields {
  id: Float
}

"columns and relationships of \"product_images\""
type product_images {
  alt: String
  "A computed field, executes function \"pi_content\""
  content(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): [product_images_translations!]
  created_at: timestamptz!
  detail: Boolean!
  id: uuid!
  index: Int
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  primary: Boolean!
  primary_hover: Boolean!
  "An object relationship"
  product: products
  product_id: uuid
  "An array relationship"
  product_images_translations(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): [product_images_translations!]!
  "An aggregate relationship"
  product_images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): product_images_translations_aggregate!
  src: String!
  swatch: Boolean!
  uid: String
  updated_at: timestamptz!
}

"columns and relationships of \"product_images_translations\""
type product_images_translations {
  alt: String
  id: Int!
  lang: String!
  product_image_id: uuid!
}

"aggregated selection of \"product_images_translations\""
type product_images_translations_aggregate {
  aggregate: product_images_translations_aggregate_fields
  nodes: [product_images_translations!]!
}

"aggregate fields of \"product_images_translations\""
type product_images_translations_aggregate_fields {
  avg: product_images_translations_avg_fields
  count(columns: [product_images_translations_select_column!], distinct: Boolean): Int!
  max: product_images_translations_max_fields
  min: product_images_translations_min_fields
  stddev: product_images_translations_stddev_fields
  stddev_pop: product_images_translations_stddev_pop_fields
  stddev_samp: product_images_translations_stddev_samp_fields
  sum: product_images_translations_sum_fields
  var_pop: product_images_translations_var_pop_fields
  var_samp: product_images_translations_var_samp_fields
  variance: product_images_translations_variance_fields
}

"aggregate avg on columns"
type product_images_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type product_images_translations_max_fields {
  alt: String
  id: Int
  lang: String
  product_image_id: uuid
}

"aggregate min on columns"
type product_images_translations_min_fields {
  alt: String
  id: Int
  lang: String
  product_image_id: uuid
}

"aggregate stddev on columns"
type product_images_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type product_images_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type product_images_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type product_images_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type product_images_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type product_images_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type product_images_translations_variance_fields {
  id: Float
}

"columns and relationships of \"product_style_attribute_type_options\""
type product_style_attribute_type_options {
  "An object relationship"
  attribute_type: attribute_types!
  attribute_type_id: uuid!
  "An object relationship"
  attribute_type_option: attribute_type_options!
  attribute_type_option_id: uuid!
  id: uuid!
  "An object relationship"
  product_style: product_styles!
  product_style_id: uuid!
}

"columns and relationships of \"product_style_variant_media_groups\""
type product_style_variant_media_groups {
  created_at: timestamptz!
  "An object relationship"
  media_group: media_groups!
  media_group_id: uuid!
  product_style_variant_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"product_style_variant_options\""
type product_style_variant_options {
  product_style_variant_id: uuid!
  "An object relationship"
  variant_type: variant_types!
  variant_type_id: uuid!
  "An object relationship"
  variant_type_option: variant_type_options!
  variant_type_option_id: uuid!
}

"columns and relationships of \"product_style_variants\""
type product_style_variants {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  media_groups(
    "distinct select on columns"
    distinct_on: [product_style_variant_media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_media_groups_order_by!],
    "filter the rows returned"
    where: product_style_variant_media_groups_bool_exp
  ): [product_style_variant_media_groups!]!
  price: Int
  "An object relationship"
  product_style: product_styles!
  product_style_id: uuid!
  product_style_variant: String!
  "An array relationship"
  product_style_variant_options(
    "distinct select on columns"
    distinct_on: [product_style_variant_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_options_order_by!],
    "filter the rows returned"
    where: product_style_variant_options_bool_exp
  ): [product_style_variant_options!]!
  updated_at: timestamptz!
}

"columns and relationships of \"product_styles\""
type product_styles {
  "An array relationship"
  attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_style_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_style_attribute_type_options_bool_exp
  ): [product_style_attribute_type_options!]!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "An object relationship"
  category: brand_categories
  category_id: uuid
  "A computed field, executes function \"ps_content\""
  content(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): [product_styles_translations!]
  disallow_listing: Boolean
  id: uuid!
  price: Int
  product_style: String!
  "An array relationship"
  product_style_variants(
    "distinct select on columns"
    distinct_on: [product_style_variants_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variants_order_by!],
    "filter the rows returned"
    where: product_style_variants_bool_exp
  ): [product_style_variants!]!
  "An array relationship"
  product_styles_translations(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): [product_styles_translations!]!
  "An aggregate relationship"
  product_styles_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): product_styles_translations_aggregate!
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "An array relationship"
  skus(
    "distinct select on columns"
    distinct_on: [skus_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_order_by!],
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  source: product_style_sources_enum
}

"aggregated selection of \"product_styles\""
type product_styles_aggregate {
  aggregate: product_styles_aggregate_fields
  nodes: [product_styles!]!
}

"aggregate fields of \"product_styles\""
type product_styles_aggregate_fields {
  avg: product_styles_avg_fields
  count(columns: [product_styles_select_column!], distinct: Boolean): Int!
  max: product_styles_max_fields
  min: product_styles_min_fields
  stddev: product_styles_stddev_fields
  stddev_pop: product_styles_stddev_pop_fields
  stddev_samp: product_styles_stddev_samp_fields
  sum: product_styles_sum_fields
  var_pop: product_styles_var_pop_fields
  var_samp: product_styles_var_samp_fields
  variance: product_styles_variance_fields
}

"aggregate avg on columns"
type product_styles_avg_fields {
  price: Float
}

"columns and relationships of \"product_styles_listed\""
type product_styles_listed {
  latest_created_at: timestamptz!
  max_price: Int!
  min_price: Int!
  "An object relationship"
  product_style: product_styles!
  product_style_id: uuid!
  sizes: String!
}

"aggregated selection of \"product_styles_listed\""
type product_styles_listed_aggregate {
  aggregate: product_styles_listed_aggregate_fields
  nodes: [product_styles_listed!]!
}

"aggregate fields of \"product_styles_listed\""
type product_styles_listed_aggregate_fields {
  avg: product_styles_listed_avg_fields
  count(columns: [product_styles_listed_select_column!], distinct: Boolean): Int!
  max: product_styles_listed_max_fields
  min: product_styles_listed_min_fields
  stddev: product_styles_listed_stddev_fields
  stddev_pop: product_styles_listed_stddev_pop_fields
  stddev_samp: product_styles_listed_stddev_samp_fields
  sum: product_styles_listed_sum_fields
  var_pop: product_styles_listed_var_pop_fields
  var_samp: product_styles_listed_var_samp_fields
  variance: product_styles_listed_variance_fields
}

"aggregate avg on columns"
type product_styles_listed_avg_fields {
  max_price: Float
  min_price: Float
}

"aggregate max on columns"
type product_styles_listed_max_fields {
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  product_style_id: uuid
  sizes: String
}

"aggregate min on columns"
type product_styles_listed_min_fields {
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  product_style_id: uuid
  sizes: String
}

"aggregate stddev on columns"
type product_styles_listed_stddev_fields {
  max_price: Float
  min_price: Float
}

"aggregate stddev_pop on columns"
type product_styles_listed_stddev_pop_fields {
  max_price: Float
  min_price: Float
}

"aggregate stddev_samp on columns"
type product_styles_listed_stddev_samp_fields {
  max_price: Float
  min_price: Float
}

"aggregate sum on columns"
type product_styles_listed_sum_fields {
  max_price: Int
  min_price: Int
}

"aggregate var_pop on columns"
type product_styles_listed_var_pop_fields {
  max_price: Float
  min_price: Float
}

"aggregate var_samp on columns"
type product_styles_listed_var_samp_fields {
  max_price: Float
  min_price: Float
}

"aggregate variance on columns"
type product_styles_listed_variance_fields {
  max_price: Float
  min_price: Float
}

"aggregate max on columns"
type product_styles_max_fields {
  brand_id: uuid
  category_id: uuid
  id: uuid
  price: Int
  product_style: String
}

"aggregate min on columns"
type product_styles_min_fields {
  brand_id: uuid
  category_id: uuid
  id: uuid
  price: Int
  product_style: String
}

"aggregate stddev on columns"
type product_styles_stddev_fields {
  price: Float
}

"aggregate stddev_pop on columns"
type product_styles_stddev_pop_fields {
  price: Float
}

"aggregate stddev_samp on columns"
type product_styles_stddev_samp_fields {
  price: Float
}

"aggregate sum on columns"
type product_styles_sum_fields {
  price: Int
}

"columns and relationships of \"product_styles_translations\""
type product_styles_translations {
  description: String
  id: Int!
  lang: String!
  name: String!
  product_style_id: uuid!
}

"aggregated selection of \"product_styles_translations\""
type product_styles_translations_aggregate {
  aggregate: product_styles_translations_aggregate_fields
  nodes: [product_styles_translations!]!
}

"aggregate fields of \"product_styles_translations\""
type product_styles_translations_aggregate_fields {
  avg: product_styles_translations_avg_fields
  count(columns: [product_styles_translations_select_column!], distinct: Boolean): Int!
  max: product_styles_translations_max_fields
  min: product_styles_translations_min_fields
  stddev: product_styles_translations_stddev_fields
  stddev_pop: product_styles_translations_stddev_pop_fields
  stddev_samp: product_styles_translations_stddev_samp_fields
  sum: product_styles_translations_sum_fields
  var_pop: product_styles_translations_var_pop_fields
  var_samp: product_styles_translations_var_samp_fields
  variance: product_styles_translations_variance_fields
}

"aggregate avg on columns"
type product_styles_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type product_styles_translations_max_fields {
  description: String
  id: Int
  lang: String
  name: String
  product_style_id: uuid
}

"aggregate min on columns"
type product_styles_translations_min_fields {
  description: String
  id: Int
  lang: String
  name: String
  product_style_id: uuid
}

"aggregate stddev on columns"
type product_styles_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type product_styles_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type product_styles_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type product_styles_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type product_styles_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type product_styles_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type product_styles_translations_variance_fields {
  id: Float
}

"aggregate var_pop on columns"
type product_styles_var_pop_fields {
  price: Float
}

"aggregate var_samp on columns"
type product_styles_var_samp_fields {
  price: Float
}

"aggregate variance on columns"
type product_styles_variance_fields {
  price: Float
}

"columns and relationships of \"product_tags\""
type product_tags {
  id: uuid!
  "An object relationship"
  product: products!
  product_id: uuid!
  value: String!
}

"aggregated selection of \"product_tags\""
type product_tags_aggregate {
  aggregate: product_tags_aggregate_fields
  nodes: [product_tags!]!
}

"aggregate fields of \"product_tags\""
type product_tags_aggregate_fields {
  count(columns: [product_tags_select_column!], distinct: Boolean): Int!
  max: product_tags_max_fields
  min: product_tags_min_fields
}

"aggregate max on columns"
type product_tags_max_fields {
  id: uuid
  product_id: uuid
  value: String
}

"aggregate min on columns"
type product_tags_min_fields {
  id: uuid
  product_id: uuid
  value: String
}

"columns and relationships of \"products\""
type products {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  care: String
  "An object relationship"
  category: brand_categories
  category_id: uuid
  color: String
  "A computed field, executes function \"p_content\""
  content(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): [products_translations!]
  created_at: timestamptz!
  current_price: Int
  default_price_multiplier: numeric
  description: String
  disallow_listing: Boolean!
  fit: String
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [product_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_order_by!],
    "filter the rows returned"
    where: product_images_bool_exp
  ): [product_images!]!
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  lowest_price: Int
  material: String
  name: String!
  normalized_name: String
  original_price: Int
  "An object relationship"
  parent_product: products
  parent_product_id: uuid
  "An array relationship"
  product_attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_attribute_type_options_bool_exp
  ): [product_attribute_type_options!]!
  "An array relationship"
  product_colors(
    "distinct select on columns"
    distinct_on: [product_colors_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_order_by!],
    "filter the rows returned"
    where: product_colors_bool_exp
  ): [product_colors!]!
  product_style_id: uuid
  "An array relationship"
  product_tags(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): [product_tags!]!
  "An aggregate relationship"
  product_tags_aggregate(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): product_tags_aggregate!
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "An array relationship"
  products_translations(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): [products_translations!]!
  "An aggregate relationship"
  products_translations_aggregate(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): products_translations_aggregate!
  "An object relationship"
  question_set: question_sets
  question_set_id: uuid
  sale_price: Int
  "An array relationship"
  searchable_products_results(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "An aggregate relationship"
  searchable_products_results_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "An array relationship"
  skus(
    "distinct select on columns"
    distinct_on: [skus_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_order_by!],
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  "An object relationship"
  style: product_styles
  "An object relationship"
  super_category: brand_categories
  super_category_id: uuid
  uid: String!
  updated_at: timestamptz!
  url: String
}

"aggregated selection of \"products\""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

"aggregate fields of \"products\""
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int!
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

"aggregate avg on columns"
type products_avg_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate max on columns"
type products_max_fields {
  brand_id: uuid
  care: String
  category_id: uuid
  color: String
  created_at: timestamptz
  current_price: Int
  default_price_multiplier: numeric
  description: String
  fit: String
  id: uuid
  lowest_price: Int
  material: String
  name: String
  normalized_name: String
  original_price: Int
  parent_product_id: uuid
  product_style_id: uuid
  question_set_id: uuid
  sale_price: Int
  super_category_id: uuid
  uid: String
  updated_at: timestamptz
  url: String
}

"aggregate min on columns"
type products_min_fields {
  brand_id: uuid
  care: String
  category_id: uuid
  color: String
  created_at: timestamptz
  current_price: Int
  default_price_multiplier: numeric
  description: String
  fit: String
  id: uuid
  lowest_price: Int
  material: String
  name: String
  normalized_name: String
  original_price: Int
  parent_product_id: uuid
  product_style_id: uuid
  question_set_id: uuid
  sale_price: Int
  super_category_id: uuid
  uid: String
  updated_at: timestamptz
  url: String
}

"aggregate stddev on columns"
type products_stddev_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate stddev_pop on columns"
type products_stddev_pop_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate stddev_samp on columns"
type products_stddev_samp_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate sum on columns"
type products_sum_fields {
  current_price: Int
  default_price_multiplier: numeric
  lowest_price: Int
  original_price: Int
  sale_price: Int
}

"columns and relationships of \"products_translations\""
type products_translations {
  care: String
  color: String
  description: String
  fit: String
  id: Int!
  lang: String!
  material: String
  name: String
  normalized_name: String
  product_id: uuid!
}

"aggregated selection of \"products_translations\""
type products_translations_aggregate {
  aggregate: products_translations_aggregate_fields
  nodes: [products_translations!]!
}

"aggregate fields of \"products_translations\""
type products_translations_aggregate_fields {
  avg: products_translations_avg_fields
  count(columns: [products_translations_select_column!], distinct: Boolean): Int!
  max: products_translations_max_fields
  min: products_translations_min_fields
  stddev: products_translations_stddev_fields
  stddev_pop: products_translations_stddev_pop_fields
  stddev_samp: products_translations_stddev_samp_fields
  sum: products_translations_sum_fields
  var_pop: products_translations_var_pop_fields
  var_samp: products_translations_var_samp_fields
  variance: products_translations_variance_fields
}

"aggregate avg on columns"
type products_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type products_translations_max_fields {
  care: String
  color: String
  description: String
  fit: String
  id: Int
  lang: String
  material: String
  name: String
  normalized_name: String
  product_id: uuid
}

"aggregate min on columns"
type products_translations_min_fields {
  care: String
  color: String
  description: String
  fit: String
  id: Int
  lang: String
  material: String
  name: String
  normalized_name: String
  product_id: uuid
}

"aggregate stddev on columns"
type products_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type products_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type products_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type products_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type products_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type products_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type products_translations_variance_fields {
  id: Float
}

"aggregate var_pop on columns"
type products_var_pop_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate var_samp on columns"
type products_var_samp_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

"aggregate variance on columns"
type products_variance_fields {
  current_price: Float
  default_price_multiplier: Float
  lowest_price: Float
  original_price: Float
  sale_price: Float
}

type query_root {
  "fetch data from the table: \"addresses\""
  addresses(
    "distinct select on columns"
    distinct_on: [addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [addresses_order_by!],
    "filter the rows returned"
    where: addresses_bool_exp
  ): [addresses!]!
  "fetch data from the table: \"addresses\" using primary key columns"
  addresses_by_pk(id: uuid!): addresses
  adminSearch(brand_id: uuid!, request: jsonb!): AdminSearchResult!
  "An array relationship"
  annual_sales_totals(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An aggregate relationship"
  annual_sales_totals_aggregate(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): annual_sales_totals_aggregate!
  "An array relationship"
  applied_discount_codes(
    "distinct select on columns"
    distinct_on: [applied_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [applied_discount_codes_order_by!],
    "filter the rows returned"
    where: applied_discount_codes_bool_exp
  ): [applied_discount_codes!]!
  "fetch data from the table: \"applied_discount_codes\" using primary key columns"
  applied_discount_codes_by_pk(id: uuid!): applied_discount_codes
  "An array relationship"
  attempted_discount_codes(
    "distinct select on columns"
    distinct_on: [attempted_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attempted_discount_codes_order_by!],
    "filter the rows returned"
    where: attempted_discount_codes_bool_exp
  ): [attempted_discount_codes!]!
  "fetch data from the table: \"attempted_discount_codes\" using primary key columns"
  attempted_discount_codes_by_pk(id: uuid!): attempted_discount_codes
  "An array relationship"
  attribute_type_options(
    "distinct select on columns"
    distinct_on: [attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_order_by!],
    "filter the rows returned"
    where: attribute_type_options_bool_exp
  ): [attribute_type_options!]!
  "fetch data from the table: \"attribute_type_options\" using primary key columns"
  attribute_type_options_by_pk(id: uuid!): attribute_type_options
  "fetch data from the table: \"attribute_type_options_translations\""
  attribute_type_options_translations(
    "distinct select on columns"
    distinct_on: [attribute_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_translations_order_by!],
    "filter the rows returned"
    where: attribute_type_options_translations_bool_exp
  ): [attribute_type_options_translations!]!
  "fetch data from the table: \"attribute_type_options_translations\" using primary key columns"
  attribute_type_options_translations_by_pk(id: Int!): attribute_type_options_translations
  "An array relationship"
  attribute_types(
    "distinct select on columns"
    distinct_on: [attribute_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_order_by!],
    "filter the rows returned"
    where: attribute_types_bool_exp
  ): [attribute_types!]!
  "fetch data from the table: \"attribute_types\" using primary key columns"
  attribute_types_by_pk(id: uuid!): attribute_types
  "fetch data from the table: \"attribute_types_translations\""
  attribute_types_translations(
    "distinct select on columns"
    distinct_on: [attribute_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_translations_order_by!],
    "filter the rows returned"
    where: attribute_types_translations_bool_exp
  ): [attribute_types_translations!]!
  "fetch data from the table: \"attribute_types_translations\" using primary key columns"
  attribute_types_translations_by_pk(id: Int!): attribute_types_translations
  "fetch data from the table: \"auction_bids\""
  auction_bids(
    "distinct select on columns"
    distinct_on: [auction_bids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_order_by!],
    "filter the rows returned"
    where: auction_bids_bool_exp
  ): [auction_bids!]!
  "fetch data from the table: \"auction_bids\" using primary key columns"
  auction_bids_by_pk(id: uuid!): auction_bids
  "fetch data from the table: \"auction_bids_history\""
  auction_bids_history(
    "distinct select on columns"
    distinct_on: [auction_bids_history_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_history_order_by!],
    "filter the rows returned"
    where: auction_bids_history_bool_exp
  ): [auction_bids_history!]!
  "fetch data from the table: \"auction_bids_history\" using primary key columns"
  auction_bids_history_by_pk(id: uuid!): auction_bids_history
  "An array relationship"
  auctions(
    "distinct select on columns"
    distinct_on: [auctions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auctions_order_by!],
    "filter the rows returned"
    where: auctions_bool_exp
  ): [auctions!]!
  "fetch data from the table: \"auctions\" using primary key columns"
  auctions_by_pk(id: uuid!): auctions
  "An array relationship"
  brand_categories(
    "distinct select on columns"
    distinct_on: [brand_categories_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_order_by!],
    "filter the rows returned"
    where: brand_categories_bool_exp
  ): [brand_categories!]!
  "fetch data from the table: \"brand_categories\" using primary key columns"
  brand_categories_by_pk(id: uuid!): brand_categories
  "fetch data from the table: \"brand_categories_translations\""
  brand_categories_translations(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): [brand_categories_translations!]!
  "fetch aggregated fields from the table: \"brand_categories_translations\""
  brand_categories_translations_aggregate(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): brand_categories_translations_aggregate!
  "fetch data from the table: \"brand_categories_translations\" using primary key columns"
  brand_categories_translations_by_pk(id: Int!): brand_categories_translations
  "fetch data from the table: \"brand_fulfillment_in_store_options\""
  brand_fulfillment_in_store_options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_options_bool_exp
  ): [brand_fulfillment_in_store_options!]!
  "fetch data from the table: \"brand_fulfillment_in_store_options\" using primary key columns"
  brand_fulfillment_in_store_options_by_pk(id: uuid!): brand_fulfillment_in_store_options
  "fetch data from the table: \"brand_fulfillment_in_store_settings\""
  brand_fulfillment_in_store_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_settings_bool_exp
  ): [brand_fulfillment_in_store_settings!]!
  "fetch data from the table: \"brand_fulfillment_in_store_settings\" using primary key columns"
  brand_fulfillment_in_store_settings_by_pk(id: uuid!): brand_fulfillment_in_store_settings
  "fetch data from the table: \"brand_fulfillment_postal_options\""
  brand_fulfillment_postal_options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_options_bool_exp
  ): [brand_fulfillment_postal_options!]!
  "fetch data from the table: \"brand_fulfillment_postal_options\" using primary key columns"
  brand_fulfillment_postal_options_by_pk(id: uuid!): brand_fulfillment_postal_options
  "fetch data from the table: \"brand_fulfillment_postal_settings\""
  brand_fulfillment_postal_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_settings_bool_exp
  ): [brand_fulfillment_postal_settings!]!
  "fetch data from the table: \"brand_fulfillment_postal_settings\" using primary key columns"
  brand_fulfillment_postal_settings_by_pk(id: uuid!): brand_fulfillment_postal_settings
  "fetch data from the table: \"brand_fulfillment_settings\""
  brand_fulfillment_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_settings_bool_exp
  ): [brand_fulfillment_settings!]!
  "fetch data from the table: \"brand_fulfillment_settings\" using primary key columns"
  brand_fulfillment_settings_by_pk(id: uuid!): brand_fulfillment_settings
  "fetch data from the table: \"brand_passwords\""
  brand_passwords(
    "distinct select on columns"
    distinct_on: [brand_passwords_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_passwords_order_by!],
    "filter the rows returned"
    where: brand_passwords_bool_exp
  ): [brand_passwords!]!
  "fetch data from the table: \"brand_passwords\" using primary key columns"
  brand_passwords_by_pk(brand_id: uuid!): brand_passwords
  "fetch data from the table: \"brands\""
  brands(
    "distinct select on columns"
    distinct_on: [brands_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brands_order_by!],
    "filter the rows returned"
    where: brands_bool_exp
  ): [brands!]!
  "fetch data from the table: \"brands\" using primary key columns"
  brands_by_pk(id: uuid!): brands
  calculateCartEstimatesV2(input: CalculateCartEstimatesV2Input!): CalculateCartEstimatesV2Result!
  calculateCartEstimatesV3(input: CalculateCartEstimatesV3Input!): CalculateCartEstimatesV3Result!
  "fetch data from the table: \"chat_channels\""
  chat_channels(
    "distinct select on columns"
    distinct_on: [chat_channels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [chat_channels_order_by!],
    "filter the rows returned"
    where: chat_channels_bool_exp
  ): [chat_channels!]!
  "fetch data from the table: \"chat_channels\" using primary key columns"
  chat_channels_by_pk(key: String!): chat_channels
  checkBrandPassword(brand_id: uuid!, password: String!): CheckBrandPasswordResult!
  checkPostalCode(input: CheckPostalCodeRequest!): CheckPostalCodeResult
  "fetch data from the table: \"collapsed_product_results\""
  collapsed_product_results(
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "fetch aggregated fields from the table: \"collapsed_product_results\""
  collapsed_product_results_aggregate(
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "fetch data from the table: \"collection_media_groups\""
  collection_media_groups(
    "distinct select on columns"
    distinct_on: [collection_media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collection_media_groups_order_by!],
    "filter the rows returned"
    where: collection_media_groups_bool_exp
  ): [collection_media_groups!]!
  "fetch data from the table: \"collection_media_groups\" using primary key columns"
  collection_media_groups_by_pk(collection_id: uuid!, media_group_id: uuid!): collection_media_groups
  "fetch data from the table: \"collections\""
  collections(
    "distinct select on columns"
    distinct_on: [collections_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_order_by!],
    "filter the rows returned"
    where: collections_bool_exp
  ): [collections!]!
  "fetch data from the table: \"collections\" using primary key columns"
  collections_by_pk(id: uuid!): collections
  "fetch data from the table: \"collections_translations\""
  collections_translations(
    "distinct select on columns"
    distinct_on: [collections_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_translations_order_by!],
    "filter the rows returned"
    where: collections_translations_bool_exp
  ): [collections_translations!]!
  "fetch data from the table: \"collections_translations\" using primary key columns"
  collections_translations_by_pk(id: Int!): collections_translations
  "An array relationship"
  condition_questions(
    "distinct select on columns"
    distinct_on: [condition_questions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_order_by!],
    "filter the rows returned"
    where: condition_questions_bool_exp
  ): [condition_questions!]!
  "fetch data from the table: \"condition_questions\" using primary key columns"
  condition_questions_by_pk(id: uuid!): condition_questions
  "fetch data from the table: \"condition_questions_translations\""
  condition_questions_translations(
    "distinct select on columns"
    distinct_on: [condition_questions_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_translations_order_by!],
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): [condition_questions_translations!]!
  "fetch aggregated fields from the table: \"condition_questions_translations\""
  condition_questions_translations_aggregate(
    "distinct select on columns"
    distinct_on: [condition_questions_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_translations_order_by!],
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): condition_questions_translations_aggregate!
  "fetch data from the table: \"condition_questions_translations\" using primary key columns"
  condition_questions_translations_by_pk(id: Int!): condition_questions_translations
  "An array relationship"
  condition_responses(
    "distinct select on columns"
    distinct_on: [condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_responses_order_by!],
    "filter the rows returned"
    where: condition_responses_bool_exp
  ): [condition_responses!]!
  "fetch data from the table: \"condition_responses\" using primary key columns"
  condition_responses_by_pk(id: uuid!): condition_responses
  "fetch data from the table: \"credit\""
  credit(
    "distinct select on columns"
    distinct_on: [credit_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [credit_order_by!],
    "filter the rows returned"
    where: credit_bool_exp
  ): [credit!]!
  "fetch data from the table: \"credit\" using primary key columns"
  credit_by_pk(id: uuid!): credit
  "fetch data from the table: \"dac7_verified_storefronts\""
  dac7_verified_storefronts(
    "distinct select on columns"
    distinct_on: [dac7_verified_storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [dac7_verified_storefronts_order_by!],
    "filter the rows returned"
    where: dac7_verified_storefronts_bool_exp
  ): [dac7_verified_storefronts!]!
  detectLanguage(detectLanguageRequest: DetectLanguageRequest!): DetectLanguageResponse!
  enhancePhotoStatus(id: uuid!): EnhancePhotoStatusResult
  "An array relationship"
  external_sku_ids(
    "distinct select on columns"
    distinct_on: [external_sku_ids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [external_sku_ids_order_by!],
    "filter the rows returned"
    where: external_sku_ids_bool_exp
  ): [external_sku_ids!]!
  "fetch data from the table: \"external_sku_ids\" using primary key columns"
  external_sku_ids_by_pk(id: uuid!): external_sku_ids
  "fetch data from the table: \"form_submissions\""
  form_submissions(
    "distinct select on columns"
    distinct_on: [form_submissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [form_submissions_order_by!],
    "filter the rows returned"
    where: form_submissions_bool_exp
  ): [form_submissions!]!
  "fetch aggregated fields from the table: \"form_submissions\""
  form_submissions_aggregate(
    "distinct select on columns"
    distinct_on: [form_submissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [form_submissions_order_by!],
    "filter the rows returned"
    where: form_submissions_bool_exp
  ): form_submissions_aggregate!
  "fetch data from the table: \"form_submissions\" using primary key columns"
  form_submissions_by_pk(id: uuid!): form_submissions
  "fetch data from the table: \"forms\""
  forms(
    "distinct select on columns"
    distinct_on: [forms_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [forms_order_by!],
    "filter the rows returned"
    where: forms_bool_exp
  ): [forms!]!
  "fetch data from the table: \"forms\" using primary key columns"
  forms_by_pk(id: uuid!): forms
  "fetch data from the table: \"fulfillment_intents\""
  fulfillment_intents(
    "distinct select on columns"
    distinct_on: [fulfillment_intents_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillment_intents_order_by!],
    "filter the rows returned"
    where: fulfillment_intents_bool_exp
  ): [fulfillment_intents!]!
  "fetch data from the table: \"fulfillment_intents\" using primary key columns"
  fulfillment_intents_by_pk(id: uuid!): fulfillment_intents
  "fetch data from the table: \"fulfillment_services\""
  fulfillment_services(
    "distinct select on columns"
    distinct_on: [fulfillment_services_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillment_services_order_by!],
    "filter the rows returned"
    where: fulfillment_services_bool_exp
  ): [fulfillment_services!]!
  "fetch data from the table: \"fulfillment_services\" using primary key columns"
  fulfillment_services_by_pk(id: uuid!): fulfillment_services
  "fetch data from the table: \"fulfillments\""
  fulfillments(
    "distinct select on columns"
    distinct_on: [fulfillments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillments_order_by!],
    "filter the rows returned"
    where: fulfillments_bool_exp
  ): [fulfillments!]!
  "fetch data from the table: \"fulfillments\" using primary key columns"
  fulfillments_by_pk(id: uuid!): fulfillments
  generateTestEmail(input: GenerateTestEmailInput!): GenerateTestEmailResult!
  getAttributeOptions(input: GetAttributeOptionsInput!): GetAttributeOptionsResponse
  getBrandSort(brand_id: uuid!): GetBrandSortResult!
  getCheckoutFulfillmentOptions(input: GetCheckoutFulfillmentOptionsInput!): GetCheckoutFulfillmentOptionsResult!
  "Fetches the collection definition, for manual collections, the definition field in the response will be null."
  getCollectionDefinition(input: GetCollectionDefinitionInput!): GetCollectionDefinitionResponse
  getEntityDistance(input: EntityDistanceRequest!): EntityDistanceResult
  getFormSubmission(input: GetFormSubmissionInput!): GetFormSubmissionResult
  getFormSubmissions(input: GetFormSubmissionsRequest!): GetFormSubmissionsResult!
  getInStoreFulfillmentOptionsForStorefront(brand_id: uuid!, storefront_id: uuid): GetInStoreFulfillmentOptionsForStorefrontResult!
  getInStorePickupsForCodes(brand_id: uuid!, identifiers: [String!]): GetInStorePickupsForCodesResult
  getItemFulfillmentOptions(input: GetItemFulfillmentOptionsInput!): GetItemFulfillmentOptionsResponse
  "Fetches manually tagged products, listings, product style variants, and product style IDs in a collection"
  getManualCollectionItems(input: GetManualCollectionItemsInput!): GetManualCollectionItemsResponse
  getOrCreateStreamChatUser(input: GetOrCreateStreamChatUserInput!): GetOrCreateStreamChatUserResult!
  getPostiPickupPoints(postal_code: String!): [PostiPickupPoint!]!
  getProductStyleSkus(input: GetProductStyleSkusInput): GetProductStyleSkusResult
  getProductsXmlSitemap(input: GetProductsXmlSitemapInput!): GetProductsXmlSitemapResult!
  getReaderStatus(brand_id: uuid!, pos_station_id: uuid!): GetReaderStatusResult
  getReturnEstimate(input: GetReturnEstimateInput!): GetReturnEstimateResponse
  getSearchPageSort(input: GetSearchPageSortInput!): GetSearchPageSortResponse!
  getStoreTakeback(brand_id: uuid!, input: GetStoreTakebackInput!): GetStoreTakebackResult
  "Returns store takeback details used in the confirmation screen"
  getStoreTakebackConfirmationDetails(brand_id: uuid!, takeback_number: String!): GetStoreTakebackConfirmationDetailsResult
  getStorefrontsForUser(brand_id: uuid!, user_id: uuid!): [StorefrontsForUserResult]!
  getStripeAccount(account_id: String!, brand_slug: String): GetStripeAccountResult!
  getStripeAccountLink(account_id: String!, brand_uid: String!): GetStripeAccountLinkResult!
  getTakebackEstimate(brand_id: uuid!, input: GetTakebackEstimateInput!): GetTakebackEstimateResult!
  getTakebackItemEstimates(brand_id: uuid!, input: GetTakebackItemEstimatesInput!): GetTakebackItemEstimatesResult!
  getTakebackRequestInfo(brand_id: uuid!, takeback_id: uuid!): GetTakebackRequestInfoResult
  getUserEmailVerified: GetUserEmailVerifiedResponse!
  getUserPreferredLanguage(input: GetUserPreferredLanguageInput!): GetUserPreferredLanguageResult!
  getVariantTypeOptions(input: GetVariantTypeOptionsInput): GetVariantTypeOptionsResult
  getVariants(input: GetVariantsInput): GetVariantsResult
  getWorkflowDefinitionV1(input: GetWorkflowDefinitionV1Input!): GetWorkflowDefinitionV1Result!
  getWorkflowItem(input: GetWorkflowItemInput!): GetWorkflowItemResult!
  getWorkflowItems(input: GetWorkflowItemsInput!): GetWorkflowItemsResult!
  "An array relationship"
  gift_cards(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): [gift_cards!]!
  "An aggregate relationship"
  gift_cards_aggregate(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): gift_cards_aggregate!
  "fetch data from the table: \"gift_cards\" using primary key columns"
  gift_cards_by_pk(id: uuid!): gift_cards
  "fetch data from the table: \"images\""
  images(
    "distinct select on columns"
    distinct_on: [images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [images_order_by!],
    "filter the rows returned"
    where: images_bool_exp
  ): [images!]!
  "fetch data from the table: \"images\" using primary key columns"
  images_by_pk(id: uuid!): images
  "An array relationship"
  in_store_pickups(
    "distinct select on columns"
    distinct_on: [in_store_pickups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [in_store_pickups_order_by!],
    "filter the rows returned"
    where: in_store_pickups_bool_exp
  ): [in_store_pickups!]!
  "fetch data from the table: \"in_store_pickups\" using primary key columns"
  in_store_pickups_by_pk(id: uuid!): in_store_pickups
  "fetch data from the table: \"listing_auto_price_reduce\""
  listing_auto_price_reduce(
    "distinct select on columns"
    distinct_on: [listing_auto_price_reduce_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_auto_price_reduce_order_by!],
    "filter the rows returned"
    where: listing_auto_price_reduce_bool_exp
  ): [listing_auto_price_reduce!]!
  "fetch data from the table: \"listing_auto_price_reduce\" using primary key columns"
  listing_auto_price_reduce_by_pk(id: uuid!): listing_auto_price_reduce
  "fetch data from the table: \"listing_channels\""
  listing_channels(
    "distinct select on columns"
    distinct_on: [listing_channels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_channels_order_by!],
    "filter the rows returned"
    where: listing_channels_bool_exp
  ): [listing_channels!]!
  "fetch data from the table: \"listing_channels\" using primary key columns"
  listing_channels_by_pk(id: uuid!): listing_channels
  "fetch data from the table: \"listing_event_types\""
  listing_event_types(
    "distinct select on columns"
    distinct_on: [listing_event_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_event_types_order_by!],
    "filter the rows returned"
    where: listing_event_types_bool_exp
  ): [listing_event_types!]!
  "fetch data from the table: \"listing_event_types\" using primary key columns"
  listing_event_types_by_pk(type: String!): listing_event_types
  "fetch data from the table: \"listing_events\""
  listing_events(
    "distinct select on columns"
    distinct_on: [listing_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_events_order_by!],
    "filter the rows returned"
    where: listing_events_bool_exp
  ): [listing_events!]!
  "fetch data from the table: \"listing_events\" using primary key columns"
  listing_events_by_pk(id: uuid!): listing_events
  "fetch data from the table: \"listing_images\""
  listing_images(
    "distinct select on columns"
    distinct_on: [listing_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_images_order_by!],
    "filter the rows returned"
    where: listing_images_bool_exp
  ): [listing_images!]!
  "fetch data from the table: \"listing_images\" using primary key columns"
  listing_images_by_pk(id: uuid!): listing_images
  "An array relationship"
  listing_metadata(
    "distinct select on columns"
    distinct_on: [listing_metadata_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_metadata_order_by!],
    "filter the rows returned"
    where: listing_metadata_bool_exp
  ): [listing_metadata!]!
  "fetch data from the table: \"listing_metadata\" using primary key columns"
  listing_metadata_by_pk(id: uuid!): listing_metadata
  "fetch data from the table: \"listing_platforms\""
  listing_platforms(
    "distinct select on columns"
    distinct_on: [listing_platforms_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_platforms_order_by!],
    "filter the rows returned"
    where: listing_platforms_bool_exp
  ): [listing_platforms!]!
  "fetch data from the table: \"listing_platforms\" using primary key columns"
  listing_platforms_by_pk(id: uuid!): listing_platforms
  "fetch data from the table: \"listing_relistings\""
  listing_relistings(
    "distinct select on columns"
    distinct_on: [listing_relistings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_relistings_order_by!],
    "filter the rows returned"
    where: listing_relistings_bool_exp
  ): [listing_relistings!]!
  "fetch data from the table: \"listing_relistings\" using primary key columns"
  listing_relistings_by_pk(new_listing_id: uuid!, previous_listing_id: uuid!): listing_relistings
  "fetch data from the table: \"listing_statuses\""
  listing_statuses(
    "distinct select on columns"
    distinct_on: [listing_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_statuses_order_by!],
    "filter the rows returned"
    where: listing_statuses_bool_exp
  ): [listing_statuses!]!
  "fetch data from the table: \"listing_statuses\" using primary key columns"
  listing_statuses_by_pk(status: String!): listing_statuses
  "fetch data from the table: \"listing_user_action_timestamp\""
  listing_user_action_timestamp(
    "distinct select on columns"
    distinct_on: [listing_user_action_timestamp_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_user_action_timestamp_order_by!],
    "filter the rows returned"
    where: listing_user_action_timestamp_bool_exp
  ): [listing_user_action_timestamp!]!
  "fetch data from the table: \"listing_user_action_timestamp\" using primary key columns"
  listing_user_action_timestamp_by_pk(id: uuid!): listing_user_action_timestamp
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  "fetch data from the table: \"listings\" using primary key columns"
  listings_by_pk(id: uuid!): listings
  lookupOrder(brand_id: uuid!, email: String!, order_number: String!): LookupOrderResult!
  lookupTakebacks(brand_id: uuid!, input: LookupTakebacksInput!): LookupTakebacksResult!
  "An array relationship"
  mail_takebacks(
    "distinct select on columns"
    distinct_on: [mail_takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mail_takebacks_order_by!],
    "filter the rows returned"
    where: mail_takebacks_bool_exp
  ): [mail_takebacks!]!
  "fetch data from the table: \"mail_takebacks\" using primary key columns"
  mail_takebacks_by_pk(id: uuid!): mail_takebacks
  "fetch data from the table: \"media_group_items\""
  media_group_items(
    "distinct select on columns"
    distinct_on: [media_group_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [media_group_items_order_by!],
    "filter the rows returned"
    where: media_group_items_bool_exp
  ): [media_group_items!]!
  "fetch data from the table: \"media_group_items\" using primary key columns"
  media_group_items_by_pk(id: uuid!): media_group_items
  "fetch data from the table: \"media_groups\""
  media_groups(
    "distinct select on columns"
    distinct_on: [media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [media_groups_order_by!],
    "filter the rows returned"
    where: media_groups_bool_exp
  ): [media_groups!]!
  "fetch data from the table: \"media_groups\" using primary key columns"
  media_groups_by_pk(id: uuid!): media_groups
  "fetch data from the table: \"mobile_uploads\""
  mobile_uploads(
    "distinct select on columns"
    distinct_on: [mobile_uploads_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mobile_uploads_order_by!],
    "filter the rows returned"
    where: mobile_uploads_bool_exp
  ): [mobile_uploads!]!
  "fetch data from the table: \"mobile_uploads\" using primary key columns"
  mobile_uploads_by_pk(id: uuid!): mobile_uploads
  moveTempImages(sessionId: String!): MoveTempImagesResult
  "fetch data from the table: \"order_addresses\""
  order_addresses(
    "distinct select on columns"
    distinct_on: [order_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_addresses_order_by!],
    "filter the rows returned"
    where: order_addresses_bool_exp
  ): [order_addresses!]!
  "fetch data from the table: \"order_addresses\" using primary key columns"
  order_addresses_by_pk(id: uuid!): order_addresses
  "fetch data from the table: \"order_intent_items\""
  order_intent_items(
    "distinct select on columns"
    distinct_on: [order_intent_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_intent_items_order_by!],
    "filter the rows returned"
    where: order_intent_items_bool_exp
  ): [order_intent_items!]!
  "fetch data from the table: \"order_intent_items\" using primary key columns"
  order_intent_items_by_pk(id: uuid!): order_intent_items
  "fetch data from the table: \"order_intents\""
  order_intents(
    "distinct select on columns"
    distinct_on: [order_intents_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_intents_order_by!],
    "filter the rows returned"
    where: order_intents_bool_exp
  ): [order_intents!]!
  "fetch data from the table: \"order_intents\" using primary key columns"
  order_intents_by_pk(id: uuid!): order_intents
  "An array relationship"
  order_items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  order_items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  "fetch data from the table: \"order_items\" using primary key columns"
  order_items_by_pk(id: uuid!): order_items
  "fetch data from the table: \"order_statuses\""
  order_statuses(
    "distinct select on columns"
    distinct_on: [order_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_statuses_order_by!],
    "filter the rows returned"
    where: order_statuses_bool_exp
  ): [order_statuses!]!
  "fetch data from the table: \"order_statuses\" using primary key columns"
  order_statuses_by_pk(status: String!): order_statuses
  "An array relationship"
  orders(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): [orders!]!
  "An aggregate relationship"
  orders_aggregate(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): orders_aggregate!
  "fetch data from the table: \"orders\" using primary key columns"
  orders_by_pk(id: uuid!): orders
  "fetch data from the table: \"orphan_condition_responses\""
  orphan_condition_responses(
    "distinct select on columns"
    distinct_on: [orphan_condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_condition_responses_order_by!],
    "filter the rows returned"
    where: orphan_condition_responses_bool_exp
  ): [orphan_condition_responses!]!
  "fetch data from the table: \"orphan_condition_responses\" using primary key columns"
  orphan_condition_responses_by_pk(id: uuid!): orphan_condition_responses
  "fetch data from the table: \"orphan_listings\""
  orphan_listings(
    "distinct select on columns"
    distinct_on: [orphan_listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_order_by!],
    "filter the rows returned"
    where: orphan_listings_bool_exp
  ): [orphan_listings!]!
  "fetch aggregated fields from the table: \"orphan_listings\""
  orphan_listings_aggregate(
    "distinct select on columns"
    distinct_on: [orphan_listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_order_by!],
    "filter the rows returned"
    where: orphan_listings_bool_exp
  ): orphan_listings_aggregate!
  "fetch data from the table: \"orphan_listings\" using primary key columns"
  orphan_listings_by_pk(id: uuid!): orphan_listings
  "fetch data from the table: \"orphan_listings_images\""
  orphan_listings_images(
    "distinct select on columns"
    distinct_on: [orphan_listings_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_images_order_by!],
    "filter the rows returned"
    where: orphan_listings_images_bool_exp
  ): [orphan_listings_images!]!
  "fetch data from the table: \"orphan_listings_images\" using primary key columns"
  orphan_listings_images_by_pk(id: uuid!): orphan_listings_images
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  "fetch data from the table: \"photo_enhancement_requests\" using primary key columns"
  photo_enhancement_requests_by_pk(id: uuid!): photo_enhancement_requests
  "An array relationship"
  pos_stations(
    "distinct select on columns"
    distinct_on: [pos_stations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [pos_stations_order_by!],
    "filter the rows returned"
    where: pos_stations_bool_exp
  ): [pos_stations!]!
  "fetch data from the table: \"pos_stations\" using primary key columns"
  pos_stations_by_pk(id: uuid!): pos_stations
  "fetch data from the table: \"postal_options\""
  postal_options(
    "distinct select on columns"
    distinct_on: [postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [postal_options_order_by!],
    "filter the rows returned"
    where: postal_options_bool_exp
  ): [postal_options!]!
  "fetch data from the table: \"postal_options\" using primary key columns"
  postal_options_by_pk(id: uuid!): postal_options
  "An array relationship"
  product_attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_attribute_type_options_bool_exp
  ): [product_attribute_type_options!]!
  "fetch data from the table: \"product_attribute_type_options\" using primary key columns"
  product_attribute_type_options_by_pk(id: uuid!): product_attribute_type_options
  "An array relationship"
  product_colors(
    "distinct select on columns"
    distinct_on: [product_colors_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_order_by!],
    "filter the rows returned"
    where: product_colors_bool_exp
  ): [product_colors!]!
  "fetch data from the table: \"product_colors\" using primary key columns"
  product_colors_by_pk(id: uuid!): product_colors
  "An array relationship"
  product_colors_translations(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): [product_colors_translations!]!
  "An aggregate relationship"
  product_colors_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): product_colors_translations_aggregate!
  "fetch data from the table: \"product_colors_translations\" using primary key columns"
  product_colors_translations_by_pk(id: Int!): product_colors_translations
  "fetch data from the table: \"product_images\""
  product_images(
    "distinct select on columns"
    distinct_on: [product_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_order_by!],
    "filter the rows returned"
    where: product_images_bool_exp
  ): [product_images!]!
  "fetch data from the table: \"product_images\" using primary key columns"
  product_images_by_pk(id: uuid!): product_images
  "An array relationship"
  product_images_translations(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): [product_images_translations!]!
  "An aggregate relationship"
  product_images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): product_images_translations_aggregate!
  "fetch data from the table: \"product_images_translations\" using primary key columns"
  product_images_translations_by_pk(id: Int!): product_images_translations
  "fetch data from the table: \"product_style_attribute_type_options\""
  product_style_attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_style_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_style_attribute_type_options_bool_exp
  ): [product_style_attribute_type_options!]!
  "fetch data from the table: \"product_style_attribute_type_options\" using primary key columns"
  product_style_attribute_type_options_by_pk(id: uuid!): product_style_attribute_type_options
  "fetch data from the table: \"product_style_variant_media_groups\""
  product_style_variant_media_groups(
    "distinct select on columns"
    distinct_on: [product_style_variant_media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_media_groups_order_by!],
    "filter the rows returned"
    where: product_style_variant_media_groups_bool_exp
  ): [product_style_variant_media_groups!]!
  "fetch data from the table: \"product_style_variant_media_groups\" using primary key columns"
  product_style_variant_media_groups_by_pk(media_group_id: uuid!, product_style_variant_id: uuid!): product_style_variant_media_groups
  "An array relationship"
  product_style_variant_options(
    "distinct select on columns"
    distinct_on: [product_style_variant_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_options_order_by!],
    "filter the rows returned"
    where: product_style_variant_options_bool_exp
  ): [product_style_variant_options!]!
  "fetch data from the table: \"product_style_variant_options\" using primary key columns"
  product_style_variant_options_by_pk(product_style_variant_id: uuid!, variant_type_id: uuid!): product_style_variant_options
  "An array relationship"
  product_style_variants(
    "distinct select on columns"
    distinct_on: [product_style_variants_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variants_order_by!],
    "filter the rows returned"
    where: product_style_variants_bool_exp
  ): [product_style_variants!]!
  "fetch data from the table: \"product_style_variants\" using primary key columns"
  product_style_variants_by_pk(id: uuid!): product_style_variants
  "fetch data from the table: \"product_styles\""
  product_styles(
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): [product_styles!]!
  "fetch aggregated fields from the table: \"product_styles\""
  product_styles_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): product_styles_aggregate!
  "fetch data from the table: \"product_styles\" using primary key columns"
  product_styles_by_pk(id: uuid!): product_styles
  "fetch data from the table: \"product_styles_listed\""
  product_styles_listed(
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "fetch aggregated fields from the table: \"product_styles_listed\""
  product_styles_listed_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "fetch data from the table: \"product_styles_listed\" using primary key columns"
  product_styles_listed_by_pk(product_style_id: uuid!): product_styles_listed
  "An array relationship"
  product_styles_translations(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): [product_styles_translations!]!
  "An aggregate relationship"
  product_styles_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): product_styles_translations_aggregate!
  "fetch data from the table: \"product_styles_translations\" using primary key columns"
  product_styles_translations_by_pk(id: Int!): product_styles_translations
  "An array relationship"
  product_tags(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): [product_tags!]!
  "An aggregate relationship"
  product_tags_aggregate(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): product_tags_aggregate!
  "fetch data from the table: \"product_tags\" using primary key columns"
  product_tags_by_pk(id: uuid!): product_tags
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "fetch data from the table: \"products\" using primary key columns"
  products_by_pk(id: uuid!): products
  "An array relationship"
  products_translations(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): [products_translations!]!
  "An aggregate relationship"
  products_translations_aggregate(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): products_translations_aggregate!
  "fetch data from the table: \"products_translations\" using primary key columns"
  products_translations_by_pk(id: Int!): products_translations
  "fetch data from the table: \"question_sets\""
  question_sets(
    "distinct select on columns"
    distinct_on: [question_sets_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [question_sets_order_by!],
    "filter the rows returned"
    where: question_sets_bool_exp
  ): [question_sets!]!
  "fetch data from the table: \"question_sets\" using primary key columns"
  question_sets_by_pk(id: uuid!): question_sets
  recommendPrice(input: RecommendPriceInput!): RecommendPriceResult!
  recommendations(input: RecommendationsInput!): RecommendationsResult!
  "Used for refreshing a stream chat token after getting/creating a user with getOrCreateStreamChatUser"
  refreshStreamChatToken(input: RefreshStreamChatTokenInput): RefreshStreamChatTokenResult!
  requestEmailVerificationEmail: RequestEmailVerificationEmailResult!
  requestPasswordResetEmail(input: RequestPasswordResetEmailInput): RequestPasswordResetEmailResult
  resolveExternalId(input: ResolveExternalIdInput!): ResolveExternalIdResult!
  resolveExternalOrder(brand_id: uuid!, email: String!, order_number: String!): [ResolveExternalOrderResult]!
  "fetch data from the table: \"retail_associates\""
  retail_associates(
    "distinct select on columns"
    distinct_on: [retail_associates_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_associates_order_by!],
    "filter the rows returned"
    where: retail_associates_bool_exp
  ): [retail_associates!]!
  "fetch data from the table: \"retail_associates\" using primary key columns"
  retail_associates_by_pk(id: uuid!): retail_associates
  "fetch data from the table: \"retail_store_addresses\""
  retail_store_addresses(
    "distinct select on columns"
    distinct_on: [retail_store_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_store_addresses_order_by!],
    "filter the rows returned"
    where: retail_store_addresses_bool_exp
  ): [retail_store_addresses!]!
  "fetch data from the table: \"retail_store_brand_uses\""
  retail_store_brand_uses(
    "distinct select on columns"
    distinct_on: [retail_store_brand_uses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_store_brand_uses_order_by!],
    "filter the rows returned"
    where: retail_store_brand_uses_bool_exp
  ): [retail_store_brand_uses!]!
  "fetch data from the table: \"retail_store_brand_uses\" using primary key columns"
  retail_store_brand_uses_by_pk(brand_id: uuid!, retail_store_id: uuid!, use_case: retail_store_use_cases_enum!): retail_store_brand_uses
  "fetch data from the table: \"retail_stores\""
  retail_stores(
    "distinct select on columns"
    distinct_on: [retail_stores_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_order_by!],
    "filter the rows returned"
    where: retail_stores_bool_exp
  ): [retail_stores!]!
  "fetch data from the table: \"retail_stores\" using primary key columns"
  retail_stores_by_pk(id: uuid!): retail_stores
  "fetch data from the table: \"retail_stores_translations\""
  retail_stores_translations(
    "distinct select on columns"
    distinct_on: [retail_stores_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_translations_order_by!],
    "filter the rows returned"
    where: retail_stores_translations_bool_exp
  ): [retail_stores_translations!]!
  "fetch data from the table: \"retail_stores_translations\" using primary key columns"
  retail_stores_translations_by_pk(id: Int!): retail_stores_translations
  "An array relationship"
  return_items(
    "distinct select on columns"
    distinct_on: [return_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [return_items_order_by!],
    "filter the rows returned"
    where: return_items_bool_exp
  ): [return_items!]!
  "fetch data from the table: \"return_items\" using primary key columns"
  return_items_by_pk(id: uuid!): return_items
  "fetch data from the table: \"returns\""
  returns(
    "distinct select on columns"
    distinct_on: [returns_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [returns_order_by!],
    "filter the rows returned"
    where: returns_bool_exp
  ): [returns!]!
  "fetch data from the table: \"returns\" using primary key columns"
  returns_by_pk(id: uuid!): returns
  revokeRefreshToken: RevokeRefreshTokenResult!
  "fetch data from the table: \"roles\""
  roles(
    "distinct select on columns"
    distinct_on: [roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [roles_order_by!],
    "filter the rows returned"
    where: roles_bool_exp
  ): [roles!]!
  "fetch data from the table: \"roles\" using primary key columns"
  roles_by_pk(role: String!): roles
  search(brand_id: uuid!, request: jsonb!): SearchResult!
  "execute function \"search_listings\" which returns \"unique_listings_results\""
  search_listings(
    "input parameters for function \"search_listings\""
    args: search_listings_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "execute function \"search_listings_31pl\" which returns \"unique_listings_results_tnf\""
  search_listings_31pl(
    "input parameters for function \"search_listings_31pl\""
    args: search_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"search_listings_31pl\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  search_listings_31pl_aggregate(
    "input parameters for function \"search_listings_31pl_aggregate\""
    args: search_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "execute function \"search_listings\" and query aggregates on result of table type \"unique_listings_results\""
  search_listings_aggregate(
    "input parameters for function \"search_listings_aggregate\""
    args: search_listings_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "execute function \"search_listings_tnf\" which returns \"unique_listings_results_tnf\""
  search_listings_tnf(
    "input parameters for function \"search_listings_tnf\""
    args: search_listings_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"search_listings_tnf\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  search_listings_tnf_aggregate(
    "input parameters for function \"search_listings_tnf_aggregate\""
    args: search_listings_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "An array relationship"
  search_page_translations(
    "distinct select on columns"
    distinct_on: [search_page_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_page_translations_order_by!],
    "filter the rows returned"
    where: search_page_translations_bool_exp
  ): [search_page_translations!]!
  "fetch data from the table: \"search_page_translations\" using primary key columns"
  search_page_translations_by_pk(id: Int!): search_page_translations
  "fetch data from the table: \"search_pages\""
  search_pages(
    "distinct select on columns"
    distinct_on: [search_pages_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_pages_order_by!],
    "filter the rows returned"
    where: search_pages_bool_exp
  ): [search_pages!]!
  "fetch data from the table: \"search_pages\" using primary key columns"
  search_pages_by_pk(id: uuid!): search_pages
  "execute function \"search_products\" which returns \"searchable_products_results\""
  search_products(
    "input parameters for function \"search_products\""
    args: search_products_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "execute function \"search_products\" and query aggregates on result of table type \"searchable_products_results\""
  search_products_aggregate(
    "input parameters for function \"search_products_aggregate\""
    args: search_products_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "execute function \"search_products_by_sku\" which returns \"searchable_products_results\""
  search_products_by_sku(
    "input parameters for function \"search_products_by_sku\""
    args: search_products_by_sku_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "execute function \"search_products_by_sku\" and query aggregates on result of table type \"searchable_products_results\""
  search_products_by_sku_aggregate(
    "input parameters for function \"search_products_by_sku_aggregate\""
    args: search_products_by_sku_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "execute function \"search_products_by_sku_collapsed\" which returns \"collapsed_product_results\""
  search_products_by_sku_collapsed(
    "input parameters for function \"search_products_by_sku_collapsed\""
    args: search_products_by_sku_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "execute function \"search_products_by_sku_collapsed\" and query aggregates on result of table type \"collapsed_product_results\""
  search_products_by_sku_collapsed_aggregate(
    "input parameters for function \"search_products_by_sku_collapsed_aggregate\""
    args: search_products_by_sku_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "execute function \"search_products_collapsed\" which returns \"collapsed_product_results\""
  search_products_collapsed(
    "input parameters for function \"search_products_collapsed\""
    args: search_products_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "execute function \"search_products_collapsed\" and query aggregates on result of table type \"collapsed_product_results\""
  search_products_collapsed_aggregate(
    "input parameters for function \"search_products_collapsed_aggregate\""
    args: search_products_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "execute function \"search_styles\" which returns \"product_styles\""
  search_styles(
    "input parameters for function \"search_styles\""
    args: search_styles_args!,
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): [product_styles!]!
  "execute function \"search_styles\" and query aggregates on result of table type \"product_styles\""
  search_styles_aggregate(
    "input parameters for function \"search_styles_aggregate\""
    args: search_styles_args!,
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): product_styles_aggregate!
  "execute function \"search_unique_listed_product_styles_tnf\" which returns \"product_styles_listed\""
  search_unique_listed_product_styles_tnf(
    "input parameters for function \"search_unique_listed_product_styles_tnf\""
    args: search_unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "execute function \"search_unique_listed_product_styles_tnf\" and query aggregates on result of table type \"product_styles_listed\""
  search_unique_listed_product_styles_tnf_aggregate(
    "input parameters for function \"search_unique_listed_product_styles_tnf_aggregate\""
    args: search_unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "execute function \"search_users\" which returns \"users\""
  search_users(
    "input parameters for function \"search_users\""
    args: search_users_args!,
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch data from the table: \"searchable_products\""
  searchable_products(
    "distinct select on columns"
    distinct_on: [searchable_products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_order_by!],
    "filter the rows returned"
    where: searchable_products_bool_exp
  ): [searchable_products!]!
  "fetch aggregated fields from the table: \"searchable_products\""
  searchable_products_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_order_by!],
    "filter the rows returned"
    where: searchable_products_bool_exp
  ): searchable_products_aggregate!
  "An array relationship"
  searchable_products_results(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "An aggregate relationship"
  searchable_products_results_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "fetch data from the table: \"searchable_products_results\" using primary key columns"
  searchable_products_results_by_pk(id: uuid!): searchable_products_results
  "fetch data from the table: \"seller_ratings\""
  seller_ratings(
    "distinct select on columns"
    distinct_on: [seller_ratings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [seller_ratings_order_by!],
    "filter the rows returned"
    where: seller_ratings_bool_exp
  ): [seller_ratings!]!
  "fetch data from the table: \"seller_ratings\" using primary key columns"
  seller_ratings_by_pk(id: uuid!): seller_ratings
  "fetch data from the table: \"shipping_carriers\""
  shipping_carriers(
    "distinct select on columns"
    distinct_on: [shipping_carriers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_carriers_order_by!],
    "filter the rows returned"
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!
  "fetch data from the table: \"shipping_carriers\" using primary key columns"
  shipping_carriers_by_pk(carrier: String!): shipping_carriers
  "fetch data from the table: \"shipping_information\""
  shipping_information(
    "distinct select on columns"
    distinct_on: [shipping_information_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_information_order_by!],
    "filter the rows returned"
    where: shipping_information_bool_exp
  ): [shipping_information!]!
  "fetch data from the table: \"shipping_information\" using primary key columns"
  shipping_information_by_pk(id: uuid!): shipping_information
  "An array relationship"
  shipping_labels(
    "distinct select on columns"
    distinct_on: [shipping_labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_labels_order_by!],
    "filter the rows returned"
    where: shipping_labels_bool_exp
  ): [shipping_labels!]!
  "fetch data from the table: \"shipping_labels\" using primary key columns"
  shipping_labels_by_pk(id: uuid!): shipping_labels
  "fetch data from the table: \"shipping_labels_private\""
  shipping_labels_private(
    "distinct select on columns"
    distinct_on: [shipping_labels_private_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_labels_private_order_by!],
    "filter the rows returned"
    where: shipping_labels_private_bool_exp
  ): [shipping_labels_private!]!
  "fetch data from the table: \"shipping_statuses\""
  shipping_statuses(
    "distinct select on columns"
    distinct_on: [shipping_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_statuses_order_by!],
    "filter the rows returned"
    where: shipping_statuses_bool_exp
  ): [shipping_statuses!]!
  "fetch data from the table: \"shipping_statuses\" using primary key columns"
  shipping_statuses_by_pk(status: String!): shipping_statuses
  "fetch data from the table: \"short_links\""
  short_links(
    "distinct select on columns"
    distinct_on: [short_links_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [short_links_order_by!],
    "filter the rows returned"
    where: short_links_bool_exp
  ): [short_links!]!
  "fetch data from the table: \"short_links\" using primary key columns"
  short_links_by_pk(id: uuid!): short_links
  "fetch data from the table: \"sku_images\""
  sku_images(
    "distinct select on columns"
    distinct_on: [sku_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_order_by!],
    "filter the rows returned"
    where: sku_images_bool_exp
  ): [sku_images!]!
  "fetch data from the table: \"sku_images\" using primary key columns"
  sku_images_by_pk(id: uuid!): sku_images
  "fetch data from the table: \"sku_images_translations\""
  sku_images_translations(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): [sku_images_translations!]!
  "fetch aggregated fields from the table: \"sku_images_translations\""
  sku_images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): sku_images_translations_aggregate!
  "fetch data from the table: \"sku_images_translations\" using primary key columns"
  sku_images_translations_by_pk(id: Int!): sku_images_translations
  "An array relationship"
  sku_variant_type_options(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): [sku_variant_type_options!]!
  "An aggregate relationship"
  sku_variant_type_options_aggregate(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): sku_variant_type_options_aggregate!
  "fetch data from the table: \"sku_variant_type_options\" using primary key columns"
  sku_variant_type_options_by_pk(id: uuid!): sku_variant_type_options
  "An array relationship"
  skus(
    "distinct select on columns"
    distinct_on: [skus_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_order_by!],
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  "fetch data from the table: \"skus\" using primary key columns"
  skus_by_pk(id: uuid!): skus
  "An array relationship"
  skus_translations(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): [skus_translations!]!
  "An aggregate relationship"
  skus_translations_aggregate(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): skus_translations_aggregate!
  "fetch data from the table: \"skus_translations\" using primary key columns"
  skus_translations_by_pk(id: bigint!): skus_translations
  "fetch data from the table: \"storefront_fulfillment_in_store_options\""
  storefront_fulfillment_in_store_options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_options_bool_exp
  ): [storefront_fulfillment_in_store_options!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_options\" using primary key columns"
  storefront_fulfillment_in_store_options_by_pk(id: uuid!): storefront_fulfillment_in_store_options
  "fetch data from the table: \"storefront_fulfillment_in_store_settings\""
  storefront_fulfillment_in_store_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_settings_bool_exp
  ): [storefront_fulfillment_in_store_settings!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_settings\" using primary key columns"
  storefront_fulfillment_in_store_settings_by_pk(id: uuid!): storefront_fulfillment_in_store_settings
  "fetch data from the table: \"storefront_fulfillment_postal_options\""
  storefront_fulfillment_postal_options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_options_bool_exp
  ): [storefront_fulfillment_postal_options!]!
  "fetch data from the table: \"storefront_fulfillment_postal_options\" using primary key columns"
  storefront_fulfillment_postal_options_by_pk(id: uuid!): storefront_fulfillment_postal_options
  "fetch data from the table: \"storefront_fulfillment_postal_settings\""
  storefront_fulfillment_postal_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_settings_bool_exp
  ): [storefront_fulfillment_postal_settings!]!
  "fetch data from the table: \"storefront_fulfillment_postal_settings\" using primary key columns"
  storefront_fulfillment_postal_settings_by_pk(id: uuid!): storefront_fulfillment_postal_settings
  "fetch data from the table: \"storefront_fulfillment_settings\""
  storefront_fulfillment_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_settings_bool_exp
  ): [storefront_fulfillment_settings!]!
  "fetch data from the table: \"storefront_fulfillment_settings\" using primary key columns"
  storefront_fulfillment_settings_by_pk(id: uuid!): storefront_fulfillment_settings
  "fetch data from the table: \"storefront_images\""
  storefront_images(
    "distinct select on columns"
    distinct_on: [storefront_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_images_order_by!],
    "filter the rows returned"
    where: storefront_images_bool_exp
  ): [storefront_images!]!
  "fetch data from the table: \"storefront_images\" using primary key columns"
  storefront_images_by_pk(id: uuid!): storefront_images
  "fetch data from the table: \"storefront_payout_settings\""
  storefront_payout_settings(
    "distinct select on columns"
    distinct_on: [storefront_payout_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_payout_settings_order_by!],
    "filter the rows returned"
    where: storefront_payout_settings_bool_exp
  ): [storefront_payout_settings!]!
  "fetch data from the table: \"storefront_reviews\""
  storefront_reviews(
    "distinct select on columns"
    distinct_on: [storefront_reviews_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_reviews_order_by!],
    "filter the rows returned"
    where: storefront_reviews_bool_exp
  ): [storefront_reviews!]!
  "fetch aggregated fields from the table: \"storefront_reviews\""
  storefront_reviews_aggregate(
    "distinct select on columns"
    distinct_on: [storefront_reviews_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_reviews_order_by!],
    "filter the rows returned"
    where: storefront_reviews_bool_exp
  ): storefront_reviews_aggregate!
  "fetch data from the table: \"storefront_reviews\" using primary key columns"
  storefront_reviews_by_pk(id: uuid!): storefront_reviews
  "fetch data from the table: \"storefront_verified_attributes\""
  storefront_verified_attributes(
    "distinct select on columns"
    distinct_on: [storefront_verified_attributes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_verified_attributes_order_by!],
    "filter the rows returned"
    where: storefront_verified_attributes_bool_exp
  ): [storefront_verified_attributes!]!
  "fetch data from the table: \"storefront_verified_attributes\" using primary key columns"
  storefront_verified_attributes_by_pk(attribute: verified_identity_attributes_enum!, storefront_id: uuid!): storefront_verified_attributes
  "An array relationship"
  storefronts(
    "distinct select on columns"
    distinct_on: [storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefronts_order_by!],
    "filter the rows returned"
    where: storefronts_bool_exp
  ): [storefronts!]!
  "fetch data from the table: \"storefronts\" using primary key columns"
  storefronts_by_pk(id: uuid!): storefronts
  "An array relationship"
  takeback_items(
    "distinct select on columns"
    distinct_on: [takeback_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takeback_items_order_by!],
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  "fetch data from the table: \"takeback_items\" using primary key columns"
  takeback_items_by_pk(id: uuid!): takeback_items
  "fetch data from the table: \"takebacks\""
  takebacks(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): [takebacks!]!
  "fetch aggregated fields from the table: \"takebacks\""
  takebacks_aggregate(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): takebacks_aggregate!
  "fetch data from the table: \"takebacks\" using primary key columns"
  takebacks_by_pk(id: uuid!): takebacks
  "fetch data from the table: \"transaction_types\""
  transaction_types(
    "distinct select on columns"
    distinct_on: [transaction_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transaction_types_order_by!],
    "filter the rows returned"
    where: transaction_types_bool_exp
  ): [transaction_types!]!
  "fetch data from the table: \"transaction_types\" using primary key columns"
  transaction_types_by_pk(type: String!): transaction_types
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(id: uuid!): transactions
  translateText(translateRequest: TranslateRequest!): TranslateResponse!
  "fetch data from the table: \"unassociated_listing_data\""
  unassociated_listing_data(
    "distinct select on columns"
    distinct_on: [unassociated_listing_data_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unassociated_listing_data_order_by!],
    "filter the rows returned"
    where: unassociated_listing_data_bool_exp
  ): [unassociated_listing_data!]!
  "fetch data from the table: \"unassociated_listing_data\" using primary key columns"
  unassociated_listing_data_by_pk(id: uuid!): unassociated_listing_data
  "fetch data from the table: \"unassociated_listing_data_schemas\""
  unassociated_listing_data_schemas(
    "distinct select on columns"
    distinct_on: [unassociated_listing_data_schemas_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unassociated_listing_data_schemas_order_by!],
    "filter the rows returned"
    where: unassociated_listing_data_schemas_bool_exp
  ): [unassociated_listing_data_schemas!]!
  "fetch data from the table: \"unassociated_listing_data_schemas\" using primary key columns"
  unassociated_listing_data_schemas_by_pk(id: uuid!): unassociated_listing_data_schemas
  "execute function \"unique_listed_product_styles_tnf\" which returns \"product_styles_listed\""
  unique_listed_product_styles_tnf(
    "input parameters for function \"unique_listed_product_styles_tnf\""
    args: unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "execute function \"unique_listed_product_styles_tnf\" and query aggregates on result of table type \"product_styles_listed\""
  unique_listed_product_styles_tnf_aggregate(
    "input parameters for function \"unique_listed_product_styles_tnf_aggregate\""
    args: unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "execute function \"unique_listing_tags_by_brand\" which returns \"unique_tags_results\""
  unique_listing_tags_by_brand(
    "input parameters for function \"unique_listing_tags_by_brand\""
    args: unique_listing_tags_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "execute function \"unique_listing_tags_by_brand\" and query aggregates on result of table type \"unique_tags_results\""
  unique_listing_tags_by_brand_aggregate(
    "input parameters for function \"unique_listing_tags_by_brand_aggregate\""
    args: unique_listing_tags_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "execute function \"unique_listing_tags_by_brand_collection\" which returns \"unique_tags_results\""
  unique_listing_tags_by_brand_collection(
    "input parameters for function \"unique_listing_tags_by_brand_collection\""
    args: unique_listing_tags_by_brand_collection_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "execute function \"unique_listing_tags_by_brand_collection\" and query aggregates on result of table type \"unique_tags_results\""
  unique_listing_tags_by_brand_collection_aggregate(
    "input parameters for function \"unique_listing_tags_by_brand_collection_aggregate\""
    args: unique_listing_tags_by_brand_collection_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "execute function \"unique_listings_31pl\" which returns \"unique_listings_results_tnf\""
  unique_listings_31pl(
    "input parameters for function \"unique_listings_31pl\""
    args: unique_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"unique_listings_31pl\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  unique_listings_31pl_aggregate(
    "input parameters for function \"unique_listings_31pl_aggregate\""
    args: unique_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "execute function \"unique_listings_by_brand\" which returns \"unique_listings_results\""
  unique_listings_by_brand(
    "input parameters for function \"unique_listings_by_brand\""
    args: unique_listings_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "execute function \"unique_listings_by_brand\" and query aggregates on result of table type \"unique_listings_results\""
  unique_listings_by_brand_aggregate(
    "input parameters for function \"unique_listings_by_brand_aggregate\""
    args: unique_listings_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "execute function \"unique_listings_by_brand_tnf\" which returns \"unique_listings_results_tnf\""
  unique_listings_by_brand_tnf(
    "input parameters for function \"unique_listings_by_brand_tnf\""
    args: unique_listings_by_brand_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"unique_listings_by_brand_tnf\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  unique_listings_by_brand_tnf_aggregate(
    "input parameters for function \"unique_listings_by_brand_tnf_aggregate\""
    args: unique_listings_by_brand_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "fetch data from the table: \"unique_listings_results\""
  unique_listings_results(
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "fetch aggregated fields from the table: \"unique_listings_results\""
  unique_listings_results_aggregate(
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "fetch data from the table: \"unique_listings_results\" using primary key columns"
  unique_listings_results_by_pk(product_id: uuid!): unique_listings_results
  "fetch data from the table: \"unique_listings_results_tnf\""
  unique_listings_results_tnf(
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "fetch aggregated fields from the table: \"unique_listings_results_tnf\""
  unique_listings_results_tnf_aggregate(
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "fetch data from the table: \"unique_listings_results_tnf\" using primary key columns"
  unique_listings_results_tnf_by_pk(product_id: uuid!): unique_listings_results_tnf
  "fetch data from the table: \"unique_tags_results\""
  unique_tags_results(
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "fetch aggregated fields from the table: \"unique_tags_results\""
  unique_tags_results_aggregate(
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "fetch data from the table: \"unique_tags_results\" using primary key columns"
  unique_tags_results_by_pk(value: String!): unique_tags_results
  "fetch data from the table: \"user_addresses\""
  user_addresses(
    "distinct select on columns"
    distinct_on: [user_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_addresses_order_by!],
    "filter the rows returned"
    where: user_addresses_bool_exp
  ): [user_addresses!]!
  "fetch data from the table: \"user_addresses\" using primary key columns"
  user_addresses_by_pk(id: uuid!): user_addresses
  "fetch data from the table: \"user_alerts\""
  user_alerts(
    "distinct select on columns"
    distinct_on: [user_alerts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_alerts_order_by!],
    "filter the rows returned"
    where: user_alerts_bool_exp
  ): [user_alerts!]!
  "fetch data from the table: \"user_alerts\" using primary key columns"
  user_alerts_by_pk(id: uuid!): user_alerts
  "An array relationship"
  user_balances(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): [user_balances!]!
  "An aggregate relationship"
  user_balances_aggregate(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): user_balances_aggregate!
  "fetch data from the table: \"user_balances\" using primary key columns"
  user_balances_by_pk(id: uuid!): user_balances
  "fetch data from the table: \"user_favorites\""
  user_favorites(
    "distinct select on columns"
    distinct_on: [user_favorites_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_favorites_order_by!],
    "filter the rows returned"
    where: user_favorites_bool_exp
  ): [user_favorites!]!
  "fetch data from the table: \"user_favorites\" using primary key columns"
  user_favorites_by_pk(id: uuid!): user_favorites
  "fetch data from the table: \"user_metadata\""
  user_metadata(
    "distinct select on columns"
    distinct_on: [user_metadata_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_metadata_order_by!],
    "filter the rows returned"
    where: user_metadata_bool_exp
  ): [user_metadata!]!
  "fetch data from the table: \"user_metadata\" using primary key columns"
  user_metadata_by_pk(id: uuid!): user_metadata
  "fetch data from the table: \"user_roles\""
  user_roles(
    "distinct select on columns"
    distinct_on: [user_roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_roles_order_by!],
    "filter the rows returned"
    where: user_roles_bool_exp
  ): [user_roles!]!
  "fetch data from the table: \"user_roles\" using primary key columns"
  user_roles_by_pk(id: uuid!): user_roles
  "fetch data from the table: \"user_verification_checks\""
  user_verification_checks(
    "distinct select on columns"
    distinct_on: [user_verification_checks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_verification_checks_order_by!],
    "filter the rows returned"
    where: user_verification_checks_bool_exp
  ): [user_verification_checks!]!
  "fetch data from the table: \"user_verification_checks\" using primary key columns"
  user_verification_checks_by_pk(id: uuid!): user_verification_checks
  "fetch data from the table: \"users\""
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch data from the table: \"users\" using primary key columns"
  users_by_pk(id: String!): users
  "fetch data from the table: \"users_private\""
  users_private(
    "distinct select on columns"
    distinct_on: [users_private_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_private_order_by!],
    "filter the rows returned"
    where: users_private_bool_exp
  ): [users_private!]!
  validateAddress(address: ValidateAddressInput!): ValidateAddressResult
  "Verifies if an address is valid for a brand and fulfillment info"
  validateAddressV2(input: ValidateAddressV2Input!): ValidateAddressV2Result!
  validateAuthActionToken(input: ValidateAuthActionTokenInput!): ValidateAuthActionTokenResult
  "An array relationship"
  variant_type_options(
    "distinct select on columns"
    distinct_on: [variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_order_by!],
    "filter the rows returned"
    where: variant_type_options_bool_exp
  ): [variant_type_options!]!
  "fetch data from the table: \"variant_type_options\" using primary key columns"
  variant_type_options_by_pk(id: uuid!): variant_type_options
  "An array relationship"
  variant_type_options_translations(
    "distinct select on columns"
    distinct_on: [variant_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_translations_order_by!],
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]!
  "fetch data from the table: \"variant_type_options_translations\" using primary key columns"
  variant_type_options_translations_by_pk(id: Int!): variant_type_options_translations
  "fetch data from the table: \"variant_types\""
  variant_types(
    "distinct select on columns"
    distinct_on: [variant_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_order_by!],
    "filter the rows returned"
    where: variant_types_bool_exp
  ): [variant_types!]!
  "fetch aggregated fields from the table: \"variant_types\""
  variant_types_aggregate(
    "distinct select on columns"
    distinct_on: [variant_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_order_by!],
    "filter the rows returned"
    where: variant_types_bool_exp
  ): variant_types_aggregate!
  "fetch data from the table: \"variant_types\" using primary key columns"
  variant_types_by_pk(id: uuid!): variant_types
  "An array relationship"
  variant_types_translations(
    "distinct select on columns"
    distinct_on: [variant_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_translations_order_by!],
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]!
  "fetch data from the table: \"variant_types_translations\" using primary key columns"
  variant_types_translations_by_pk(id: Int!): variant_types_translations
  wmsPreviewListing(brand_id: uuid, wms_item_id: uuid): WmsPreviewListing
  "An array relationship"
  wms_items(
    "distinct select on columns"
    distinct_on: [wms_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [wms_items_order_by!],
    "filter the rows returned"
    where: wms_items_bool_exp
  ): [wms_items!]!
  "fetch data from the table: \"wms_items\" using primary key columns"
  wms_items_by_pk(id: uuid!): wms_items
  "fetch data from the table: \"workflow_definitions\""
  workflow_definitions(
    "distinct select on columns"
    distinct_on: [workflow_definitions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_definitions_order_by!],
    "filter the rows returned"
    where: workflow_definitions_bool_exp
  ): [workflow_definitions!]!
  "fetch data from the table: \"workflow_definitions\" using primary key columns"
  workflow_definitions_by_pk(id: uuid!): workflow_definitions
  "fetch data from the table: \"workflow_item_event_types\""
  workflow_item_event_types(
    "distinct select on columns"
    distinct_on: [workflow_item_event_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_item_event_types_order_by!],
    "filter the rows returned"
    where: workflow_item_event_types_bool_exp
  ): [workflow_item_event_types!]!
  "fetch data from the table: \"workflow_item_event_types\" using primary key columns"
  workflow_item_event_types_by_pk(type: String!): workflow_item_event_types
  "An array relationship"
  workflow_item_events(
    "distinct select on columns"
    distinct_on: [workflow_item_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_item_events_order_by!],
    "filter the rows returned"
    where: workflow_item_events_bool_exp
  ): [workflow_item_events!]!
  "fetch data from the table: \"workflow_item_events\" using primary key columns"
  workflow_item_events_by_pk(id: uuid!): workflow_item_events
  "An array relationship"
  workflow_items(
    "distinct select on columns"
    distinct_on: [workflow_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_items_order_by!],
    "filter the rows returned"
    where: workflow_items_bool_exp
  ): [workflow_items!]!
  "fetch data from the table: \"workflow_items\" using primary key columns"
  workflow_items_by_pk(id: uuid!): workflow_items
  "An array relationship"
  workflows(
    "distinct select on columns"
    distinct_on: [workflows_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflows_order_by!],
    "filter the rows returned"
    where: workflows_bool_exp
  ): [workflows!]!
  "fetch data from the table: \"workflows\" using primary key columns"
  workflows_by_pk(id: uuid!): workflows
}

"columns and relationships of \"question_sets\""
type question_sets {
  brand_id: uuid!
  "An array relationship"
  condition_questions(
    "distinct select on columns"
    distinct_on: [condition_questions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_order_by!],
    "filter the rows returned"
    where: condition_questions_bool_exp
  ): [condition_questions!]!
  created_at: timestamptz!
  id: uuid!
  name: String!
  notes: String
  uid: String!
  updated_at: timestamptz!
}

"columns and relationships of \"retail_associates\""
type retail_associates {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  id: uuid!
  retail_store_id: uuid
  store_number: String
  "An object relationship"
  user: users!
  user_id: String!
}

"columns and relationships of \"retail_store_addresses\""
type retail_store_addresses {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  postal_code: String
}

"columns and relationships of \"retail_store_brand_uses\""
type retail_store_brand_uses {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "An object relationship"
  retail_store: retail_stores!
  retail_store_id: uuid!
  use_case: retail_store_use_cases_enum!
}

"columns and relationships of \"retail_stores\""
type retail_stores {
  "An object relationship"
  address: addresses!
  address_id: uuid!
  "A computed field, executes function \"r_content\""
  content(
    "distinct select on columns"
    distinct_on: [retail_stores_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_translations_order_by!],
    "filter the rows returned"
    where: retail_stores_translations_bool_exp
  ): [retail_stores_translations!]
  created_at: timestamptz!
  external_identifier: String
  id: uuid!
  "An array relationship"
  pos_stations(
    "distinct select on columns"
    distinct_on: [pos_stations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [pos_stations_order_by!],
    "filter the rows returned"
    where: pos_stations_bool_exp
  ): [pos_stations!]!
  "An object relationship"
  public_address: retail_store_addresses
  "An array relationship"
  translations(
    "distinct select on columns"
    distinct_on: [retail_stores_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_translations_order_by!],
    "filter the rows returned"
    where: retail_stores_translations_bool_exp
  ): [retail_stores_translations!]!
  updated_at: timestamptz!
}

"columns and relationships of \"retail_stores_translations\""
type retail_stores_translations {
  id: Int!
  lang: String!
  name: String!
  retail_store_id: uuid!
}

"columns and relationships of \"return_items\""
type return_items {
  created_at: timestamptz!
  damage_type: String
  id: uuid!
  "An object relationship"
  order_item: order_items!
  order_item_id: uuid!
  "An object relationship"
  return: returns!
  return_id: uuid!
  return_reason: String
  status: return_item_statuses_enum!
  updated_at: timestamptz!
}

"response of any mutation on the table \"return_items\""
type return_items_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [return_items!]!
}

"columns and relationships of \"returns\""
type returns {
  "An object relationship"
  address: order_addresses!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  email: String
  id: uuid!
  "An array relationship"
  items(
    "distinct select on columns"
    distinct_on: [return_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [return_items_order_by!],
    "filter the rows returned"
    where: return_items_bool_exp
  ): [return_items!]!
  preferred_language: String
  return_shipping_address_id: uuid!
  return_shipping_label_id: uuid!
  "An object relationship"
  shipping_label: shipping_labels!
  status: return_statuses_enum!
  stripe_refund_id: String
  subtotal: Int!
  tax: Int!
  total: Int!
  updated_at: timestamptz!
  "An object relationship"
  user: users
  user_id: String
}

"response of any mutation on the table \"returns\""
type returns_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [returns!]!
}

"columns and relationships of \"roles\""
type roles {
  role: String!
}

"columns and relationships of \"search_page_translations\""
type search_page_translations {
  created_at: timestamptz!
  description: String
  display_name: String!
  id: Int!
  locale: String!
  "An object relationship"
  search_page: search_pages!
  search_page_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"search_pages\""
type search_pages {
  active: Boolean!
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "An object relationship"
  collection: collections!
  collection_id: uuid!
  "A computed field, executes function \"sp_content\""
  content(
    "distinct select on columns"
    distinct_on: [search_page_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_page_translations_order_by!],
    "filter the rows returned"
    where: search_page_translations_bool_exp
  ): [search_page_translations!]
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  search_page_translations(
    "distinct select on columns"
    distinct_on: [search_page_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_page_translations_order_by!],
    "filter the rows returned"
    where: search_page_translations_bool_exp
  ): [search_page_translations!]!
  slug: String!
  updated_at: timestamptz!
}

"columns and relationships of \"searchable_products\""
type searchable_products {
  "An object relationship"
  brand: brands
  color: String
  color_mapping: String
  id: uuid
  name: String
  "An object relationship"
  product: products
  product_brand_id: uuid
  sizes: String
  skus: String
  type: String
}

"aggregated selection of \"searchable_products\""
type searchable_products_aggregate {
  aggregate: searchable_products_aggregate_fields
  nodes: [searchable_products!]!
}

"aggregate fields of \"searchable_products\""
type searchable_products_aggregate_fields {
  count(columns: [searchable_products_select_column!], distinct: Boolean): Int!
  max: searchable_products_max_fields
  min: searchable_products_min_fields
}

"aggregate max on columns"
type searchable_products_max_fields {
  color: String
  color_mapping: String
  id: uuid
  name: String
  product_brand_id: uuid
  sizes: String
  skus: String
  type: String
}

"aggregate min on columns"
type searchable_products_min_fields {
  color: String
  color_mapping: String
  id: uuid
  name: String
  product_brand_id: uuid
  sizes: String
  skus: String
  type: String
}

"columns and relationships of \"searchable_products_results\""
type searchable_products_results {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  color: String
  color_mapping: String!
  id: uuid!
  name: String!
  "An object relationship"
  product: products!
  sizes: String!
  skus: String!
  type: String
}

"aggregated selection of \"searchable_products_results\""
type searchable_products_results_aggregate {
  aggregate: searchable_products_results_aggregate_fields
  nodes: [searchable_products_results!]!
}

"aggregate fields of \"searchable_products_results\""
type searchable_products_results_aggregate_fields {
  count(columns: [searchable_products_results_select_column!], distinct: Boolean): Int!
  max: searchable_products_results_max_fields
  min: searchable_products_results_min_fields
}

"aggregate max on columns"
type searchable_products_results_max_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  id: uuid
  name: String
  sizes: String
  skus: String
  type: String
}

"aggregate min on columns"
type searchable_products_results_min_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  id: uuid
  name: String
  sizes: String
  skus: String
  type: String
}

"Note: this table is going to be deprecated in favor of a new order_item_reviews table. It is not currently read from anywhere in our app."
type seller_ratings {
  comment: String
  created_at: timestamptz!
  id: uuid!
  listing_id: uuid!
  rating: Int!
  seller_id: String!
  storefront_id: uuid
  user_id: String
  user_rated: Boolean!
}

"response of any mutation on the table \"seller_ratings\""
type seller_ratings_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [seller_ratings!]!
}

"columns and relationships of \"shipping_carriers\""
type shipping_carriers {
  carrier: String!
}

"columns and relationships of \"shipping_information\""
type shipping_information {
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  in_store_pickups(
    "distinct select on columns"
    distinct_on: [in_store_pickups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [in_store_pickups_order_by!],
    "filter the rows returned"
    where: in_store_pickups_bool_exp
  ): [in_store_pickups!]!
  "An array relationship"
  order_items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  order_items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  shipping_method: shipping_methods_enum!
  shipping_method_identifier: String
  updated_at: timestamptz!
}

"response of any mutation on the table \"shipping_information\""
type shipping_information_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [shipping_information!]!
}

"columns and relationships of \"shipping_labels\""
type shipping_labels {
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  listing: listings
  listing_id: uuid
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  "An array relationship"
  mail_takebacks(
    "distinct select on columns"
    distinct_on: [mail_takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mail_takebacks_order_by!],
    "filter the rows returned"
    where: mail_takebacks_bool_exp
  ): [mail_takebacks!]!
  "An object relationship"
  private: shipping_labels_private
  "An array relationship"
  return_listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  return_listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  shipping_carrier: shipping_carriers_enum
  shipping_service: shipping_services_enum!
  shipping_service_id: String!
  status: shipping_statuses_enum!
  tracking_number: String!
  tracking_url: String!
  updated_at: timestamptz
  user_id: String
}

"columns and relationships of \"shipping_labels_private\""
type shipping_labels_private {
  id: uuid
  label_url: String
  metadata(
    "JSON select path"
    path: String
  ): jsonb
  "An object relationship"
  shipping_label: shipping_labels
}

"columns and relationships of \"shipping_statuses\""
type shipping_statuses {
  status: String!
}

"columns and relationships of \"short_links\""
type short_links {
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  identifier: String!
  path: String!
  query_params(
    "JSON select path"
    path: String
  ): jsonb!
  updated_at: timestamptz!
}

"columns and relationships of \"sku_images\""
type sku_images {
  alt: String
  "A computed field, executes function \"si_content\""
  content(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): [sku_images_translations!]
  created_at: timestamptz!
  detail: Boolean!
  id: uuid!
  "An array relationship"
  images_translations(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): [sku_images_translations!]!
  "An aggregate relationship"
  images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): sku_images_translations_aggregate!
  index: Int
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  primary: Boolean!
  primary_hover: Boolean!
  "An object relationship"
  sku: skus!
  sku_id: uuid!
  src: String!
  swatch: Boolean!
  uid: String!
  updated_at: timestamptz!
}

"columns and relationships of \"sku_images_translations\""
type sku_images_translations {
  alt: String
  id: Int!
  lang: String!
  sku_image_id: uuid!
}

"aggregated selection of \"sku_images_translations\""
type sku_images_translations_aggregate {
  aggregate: sku_images_translations_aggregate_fields
  nodes: [sku_images_translations!]!
}

"aggregate fields of \"sku_images_translations\""
type sku_images_translations_aggregate_fields {
  avg: sku_images_translations_avg_fields
  count(columns: [sku_images_translations_select_column!], distinct: Boolean): Int!
  max: sku_images_translations_max_fields
  min: sku_images_translations_min_fields
  stddev: sku_images_translations_stddev_fields
  stddev_pop: sku_images_translations_stddev_pop_fields
  stddev_samp: sku_images_translations_stddev_samp_fields
  sum: sku_images_translations_sum_fields
  var_pop: sku_images_translations_var_pop_fields
  var_samp: sku_images_translations_var_samp_fields
  variance: sku_images_translations_variance_fields
}

"aggregate avg on columns"
type sku_images_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type sku_images_translations_max_fields {
  alt: String
  id: Int
  lang: String
  sku_image_id: uuid
}

"aggregate min on columns"
type sku_images_translations_min_fields {
  alt: String
  id: Int
  lang: String
  sku_image_id: uuid
}

"aggregate stddev on columns"
type sku_images_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type sku_images_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type sku_images_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type sku_images_translations_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type sku_images_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type sku_images_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type sku_images_translations_variance_fields {
  id: Float
}

"columns and relationships of \"sku_variant_type_options\""
type sku_variant_type_options {
  id: uuid!
  "An object relationship"
  sku: skus!
  sku_id: uuid!
  "An object relationship"
  variant_type: variant_types!
  variant_type_id: uuid!
  "An object relationship"
  variant_type_option: variant_type_options!
  variant_type_option_id: uuid!
  "An array relationship"
  variant_type_options_translations(
    "distinct select on columns"
    distinct_on: [variant_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_translations_order_by!],
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]!
  "An array relationship"
  variant_types_translations(
    "distinct select on columns"
    distinct_on: [variant_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_translations_order_by!],
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]!
}

"aggregated selection of \"sku_variant_type_options\""
type sku_variant_type_options_aggregate {
  aggregate: sku_variant_type_options_aggregate_fields
  nodes: [sku_variant_type_options!]!
}

"aggregate fields of \"sku_variant_type_options\""
type sku_variant_type_options_aggregate_fields {
  count(columns: [sku_variant_type_options_select_column!], distinct: Boolean): Int!
  max: sku_variant_type_options_max_fields
  min: sku_variant_type_options_min_fields
}

"aggregate max on columns"
type sku_variant_type_options_max_fields {
  id: uuid
  sku_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"aggregate min on columns"
type sku_variant_type_options_min_fields {
  id: uuid
  sku_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"columns and relationships of \"skus\""
type skus {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  care: String
  "A computed field, executes function \"s_content\""
  content(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): [skus_translations!]
  created_at: timestamptz!
  description: String
  dimensions: String
  dimensions_lite: String
  "An array relationship"
  external_sku_ids(
    "distinct select on columns"
    distinct_on: [external_sku_ids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [external_sku_ids_order_by!],
    "filter the rows returned"
    where: external_sku_ids_bool_exp
  ): [external_sku_ids!]!
  id: uuid!
  "An array relationship"
  images(
    "distinct select on columns"
    distinct_on: [sku_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_order_by!],
    "filter the rows returned"
    where: sku_images_bool_exp
  ): [sku_images!]!
  is_material: Boolean!
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  luggage_sleeve: Boolean
  new_logo: Boolean
  original_price: Int
  "An object relationship"
  product: products
  product_id: uuid
  "An object relationship"
  product_style: product_styles
  product_style_id: uuid
  size: String
  sku: String!
  "An array relationship"
  sku_variant_type_options(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): [sku_variant_type_options!]!
  "An aggregate relationship"
  sku_variant_type_options_aggregate(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): sku_variant_type_options_aggregate!
  "An array relationship"
  skus_translations(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): [skus_translations!]!
  "An aggregate relationship"
  skus_translations_aggregate(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): skus_translations_aggregate!
  uid: String!
  updated_at: timestamptz!
  weight: numeric
  weight_unit: String
}

"columns and relationships of \"skus_translations\""
type skus_translations {
  care: String
  description: String
  dimensions: String
  dimensions_lite: String
  id: bigint!
  lang: String!
  size: String
  sku_id: uuid!
}

"aggregated selection of \"skus_translations\""
type skus_translations_aggregate {
  aggregate: skus_translations_aggregate_fields
  nodes: [skus_translations!]!
}

"aggregate fields of \"skus_translations\""
type skus_translations_aggregate_fields {
  avg: skus_translations_avg_fields
  count(columns: [skus_translations_select_column!], distinct: Boolean): Int!
  max: skus_translations_max_fields
  min: skus_translations_min_fields
  stddev: skus_translations_stddev_fields
  stddev_pop: skus_translations_stddev_pop_fields
  stddev_samp: skus_translations_stddev_samp_fields
  sum: skus_translations_sum_fields
  var_pop: skus_translations_var_pop_fields
  var_samp: skus_translations_var_samp_fields
  variance: skus_translations_variance_fields
}

"aggregate avg on columns"
type skus_translations_avg_fields {
  id: Float
}

"aggregate max on columns"
type skus_translations_max_fields {
  care: String
  description: String
  dimensions: String
  dimensions_lite: String
  id: bigint
  lang: String
  size: String
  sku_id: uuid
}

"aggregate min on columns"
type skus_translations_min_fields {
  care: String
  description: String
  dimensions: String
  dimensions_lite: String
  id: bigint
  lang: String
  size: String
  sku_id: uuid
}

"aggregate stddev on columns"
type skus_translations_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type skus_translations_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type skus_translations_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type skus_translations_sum_fields {
  id: bigint
}

"aggregate var_pop on columns"
type skus_translations_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type skus_translations_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type skus_translations_variance_fields {
  id: Float
}

"columns and relationships of \"storefront_fulfillment_in_store_options\""
type storefront_fulfillment_in_store_options {
  "An object relationship"
  brand_fulfillment_in_store_option: brand_fulfillment_in_store_options!
  brand_fulfillment_in_store_options_id: uuid!
  created_at: timestamptz!
  id: uuid!
  shipping_fee: Int
  storefront_fulfillment_in_store_settings_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_fulfillment_in_store_settings\""
type storefront_fulfillment_in_store_settings {
  brand_fulfillment_in_store_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_options_bool_exp
  ): [storefront_fulfillment_in_store_options!]!
  storefront_fulfillment_settings_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_fulfillment_postal_options\""
type storefront_fulfillment_postal_options {
  brand_fulfillment_postal_options_id: uuid!
  created_at: timestamptz!
  id: uuid!
  shipping_fee: Int
  storefront_fulfillment_postal_settings_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_fulfillment_postal_settings\""
type storefront_fulfillment_postal_settings {
  brand_fulfillment_postal_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_options_bool_exp
  ): [storefront_fulfillment_postal_options!]!
  storefront_fulfillment_settings_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_fulfillment_settings\""
type storefront_fulfillment_settings {
  brand_fulfillment_settings_id: uuid!
  created_at: timestamptz!
  id: uuid!
  "An array relationship"
  in_store_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_settings_bool_exp
  ): [storefront_fulfillment_in_store_settings!]!
  "An array relationship"
  postal_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_settings_bool_exp
  ): [storefront_fulfillment_postal_settings!]!
  storefront_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_images\""
type storefront_images {
  alt: String
  created_at: timestamptz!
  id: uuid!
  path: String
  src: String!
  updated_at: timestamptz!
}

"columns and relationships of \"storefront_payout_settings\""
type storefront_payout_settings {
  cashout_percent: numeric
  store_credit_percent: numeric
  "An array relationship"
  storefronts(
    "distinct select on columns"
    distinct_on: [storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefronts_order_by!],
    "filter the rows returned"
    where: storefronts_bool_exp
  ): [storefronts!]!
  stripe_account_id: String
}

"This table represents seller reviews in the context of a specific order"
type storefront_reviews {
  comment: String
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  order: orders!
  order_id: uuid!
  rating: Int!
  status: review_statuses_enum!
  "An object relationship"
  storefront: storefronts!
  storefront_id: uuid!
  updated_at: timestamptz!
}

"aggregated selection of \"storefront_reviews\""
type storefront_reviews_aggregate {
  aggregate: storefront_reviews_aggregate_fields
  nodes: [storefront_reviews!]!
}

"aggregate fields of \"storefront_reviews\""
type storefront_reviews_aggregate_fields {
  avg: storefront_reviews_avg_fields
  count(columns: [storefront_reviews_select_column!], distinct: Boolean): Int!
  max: storefront_reviews_max_fields
  min: storefront_reviews_min_fields
  stddev: storefront_reviews_stddev_fields
  stddev_pop: storefront_reviews_stddev_pop_fields
  stddev_samp: storefront_reviews_stddev_samp_fields
  sum: storefront_reviews_sum_fields
  var_pop: storefront_reviews_var_pop_fields
  var_samp: storefront_reviews_var_samp_fields
  variance: storefront_reviews_variance_fields
}

"aggregate avg on columns"
type storefront_reviews_avg_fields {
  rating: Float
}

"aggregate max on columns"
type storefront_reviews_max_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  order_id: uuid
  rating: Int
  storefront_id: uuid
  updated_at: timestamptz
}

"aggregate min on columns"
type storefront_reviews_min_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  order_id: uuid
  rating: Int
  storefront_id: uuid
  updated_at: timestamptz
}

"response of any mutation on the table \"storefront_reviews\""
type storefront_reviews_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [storefront_reviews!]!
}

"aggregate stddev on columns"
type storefront_reviews_stddev_fields {
  rating: Float
}

"aggregate stddev_pop on columns"
type storefront_reviews_stddev_pop_fields {
  rating: Float
}

"aggregate stddev_samp on columns"
type storefront_reviews_stddev_samp_fields {
  rating: Float
}

"aggregate sum on columns"
type storefront_reviews_sum_fields {
  rating: Int
}

"aggregate var_pop on columns"
type storefront_reviews_var_pop_fields {
  rating: Float
}

"aggregate var_samp on columns"
type storefront_reviews_var_samp_fields {
  rating: Float
}

"aggregate variance on columns"
type storefront_reviews_variance_fields {
  rating: Float
}

"columns and relationships of \"storefront_verified_attributes\""
type storefront_verified_attributes {
  attribute: verified_identity_attributes_enum!
  "An object relationship"
  storefront: storefronts!
  storefront_id: uuid!
}

"columns and relationships of \"storefronts\""
type storefronts {
  "An object relationship"
  address: addresses
  "An array relationship"
  annual_sales_totals(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An aggregate relationship"
  annual_sales_totals_aggregate(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): annual_sales_totals_aggregate!
  "An array relationship"
  balances(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): [user_balances!]!
  "An aggregate relationship"
  balances_aggregate(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): user_balances_aggregate!
  bio: String
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "An object relationship"
  dac7_verified: dac7_verified_storefronts
  "An array relationship"
  fulfillment_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_settings_bool_exp
  ): [storefront_fulfillment_settings!]!
  hide_address: Boolean!
  id: uuid!
  links(
    "JSON select path"
    path: String
  ): jsonb
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  "An object relationship"
  logo: storefront_images
  logo_id: uuid
  name: String!
  "An object relationship"
  owner: users!
  "An object relationship"
  payout_settings: storefront_payout_settings
  primary_address_id: uuid
  slug: String!
  status: storefront_statuses_enum!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  type: storefront_types_enum!
  verified: Boolean!
  "An array relationship"
  verified_attributes(
    "distinct select on columns"
    distinct_on: [storefront_verified_attributes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_verified_attributes_order_by!],
    "filter the rows returned"
    where: storefront_verified_attributes_bool_exp
  ): [storefront_verified_attributes!]!
}

"response of any mutation on the table \"storefronts\""
type storefronts_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [storefronts!]!
}

type subscription_root {
  "fetch data from the table: \"addresses\""
  addresses(
    "distinct select on columns"
    distinct_on: [addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [addresses_order_by!],
    "filter the rows returned"
    where: addresses_bool_exp
  ): [addresses!]!
  "fetch data from the table: \"addresses\" using primary key columns"
  addresses_by_pk(id: uuid!): addresses
  "fetch data from the table in a streaming manner: \"addresses\""
  addresses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [addresses_stream_cursor_input]!,
    "filter the rows returned"
    where: addresses_bool_exp
  ): [addresses!]!
  "An array relationship"
  annual_sales_totals(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An aggregate relationship"
  annual_sales_totals_aggregate(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): annual_sales_totals_aggregate!
  "fetch data from the table in a streaming manner: \"annual_sales_totals\""
  annual_sales_totals_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [annual_sales_totals_stream_cursor_input]!,
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An array relationship"
  applied_discount_codes(
    "distinct select on columns"
    distinct_on: [applied_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [applied_discount_codes_order_by!],
    "filter the rows returned"
    where: applied_discount_codes_bool_exp
  ): [applied_discount_codes!]!
  "fetch data from the table: \"applied_discount_codes\" using primary key columns"
  applied_discount_codes_by_pk(id: uuid!): applied_discount_codes
  "fetch data from the table in a streaming manner: \"applied_discount_codes\""
  applied_discount_codes_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [applied_discount_codes_stream_cursor_input]!,
    "filter the rows returned"
    where: applied_discount_codes_bool_exp
  ): [applied_discount_codes!]!
  "An array relationship"
  attempted_discount_codes(
    "distinct select on columns"
    distinct_on: [attempted_discount_codes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attempted_discount_codes_order_by!],
    "filter the rows returned"
    where: attempted_discount_codes_bool_exp
  ): [attempted_discount_codes!]!
  "fetch data from the table: \"attempted_discount_codes\" using primary key columns"
  attempted_discount_codes_by_pk(id: uuid!): attempted_discount_codes
  "fetch data from the table in a streaming manner: \"attempted_discount_codes\""
  attempted_discount_codes_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attempted_discount_codes_stream_cursor_input]!,
    "filter the rows returned"
    where: attempted_discount_codes_bool_exp
  ): [attempted_discount_codes!]!
  "An array relationship"
  attribute_type_options(
    "distinct select on columns"
    distinct_on: [attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_order_by!],
    "filter the rows returned"
    where: attribute_type_options_bool_exp
  ): [attribute_type_options!]!
  "fetch data from the table: \"attribute_type_options\" using primary key columns"
  attribute_type_options_by_pk(id: uuid!): attribute_type_options
  "fetch data from the table in a streaming manner: \"attribute_type_options\""
  attribute_type_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attribute_type_options_stream_cursor_input]!,
    "filter the rows returned"
    where: attribute_type_options_bool_exp
  ): [attribute_type_options!]!
  "fetch data from the table: \"attribute_type_options_translations\""
  attribute_type_options_translations(
    "distinct select on columns"
    distinct_on: [attribute_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_type_options_translations_order_by!],
    "filter the rows returned"
    where: attribute_type_options_translations_bool_exp
  ): [attribute_type_options_translations!]!
  "fetch data from the table: \"attribute_type_options_translations\" using primary key columns"
  attribute_type_options_translations_by_pk(id: Int!): attribute_type_options_translations
  "fetch data from the table in a streaming manner: \"attribute_type_options_translations\""
  attribute_type_options_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attribute_type_options_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: attribute_type_options_translations_bool_exp
  ): [attribute_type_options_translations!]!
  "An array relationship"
  attribute_types(
    "distinct select on columns"
    distinct_on: [attribute_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_order_by!],
    "filter the rows returned"
    where: attribute_types_bool_exp
  ): [attribute_types!]!
  "fetch data from the table: \"attribute_types\" using primary key columns"
  attribute_types_by_pk(id: uuid!): attribute_types
  "fetch data from the table in a streaming manner: \"attribute_types\""
  attribute_types_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attribute_types_stream_cursor_input]!,
    "filter the rows returned"
    where: attribute_types_bool_exp
  ): [attribute_types!]!
  "fetch data from the table: \"attribute_types_translations\""
  attribute_types_translations(
    "distinct select on columns"
    distinct_on: [attribute_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [attribute_types_translations_order_by!],
    "filter the rows returned"
    where: attribute_types_translations_bool_exp
  ): [attribute_types_translations!]!
  "fetch data from the table: \"attribute_types_translations\" using primary key columns"
  attribute_types_translations_by_pk(id: Int!): attribute_types_translations
  "fetch data from the table in a streaming manner: \"attribute_types_translations\""
  attribute_types_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [attribute_types_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: attribute_types_translations_bool_exp
  ): [attribute_types_translations!]!
  "fetch data from the table: \"auction_bids\""
  auction_bids(
    "distinct select on columns"
    distinct_on: [auction_bids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_order_by!],
    "filter the rows returned"
    where: auction_bids_bool_exp
  ): [auction_bids!]!
  "fetch data from the table: \"auction_bids\" using primary key columns"
  auction_bids_by_pk(id: uuid!): auction_bids
  "fetch data from the table: \"auction_bids_history\""
  auction_bids_history(
    "distinct select on columns"
    distinct_on: [auction_bids_history_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auction_bids_history_order_by!],
    "filter the rows returned"
    where: auction_bids_history_bool_exp
  ): [auction_bids_history!]!
  "fetch data from the table: \"auction_bids_history\" using primary key columns"
  auction_bids_history_by_pk(id: uuid!): auction_bids_history
  "fetch data from the table in a streaming manner: \"auction_bids_history\""
  auction_bids_history_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [auction_bids_history_stream_cursor_input]!,
    "filter the rows returned"
    where: auction_bids_history_bool_exp
  ): [auction_bids_history!]!
  "fetch data from the table in a streaming manner: \"auction_bids\""
  auction_bids_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [auction_bids_stream_cursor_input]!,
    "filter the rows returned"
    where: auction_bids_bool_exp
  ): [auction_bids!]!
  "An array relationship"
  auctions(
    "distinct select on columns"
    distinct_on: [auctions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [auctions_order_by!],
    "filter the rows returned"
    where: auctions_bool_exp
  ): [auctions!]!
  "fetch data from the table: \"auctions\" using primary key columns"
  auctions_by_pk(id: uuid!): auctions
  "fetch data from the table in a streaming manner: \"auctions\""
  auctions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [auctions_stream_cursor_input]!,
    "filter the rows returned"
    where: auctions_bool_exp
  ): [auctions!]!
  "An array relationship"
  brand_categories(
    "distinct select on columns"
    distinct_on: [brand_categories_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_order_by!],
    "filter the rows returned"
    where: brand_categories_bool_exp
  ): [brand_categories!]!
  "fetch data from the table: \"brand_categories\" using primary key columns"
  brand_categories_by_pk(id: uuid!): brand_categories
  "fetch data from the table in a streaming manner: \"brand_categories\""
  brand_categories_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_categories_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_categories_bool_exp
  ): [brand_categories!]!
  "fetch data from the table: \"brand_categories_translations\""
  brand_categories_translations(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): [brand_categories_translations!]!
  "fetch aggregated fields from the table: \"brand_categories_translations\""
  brand_categories_translations_aggregate(
    "distinct select on columns"
    distinct_on: [brand_categories_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_categories_translations_order_by!],
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): brand_categories_translations_aggregate!
  "fetch data from the table: \"brand_categories_translations\" using primary key columns"
  brand_categories_translations_by_pk(id: Int!): brand_categories_translations
  "fetch data from the table in a streaming manner: \"brand_categories_translations\""
  brand_categories_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_categories_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_categories_translations_bool_exp
  ): [brand_categories_translations!]!
  "fetch data from the table: \"brand_fulfillment_in_store_options\""
  brand_fulfillment_in_store_options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_options_bool_exp
  ): [brand_fulfillment_in_store_options!]!
  "fetch data from the table: \"brand_fulfillment_in_store_options\" using primary key columns"
  brand_fulfillment_in_store_options_by_pk(id: uuid!): brand_fulfillment_in_store_options
  "fetch data from the table in a streaming manner: \"brand_fulfillment_in_store_options\""
  brand_fulfillment_in_store_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_fulfillment_in_store_options_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_fulfillment_in_store_options_bool_exp
  ): [brand_fulfillment_in_store_options!]!
  "fetch data from the table: \"brand_fulfillment_in_store_settings\""
  brand_fulfillment_in_store_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_in_store_settings_bool_exp
  ): [brand_fulfillment_in_store_settings!]!
  "fetch data from the table: \"brand_fulfillment_in_store_settings\" using primary key columns"
  brand_fulfillment_in_store_settings_by_pk(id: uuid!): brand_fulfillment_in_store_settings
  "fetch data from the table in a streaming manner: \"brand_fulfillment_in_store_settings\""
  brand_fulfillment_in_store_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_fulfillment_in_store_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_fulfillment_in_store_settings_bool_exp
  ): [brand_fulfillment_in_store_settings!]!
  "fetch data from the table: \"brand_fulfillment_postal_options\""
  brand_fulfillment_postal_options(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_options_bool_exp
  ): [brand_fulfillment_postal_options!]!
  "fetch data from the table: \"brand_fulfillment_postal_options\" using primary key columns"
  brand_fulfillment_postal_options_by_pk(id: uuid!): brand_fulfillment_postal_options
  "fetch data from the table in a streaming manner: \"brand_fulfillment_postal_options\""
  brand_fulfillment_postal_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_fulfillment_postal_options_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_fulfillment_postal_options_bool_exp
  ): [brand_fulfillment_postal_options!]!
  "fetch data from the table: \"brand_fulfillment_postal_settings\""
  brand_fulfillment_postal_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_postal_settings_bool_exp
  ): [brand_fulfillment_postal_settings!]!
  "fetch data from the table: \"brand_fulfillment_postal_settings\" using primary key columns"
  brand_fulfillment_postal_settings_by_pk(id: uuid!): brand_fulfillment_postal_settings
  "fetch data from the table in a streaming manner: \"brand_fulfillment_postal_settings\""
  brand_fulfillment_postal_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_fulfillment_postal_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_fulfillment_postal_settings_bool_exp
  ): [brand_fulfillment_postal_settings!]!
  "fetch data from the table: \"brand_fulfillment_settings\""
  brand_fulfillment_settings(
    "distinct select on columns"
    distinct_on: [brand_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: brand_fulfillment_settings_bool_exp
  ): [brand_fulfillment_settings!]!
  "fetch data from the table: \"brand_fulfillment_settings\" using primary key columns"
  brand_fulfillment_settings_by_pk(id: uuid!): brand_fulfillment_settings
  "fetch data from the table in a streaming manner: \"brand_fulfillment_settings\""
  brand_fulfillment_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_fulfillment_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_fulfillment_settings_bool_exp
  ): [brand_fulfillment_settings!]!
  "fetch data from the table: \"brand_passwords\""
  brand_passwords(
    "distinct select on columns"
    distinct_on: [brand_passwords_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brand_passwords_order_by!],
    "filter the rows returned"
    where: brand_passwords_bool_exp
  ): [brand_passwords!]!
  "fetch data from the table: \"brand_passwords\" using primary key columns"
  brand_passwords_by_pk(brand_id: uuid!): brand_passwords
  "fetch data from the table in a streaming manner: \"brand_passwords\""
  brand_passwords_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brand_passwords_stream_cursor_input]!,
    "filter the rows returned"
    where: brand_passwords_bool_exp
  ): [brand_passwords!]!
  "fetch data from the table: \"brands\""
  brands(
    "distinct select on columns"
    distinct_on: [brands_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [brands_order_by!],
    "filter the rows returned"
    where: brands_bool_exp
  ): [brands!]!
  "fetch data from the table: \"brands\" using primary key columns"
  brands_by_pk(id: uuid!): brands
  "fetch data from the table in a streaming manner: \"brands\""
  brands_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [brands_stream_cursor_input]!,
    "filter the rows returned"
    where: brands_bool_exp
  ): [brands!]!
  "fetch data from the table: \"chat_channels\""
  chat_channels(
    "distinct select on columns"
    distinct_on: [chat_channels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [chat_channels_order_by!],
    "filter the rows returned"
    where: chat_channels_bool_exp
  ): [chat_channels!]!
  "fetch data from the table: \"chat_channels\" using primary key columns"
  chat_channels_by_pk(key: String!): chat_channels
  "fetch data from the table in a streaming manner: \"chat_channels\""
  chat_channels_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [chat_channels_stream_cursor_input]!,
    "filter the rows returned"
    where: chat_channels_bool_exp
  ): [chat_channels!]!
  "fetch data from the table: \"collapsed_product_results\""
  collapsed_product_results(
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "fetch aggregated fields from the table: \"collapsed_product_results\""
  collapsed_product_results_aggregate(
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "fetch data from the table in a streaming manner: \"collapsed_product_results\""
  collapsed_product_results_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [collapsed_product_results_stream_cursor_input]!,
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "fetch data from the table: \"collection_media_groups\""
  collection_media_groups(
    "distinct select on columns"
    distinct_on: [collection_media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collection_media_groups_order_by!],
    "filter the rows returned"
    where: collection_media_groups_bool_exp
  ): [collection_media_groups!]!
  "fetch data from the table: \"collection_media_groups\" using primary key columns"
  collection_media_groups_by_pk(collection_id: uuid!, media_group_id: uuid!): collection_media_groups
  "fetch data from the table in a streaming manner: \"collection_media_groups\""
  collection_media_groups_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [collection_media_groups_stream_cursor_input]!,
    "filter the rows returned"
    where: collection_media_groups_bool_exp
  ): [collection_media_groups!]!
  "fetch data from the table: \"collections\""
  collections(
    "distinct select on columns"
    distinct_on: [collections_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_order_by!],
    "filter the rows returned"
    where: collections_bool_exp
  ): [collections!]!
  "fetch data from the table: \"collections\" using primary key columns"
  collections_by_pk(id: uuid!): collections
  "fetch data from the table in a streaming manner: \"collections\""
  collections_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [collections_stream_cursor_input]!,
    "filter the rows returned"
    where: collections_bool_exp
  ): [collections!]!
  "fetch data from the table: \"collections_translations\""
  collections_translations(
    "distinct select on columns"
    distinct_on: [collections_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collections_translations_order_by!],
    "filter the rows returned"
    where: collections_translations_bool_exp
  ): [collections_translations!]!
  "fetch data from the table: \"collections_translations\" using primary key columns"
  collections_translations_by_pk(id: Int!): collections_translations
  "fetch data from the table in a streaming manner: \"collections_translations\""
  collections_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [collections_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: collections_translations_bool_exp
  ): [collections_translations!]!
  "An array relationship"
  condition_questions(
    "distinct select on columns"
    distinct_on: [condition_questions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_order_by!],
    "filter the rows returned"
    where: condition_questions_bool_exp
  ): [condition_questions!]!
  "fetch data from the table: \"condition_questions\" using primary key columns"
  condition_questions_by_pk(id: uuid!): condition_questions
  "fetch data from the table in a streaming manner: \"condition_questions\""
  condition_questions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [condition_questions_stream_cursor_input]!,
    "filter the rows returned"
    where: condition_questions_bool_exp
  ): [condition_questions!]!
  "fetch data from the table: \"condition_questions_translations\""
  condition_questions_translations(
    "distinct select on columns"
    distinct_on: [condition_questions_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_translations_order_by!],
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): [condition_questions_translations!]!
  "fetch aggregated fields from the table: \"condition_questions_translations\""
  condition_questions_translations_aggregate(
    "distinct select on columns"
    distinct_on: [condition_questions_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_questions_translations_order_by!],
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): condition_questions_translations_aggregate!
  "fetch data from the table: \"condition_questions_translations\" using primary key columns"
  condition_questions_translations_by_pk(id: Int!): condition_questions_translations
  "fetch data from the table in a streaming manner: \"condition_questions_translations\""
  condition_questions_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [condition_questions_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: condition_questions_translations_bool_exp
  ): [condition_questions_translations!]!
  "An array relationship"
  condition_responses(
    "distinct select on columns"
    distinct_on: [condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [condition_responses_order_by!],
    "filter the rows returned"
    where: condition_responses_bool_exp
  ): [condition_responses!]!
  "fetch data from the table: \"condition_responses\" using primary key columns"
  condition_responses_by_pk(id: uuid!): condition_responses
  "fetch data from the table in a streaming manner: \"condition_responses\""
  condition_responses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [condition_responses_stream_cursor_input]!,
    "filter the rows returned"
    where: condition_responses_bool_exp
  ): [condition_responses!]!
  "fetch data from the table: \"credit\""
  credit(
    "distinct select on columns"
    distinct_on: [credit_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [credit_order_by!],
    "filter the rows returned"
    where: credit_bool_exp
  ): [credit!]!
  "fetch data from the table: \"credit\" using primary key columns"
  credit_by_pk(id: uuid!): credit
  "fetch data from the table in a streaming manner: \"credit\""
  credit_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [credit_stream_cursor_input]!,
    "filter the rows returned"
    where: credit_bool_exp
  ): [credit!]!
  "fetch data from the table: \"dac7_verified_storefronts\""
  dac7_verified_storefronts(
    "distinct select on columns"
    distinct_on: [dac7_verified_storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [dac7_verified_storefronts_order_by!],
    "filter the rows returned"
    where: dac7_verified_storefronts_bool_exp
  ): [dac7_verified_storefronts!]!
  "fetch data from the table in a streaming manner: \"dac7_verified_storefronts\""
  dac7_verified_storefronts_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [dac7_verified_storefronts_stream_cursor_input]!,
    "filter the rows returned"
    where: dac7_verified_storefronts_bool_exp
  ): [dac7_verified_storefronts!]!
  "An array relationship"
  external_sku_ids(
    "distinct select on columns"
    distinct_on: [external_sku_ids_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [external_sku_ids_order_by!],
    "filter the rows returned"
    where: external_sku_ids_bool_exp
  ): [external_sku_ids!]!
  "fetch data from the table: \"external_sku_ids\" using primary key columns"
  external_sku_ids_by_pk(id: uuid!): external_sku_ids
  "fetch data from the table in a streaming manner: \"external_sku_ids\""
  external_sku_ids_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [external_sku_ids_stream_cursor_input]!,
    "filter the rows returned"
    where: external_sku_ids_bool_exp
  ): [external_sku_ids!]!
  "fetch data from the table: \"form_submissions\""
  form_submissions(
    "distinct select on columns"
    distinct_on: [form_submissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [form_submissions_order_by!],
    "filter the rows returned"
    where: form_submissions_bool_exp
  ): [form_submissions!]!
  "fetch aggregated fields from the table: \"form_submissions\""
  form_submissions_aggregate(
    "distinct select on columns"
    distinct_on: [form_submissions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [form_submissions_order_by!],
    "filter the rows returned"
    where: form_submissions_bool_exp
  ): form_submissions_aggregate!
  "fetch data from the table: \"form_submissions\" using primary key columns"
  form_submissions_by_pk(id: uuid!): form_submissions
  "fetch data from the table in a streaming manner: \"form_submissions\""
  form_submissions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [form_submissions_stream_cursor_input]!,
    "filter the rows returned"
    where: form_submissions_bool_exp
  ): [form_submissions!]!
  "fetch data from the table: \"forms\""
  forms(
    "distinct select on columns"
    distinct_on: [forms_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [forms_order_by!],
    "filter the rows returned"
    where: forms_bool_exp
  ): [forms!]!
  "fetch data from the table: \"forms\" using primary key columns"
  forms_by_pk(id: uuid!): forms
  "fetch data from the table in a streaming manner: \"forms\""
  forms_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [forms_stream_cursor_input]!,
    "filter the rows returned"
    where: forms_bool_exp
  ): [forms!]!
  "fetch data from the table: \"fulfillment_intents\""
  fulfillment_intents(
    "distinct select on columns"
    distinct_on: [fulfillment_intents_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillment_intents_order_by!],
    "filter the rows returned"
    where: fulfillment_intents_bool_exp
  ): [fulfillment_intents!]!
  "fetch data from the table: \"fulfillment_intents\" using primary key columns"
  fulfillment_intents_by_pk(id: uuid!): fulfillment_intents
  "fetch data from the table in a streaming manner: \"fulfillment_intents\""
  fulfillment_intents_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [fulfillment_intents_stream_cursor_input]!,
    "filter the rows returned"
    where: fulfillment_intents_bool_exp
  ): [fulfillment_intents!]!
  "fetch data from the table: \"fulfillment_services\""
  fulfillment_services(
    "distinct select on columns"
    distinct_on: [fulfillment_services_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillment_services_order_by!],
    "filter the rows returned"
    where: fulfillment_services_bool_exp
  ): [fulfillment_services!]!
  "fetch data from the table: \"fulfillment_services\" using primary key columns"
  fulfillment_services_by_pk(id: uuid!): fulfillment_services
  "fetch data from the table in a streaming manner: \"fulfillment_services\""
  fulfillment_services_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [fulfillment_services_stream_cursor_input]!,
    "filter the rows returned"
    where: fulfillment_services_bool_exp
  ): [fulfillment_services!]!
  "fetch data from the table: \"fulfillments\""
  fulfillments(
    "distinct select on columns"
    distinct_on: [fulfillments_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [fulfillments_order_by!],
    "filter the rows returned"
    where: fulfillments_bool_exp
  ): [fulfillments!]!
  "fetch data from the table: \"fulfillments\" using primary key columns"
  fulfillments_by_pk(id: uuid!): fulfillments
  "fetch data from the table in a streaming manner: \"fulfillments\""
  fulfillments_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [fulfillments_stream_cursor_input]!,
    "filter the rows returned"
    where: fulfillments_bool_exp
  ): [fulfillments!]!
  "An array relationship"
  gift_cards(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): [gift_cards!]!
  "An aggregate relationship"
  gift_cards_aggregate(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): gift_cards_aggregate!
  "fetch data from the table: \"gift_cards\" using primary key columns"
  gift_cards_by_pk(id: uuid!): gift_cards
  "fetch data from the table in a streaming manner: \"gift_cards\""
  gift_cards_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [gift_cards_stream_cursor_input]!,
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): [gift_cards!]!
  "fetch data from the table: \"images\""
  images(
    "distinct select on columns"
    distinct_on: [images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [images_order_by!],
    "filter the rows returned"
    where: images_bool_exp
  ): [images!]!
  "fetch data from the table: \"images\" using primary key columns"
  images_by_pk(id: uuid!): images
  "fetch data from the table in a streaming manner: \"images\""
  images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [images_stream_cursor_input]!,
    "filter the rows returned"
    where: images_bool_exp
  ): [images!]!
  "An array relationship"
  in_store_pickups(
    "distinct select on columns"
    distinct_on: [in_store_pickups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [in_store_pickups_order_by!],
    "filter the rows returned"
    where: in_store_pickups_bool_exp
  ): [in_store_pickups!]!
  "fetch data from the table: \"in_store_pickups\" using primary key columns"
  in_store_pickups_by_pk(id: uuid!): in_store_pickups
  "fetch data from the table in a streaming manner: \"in_store_pickups\""
  in_store_pickups_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [in_store_pickups_stream_cursor_input]!,
    "filter the rows returned"
    where: in_store_pickups_bool_exp
  ): [in_store_pickups!]!
  "fetch data from the table: \"listing_auto_price_reduce\""
  listing_auto_price_reduce(
    "distinct select on columns"
    distinct_on: [listing_auto_price_reduce_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_auto_price_reduce_order_by!],
    "filter the rows returned"
    where: listing_auto_price_reduce_bool_exp
  ): [listing_auto_price_reduce!]!
  "fetch data from the table: \"listing_auto_price_reduce\" using primary key columns"
  listing_auto_price_reduce_by_pk(id: uuid!): listing_auto_price_reduce
  "fetch data from the table in a streaming manner: \"listing_auto_price_reduce\""
  listing_auto_price_reduce_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_auto_price_reduce_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_auto_price_reduce_bool_exp
  ): [listing_auto_price_reduce!]!
  "fetch data from the table: \"listing_channels\""
  listing_channels(
    "distinct select on columns"
    distinct_on: [listing_channels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_channels_order_by!],
    "filter the rows returned"
    where: listing_channels_bool_exp
  ): [listing_channels!]!
  "fetch data from the table: \"listing_channels\" using primary key columns"
  listing_channels_by_pk(id: uuid!): listing_channels
  "fetch data from the table in a streaming manner: \"listing_channels\""
  listing_channels_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_channels_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_channels_bool_exp
  ): [listing_channels!]!
  "fetch data from the table: \"listing_event_types\""
  listing_event_types(
    "distinct select on columns"
    distinct_on: [listing_event_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_event_types_order_by!],
    "filter the rows returned"
    where: listing_event_types_bool_exp
  ): [listing_event_types!]!
  "fetch data from the table: \"listing_event_types\" using primary key columns"
  listing_event_types_by_pk(type: String!): listing_event_types
  "fetch data from the table in a streaming manner: \"listing_event_types\""
  listing_event_types_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_event_types_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_event_types_bool_exp
  ): [listing_event_types!]!
  "fetch data from the table: \"listing_events\""
  listing_events(
    "distinct select on columns"
    distinct_on: [listing_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_events_order_by!],
    "filter the rows returned"
    where: listing_events_bool_exp
  ): [listing_events!]!
  "fetch data from the table: \"listing_events\" using primary key columns"
  listing_events_by_pk(id: uuid!): listing_events
  "fetch data from the table in a streaming manner: \"listing_events\""
  listing_events_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_events_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_events_bool_exp
  ): [listing_events!]!
  "fetch data from the table: \"listing_images\""
  listing_images(
    "distinct select on columns"
    distinct_on: [listing_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_images_order_by!],
    "filter the rows returned"
    where: listing_images_bool_exp
  ): [listing_images!]!
  "fetch data from the table: \"listing_images\" using primary key columns"
  listing_images_by_pk(id: uuid!): listing_images
  "fetch data from the table in a streaming manner: \"listing_images\""
  listing_images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_images_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_images_bool_exp
  ): [listing_images!]!
  "An array relationship"
  listing_metadata(
    "distinct select on columns"
    distinct_on: [listing_metadata_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_metadata_order_by!],
    "filter the rows returned"
    where: listing_metadata_bool_exp
  ): [listing_metadata!]!
  "fetch data from the table: \"listing_metadata\" using primary key columns"
  listing_metadata_by_pk(id: uuid!): listing_metadata
  "fetch data from the table in a streaming manner: \"listing_metadata\""
  listing_metadata_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_metadata_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_metadata_bool_exp
  ): [listing_metadata!]!
  "fetch data from the table: \"listing_platforms\""
  listing_platforms(
    "distinct select on columns"
    distinct_on: [listing_platforms_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_platforms_order_by!],
    "filter the rows returned"
    where: listing_platforms_bool_exp
  ): [listing_platforms!]!
  "fetch data from the table: \"listing_platforms\" using primary key columns"
  listing_platforms_by_pk(id: uuid!): listing_platforms
  "fetch data from the table in a streaming manner: \"listing_platforms\""
  listing_platforms_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_platforms_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_platforms_bool_exp
  ): [listing_platforms!]!
  "fetch data from the table: \"listing_relistings\""
  listing_relistings(
    "distinct select on columns"
    distinct_on: [listing_relistings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_relistings_order_by!],
    "filter the rows returned"
    where: listing_relistings_bool_exp
  ): [listing_relistings!]!
  "fetch data from the table: \"listing_relistings\" using primary key columns"
  listing_relistings_by_pk(new_listing_id: uuid!, previous_listing_id: uuid!): listing_relistings
  "fetch data from the table in a streaming manner: \"listing_relistings\""
  listing_relistings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_relistings_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_relistings_bool_exp
  ): [listing_relistings!]!
  "fetch data from the table: \"listing_statuses\""
  listing_statuses(
    "distinct select on columns"
    distinct_on: [listing_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_statuses_order_by!],
    "filter the rows returned"
    where: listing_statuses_bool_exp
  ): [listing_statuses!]!
  "fetch data from the table: \"listing_statuses\" using primary key columns"
  listing_statuses_by_pk(status: String!): listing_statuses
  "fetch data from the table in a streaming manner: \"listing_statuses\""
  listing_statuses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_statuses_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_statuses_bool_exp
  ): [listing_statuses!]!
  "fetch data from the table: \"listing_user_action_timestamp\""
  listing_user_action_timestamp(
    "distinct select on columns"
    distinct_on: [listing_user_action_timestamp_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listing_user_action_timestamp_order_by!],
    "filter the rows returned"
    where: listing_user_action_timestamp_bool_exp
  ): [listing_user_action_timestamp!]!
  "fetch data from the table: \"listing_user_action_timestamp\" using primary key columns"
  listing_user_action_timestamp_by_pk(id: uuid!): listing_user_action_timestamp
  "fetch data from the table in a streaming manner: \"listing_user_action_timestamp\""
  listing_user_action_timestamp_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listing_user_action_timestamp_stream_cursor_input]!,
    "filter the rows returned"
    where: listing_user_action_timestamp_bool_exp
  ): [listing_user_action_timestamp!]!
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  "fetch data from the table: \"listings\" using primary key columns"
  listings_by_pk(id: uuid!): listings
  "fetch data from the table in a streaming manner: \"listings\""
  listings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [listings_stream_cursor_input]!,
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An array relationship"
  mail_takebacks(
    "distinct select on columns"
    distinct_on: [mail_takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mail_takebacks_order_by!],
    "filter the rows returned"
    where: mail_takebacks_bool_exp
  ): [mail_takebacks!]!
  "fetch data from the table: \"mail_takebacks\" using primary key columns"
  mail_takebacks_by_pk(id: uuid!): mail_takebacks
  "fetch data from the table in a streaming manner: \"mail_takebacks\""
  mail_takebacks_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [mail_takebacks_stream_cursor_input]!,
    "filter the rows returned"
    where: mail_takebacks_bool_exp
  ): [mail_takebacks!]!
  "fetch data from the table: \"media_group_items\""
  media_group_items(
    "distinct select on columns"
    distinct_on: [media_group_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [media_group_items_order_by!],
    "filter the rows returned"
    where: media_group_items_bool_exp
  ): [media_group_items!]!
  "fetch data from the table: \"media_group_items\" using primary key columns"
  media_group_items_by_pk(id: uuid!): media_group_items
  "fetch data from the table in a streaming manner: \"media_group_items\""
  media_group_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [media_group_items_stream_cursor_input]!,
    "filter the rows returned"
    where: media_group_items_bool_exp
  ): [media_group_items!]!
  "fetch data from the table: \"media_groups\""
  media_groups(
    "distinct select on columns"
    distinct_on: [media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [media_groups_order_by!],
    "filter the rows returned"
    where: media_groups_bool_exp
  ): [media_groups!]!
  "fetch data from the table: \"media_groups\" using primary key columns"
  media_groups_by_pk(id: uuid!): media_groups
  "fetch data from the table in a streaming manner: \"media_groups\""
  media_groups_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [media_groups_stream_cursor_input]!,
    "filter the rows returned"
    where: media_groups_bool_exp
  ): [media_groups!]!
  "fetch data from the table: \"mobile_uploads\""
  mobile_uploads(
    "distinct select on columns"
    distinct_on: [mobile_uploads_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mobile_uploads_order_by!],
    "filter the rows returned"
    where: mobile_uploads_bool_exp
  ): [mobile_uploads!]!
  "fetch data from the table: \"mobile_uploads\" using primary key columns"
  mobile_uploads_by_pk(id: uuid!): mobile_uploads
  "fetch data from the table in a streaming manner: \"mobile_uploads\""
  mobile_uploads_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [mobile_uploads_stream_cursor_input]!,
    "filter the rows returned"
    where: mobile_uploads_bool_exp
  ): [mobile_uploads!]!
  "fetch data from the table: \"order_addresses\""
  order_addresses(
    "distinct select on columns"
    distinct_on: [order_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_addresses_order_by!],
    "filter the rows returned"
    where: order_addresses_bool_exp
  ): [order_addresses!]!
  "fetch data from the table: \"order_addresses\" using primary key columns"
  order_addresses_by_pk(id: uuid!): order_addresses
  "fetch data from the table in a streaming manner: \"order_addresses\""
  order_addresses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [order_addresses_stream_cursor_input]!,
    "filter the rows returned"
    where: order_addresses_bool_exp
  ): [order_addresses!]!
  "fetch data from the table: \"order_intent_items\""
  order_intent_items(
    "distinct select on columns"
    distinct_on: [order_intent_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_intent_items_order_by!],
    "filter the rows returned"
    where: order_intent_items_bool_exp
  ): [order_intent_items!]!
  "fetch data from the table: \"order_intent_items\" using primary key columns"
  order_intent_items_by_pk(id: uuid!): order_intent_items
  "fetch data from the table in a streaming manner: \"order_intent_items\""
  order_intent_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [order_intent_items_stream_cursor_input]!,
    "filter the rows returned"
    where: order_intent_items_bool_exp
  ): [order_intent_items!]!
  "fetch data from the table: \"order_intents\""
  order_intents(
    "distinct select on columns"
    distinct_on: [order_intents_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_intents_order_by!],
    "filter the rows returned"
    where: order_intents_bool_exp
  ): [order_intents!]!
  "fetch data from the table: \"order_intents\" using primary key columns"
  order_intents_by_pk(id: uuid!): order_intents
  "fetch data from the table in a streaming manner: \"order_intents\""
  order_intents_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [order_intents_stream_cursor_input]!,
    "filter the rows returned"
    where: order_intents_bool_exp
  ): [order_intents!]!
  "An array relationship"
  order_items(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "An aggregate relationship"
  order_items_aggregate(
    "distinct select on columns"
    distinct_on: [order_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_items_order_by!],
    "filter the rows returned"
    where: order_items_bool_exp
  ): order_items_aggregate!
  "fetch data from the table: \"order_items\" using primary key columns"
  order_items_by_pk(id: uuid!): order_items
  "fetch data from the table in a streaming manner: \"order_items\""
  order_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [order_items_stream_cursor_input]!,
    "filter the rows returned"
    where: order_items_bool_exp
  ): [order_items!]!
  "fetch data from the table: \"order_statuses\""
  order_statuses(
    "distinct select on columns"
    distinct_on: [order_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [order_statuses_order_by!],
    "filter the rows returned"
    where: order_statuses_bool_exp
  ): [order_statuses!]!
  "fetch data from the table: \"order_statuses\" using primary key columns"
  order_statuses_by_pk(status: String!): order_statuses
  "fetch data from the table in a streaming manner: \"order_statuses\""
  order_statuses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [order_statuses_stream_cursor_input]!,
    "filter the rows returned"
    where: order_statuses_bool_exp
  ): [order_statuses!]!
  "An array relationship"
  orders(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): [orders!]!
  "An aggregate relationship"
  orders_aggregate(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): orders_aggregate!
  "fetch data from the table: \"orders\" using primary key columns"
  orders_by_pk(id: uuid!): orders
  "fetch data from the table in a streaming manner: \"orders\""
  orders_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [orders_stream_cursor_input]!,
    "filter the rows returned"
    where: orders_bool_exp
  ): [orders!]!
  "fetch data from the table: \"orphan_condition_responses\""
  orphan_condition_responses(
    "distinct select on columns"
    distinct_on: [orphan_condition_responses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_condition_responses_order_by!],
    "filter the rows returned"
    where: orphan_condition_responses_bool_exp
  ): [orphan_condition_responses!]!
  "fetch data from the table: \"orphan_condition_responses\" using primary key columns"
  orphan_condition_responses_by_pk(id: uuid!): orphan_condition_responses
  "fetch data from the table in a streaming manner: \"orphan_condition_responses\""
  orphan_condition_responses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [orphan_condition_responses_stream_cursor_input]!,
    "filter the rows returned"
    where: orphan_condition_responses_bool_exp
  ): [orphan_condition_responses!]!
  "fetch data from the table: \"orphan_listings\""
  orphan_listings(
    "distinct select on columns"
    distinct_on: [orphan_listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_order_by!],
    "filter the rows returned"
    where: orphan_listings_bool_exp
  ): [orphan_listings!]!
  "fetch aggregated fields from the table: \"orphan_listings\""
  orphan_listings_aggregate(
    "distinct select on columns"
    distinct_on: [orphan_listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_order_by!],
    "filter the rows returned"
    where: orphan_listings_bool_exp
  ): orphan_listings_aggregate!
  "fetch data from the table: \"orphan_listings\" using primary key columns"
  orphan_listings_by_pk(id: uuid!): orphan_listings
  "fetch data from the table: \"orphan_listings_images\""
  orphan_listings_images(
    "distinct select on columns"
    distinct_on: [orphan_listings_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orphan_listings_images_order_by!],
    "filter the rows returned"
    where: orphan_listings_images_bool_exp
  ): [orphan_listings_images!]!
  "fetch data from the table: \"orphan_listings_images\" using primary key columns"
  orphan_listings_images_by_pk(id: uuid!): orphan_listings_images
  "fetch data from the table in a streaming manner: \"orphan_listings_images\""
  orphan_listings_images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [orphan_listings_images_stream_cursor_input]!,
    "filter the rows returned"
    where: orphan_listings_images_bool_exp
  ): [orphan_listings_images!]!
  "fetch data from the table in a streaming manner: \"orphan_listings\""
  orphan_listings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [orphan_listings_stream_cursor_input]!,
    "filter the rows returned"
    where: orphan_listings_bool_exp
  ): [orphan_listings!]!
  "An array relationship"
  photo_enhancement_requests(
    "distinct select on columns"
    distinct_on: [photo_enhancement_requests_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [photo_enhancement_requests_order_by!],
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  "fetch data from the table: \"photo_enhancement_requests\" using primary key columns"
  photo_enhancement_requests_by_pk(id: uuid!): photo_enhancement_requests
  "fetch data from the table in a streaming manner: \"photo_enhancement_requests\""
  photo_enhancement_requests_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [photo_enhancement_requests_stream_cursor_input]!,
    "filter the rows returned"
    where: photo_enhancement_requests_bool_exp
  ): [photo_enhancement_requests!]!
  "An array relationship"
  pos_stations(
    "distinct select on columns"
    distinct_on: [pos_stations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [pos_stations_order_by!],
    "filter the rows returned"
    where: pos_stations_bool_exp
  ): [pos_stations!]!
  "fetch data from the table: \"pos_stations\" using primary key columns"
  pos_stations_by_pk(id: uuid!): pos_stations
  "fetch data from the table in a streaming manner: \"pos_stations\""
  pos_stations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [pos_stations_stream_cursor_input]!,
    "filter the rows returned"
    where: pos_stations_bool_exp
  ): [pos_stations!]!
  "fetch data from the table: \"postal_options\""
  postal_options(
    "distinct select on columns"
    distinct_on: [postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [postal_options_order_by!],
    "filter the rows returned"
    where: postal_options_bool_exp
  ): [postal_options!]!
  "fetch data from the table: \"postal_options\" using primary key columns"
  postal_options_by_pk(id: uuid!): postal_options
  "fetch data from the table in a streaming manner: \"postal_options\""
  postal_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [postal_options_stream_cursor_input]!,
    "filter the rows returned"
    where: postal_options_bool_exp
  ): [postal_options!]!
  "An array relationship"
  product_attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_attribute_type_options_bool_exp
  ): [product_attribute_type_options!]!
  "fetch data from the table: \"product_attribute_type_options\" using primary key columns"
  product_attribute_type_options_by_pk(id: uuid!): product_attribute_type_options
  "fetch data from the table in a streaming manner: \"product_attribute_type_options\""
  product_attribute_type_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_attribute_type_options_stream_cursor_input]!,
    "filter the rows returned"
    where: product_attribute_type_options_bool_exp
  ): [product_attribute_type_options!]!
  "An array relationship"
  product_colors(
    "distinct select on columns"
    distinct_on: [product_colors_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_order_by!],
    "filter the rows returned"
    where: product_colors_bool_exp
  ): [product_colors!]!
  "fetch data from the table: \"product_colors\" using primary key columns"
  product_colors_by_pk(id: uuid!): product_colors
  "fetch data from the table in a streaming manner: \"product_colors\""
  product_colors_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_colors_stream_cursor_input]!,
    "filter the rows returned"
    where: product_colors_bool_exp
  ): [product_colors!]!
  "An array relationship"
  product_colors_translations(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): [product_colors_translations!]!
  "An aggregate relationship"
  product_colors_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_colors_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_colors_translations_order_by!],
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): product_colors_translations_aggregate!
  "fetch data from the table: \"product_colors_translations\" using primary key columns"
  product_colors_translations_by_pk(id: Int!): product_colors_translations
  "fetch data from the table in a streaming manner: \"product_colors_translations\""
  product_colors_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_colors_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: product_colors_translations_bool_exp
  ): [product_colors_translations!]!
  "fetch data from the table: \"product_images\""
  product_images(
    "distinct select on columns"
    distinct_on: [product_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_order_by!],
    "filter the rows returned"
    where: product_images_bool_exp
  ): [product_images!]!
  "fetch data from the table: \"product_images\" using primary key columns"
  product_images_by_pk(id: uuid!): product_images
  "fetch data from the table in a streaming manner: \"product_images\""
  product_images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_images_stream_cursor_input]!,
    "filter the rows returned"
    where: product_images_bool_exp
  ): [product_images!]!
  "An array relationship"
  product_images_translations(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): [product_images_translations!]!
  "An aggregate relationship"
  product_images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_images_translations_order_by!],
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): product_images_translations_aggregate!
  "fetch data from the table: \"product_images_translations\" using primary key columns"
  product_images_translations_by_pk(id: Int!): product_images_translations
  "fetch data from the table in a streaming manner: \"product_images_translations\""
  product_images_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_images_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: product_images_translations_bool_exp
  ): [product_images_translations!]!
  "fetch data from the table: \"product_style_attribute_type_options\""
  product_style_attribute_type_options(
    "distinct select on columns"
    distinct_on: [product_style_attribute_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_attribute_type_options_order_by!],
    "filter the rows returned"
    where: product_style_attribute_type_options_bool_exp
  ): [product_style_attribute_type_options!]!
  "fetch data from the table: \"product_style_attribute_type_options\" using primary key columns"
  product_style_attribute_type_options_by_pk(id: uuid!): product_style_attribute_type_options
  "fetch data from the table in a streaming manner: \"product_style_attribute_type_options\""
  product_style_attribute_type_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_style_attribute_type_options_stream_cursor_input]!,
    "filter the rows returned"
    where: product_style_attribute_type_options_bool_exp
  ): [product_style_attribute_type_options!]!
  "fetch data from the table: \"product_style_variant_media_groups\""
  product_style_variant_media_groups(
    "distinct select on columns"
    distinct_on: [product_style_variant_media_groups_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_media_groups_order_by!],
    "filter the rows returned"
    where: product_style_variant_media_groups_bool_exp
  ): [product_style_variant_media_groups!]!
  "fetch data from the table: \"product_style_variant_media_groups\" using primary key columns"
  product_style_variant_media_groups_by_pk(media_group_id: uuid!, product_style_variant_id: uuid!): product_style_variant_media_groups
  "fetch data from the table in a streaming manner: \"product_style_variant_media_groups\""
  product_style_variant_media_groups_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_style_variant_media_groups_stream_cursor_input]!,
    "filter the rows returned"
    where: product_style_variant_media_groups_bool_exp
  ): [product_style_variant_media_groups!]!
  "An array relationship"
  product_style_variant_options(
    "distinct select on columns"
    distinct_on: [product_style_variant_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variant_options_order_by!],
    "filter the rows returned"
    where: product_style_variant_options_bool_exp
  ): [product_style_variant_options!]!
  "fetch data from the table: \"product_style_variant_options\" using primary key columns"
  product_style_variant_options_by_pk(product_style_variant_id: uuid!, variant_type_id: uuid!): product_style_variant_options
  "fetch data from the table in a streaming manner: \"product_style_variant_options\""
  product_style_variant_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_style_variant_options_stream_cursor_input]!,
    "filter the rows returned"
    where: product_style_variant_options_bool_exp
  ): [product_style_variant_options!]!
  "An array relationship"
  product_style_variants(
    "distinct select on columns"
    distinct_on: [product_style_variants_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_style_variants_order_by!],
    "filter the rows returned"
    where: product_style_variants_bool_exp
  ): [product_style_variants!]!
  "fetch data from the table: \"product_style_variants\" using primary key columns"
  product_style_variants_by_pk(id: uuid!): product_style_variants
  "fetch data from the table in a streaming manner: \"product_style_variants\""
  product_style_variants_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_style_variants_stream_cursor_input]!,
    "filter the rows returned"
    where: product_style_variants_bool_exp
  ): [product_style_variants!]!
  "fetch data from the table: \"product_styles\""
  product_styles(
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): [product_styles!]!
  "fetch aggregated fields from the table: \"product_styles\""
  product_styles_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): product_styles_aggregate!
  "fetch data from the table: \"product_styles\" using primary key columns"
  product_styles_by_pk(id: uuid!): product_styles
  "fetch data from the table: \"product_styles_listed\""
  product_styles_listed(
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "fetch aggregated fields from the table: \"product_styles_listed\""
  product_styles_listed_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "fetch data from the table: \"product_styles_listed\" using primary key columns"
  product_styles_listed_by_pk(product_style_id: uuid!): product_styles_listed
  "fetch data from the table in a streaming manner: \"product_styles_listed\""
  product_styles_listed_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_styles_listed_stream_cursor_input]!,
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "fetch data from the table in a streaming manner: \"product_styles\""
  product_styles_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_styles_stream_cursor_input]!,
    "filter the rows returned"
    where: product_styles_bool_exp
  ): [product_styles!]!
  "An array relationship"
  product_styles_translations(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): [product_styles_translations!]!
  "An aggregate relationship"
  product_styles_translations_aggregate(
    "distinct select on columns"
    distinct_on: [product_styles_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_translations_order_by!],
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): product_styles_translations_aggregate!
  "fetch data from the table: \"product_styles_translations\" using primary key columns"
  product_styles_translations_by_pk(id: Int!): product_styles_translations
  "fetch data from the table in a streaming manner: \"product_styles_translations\""
  product_styles_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_styles_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: product_styles_translations_bool_exp
  ): [product_styles_translations!]!
  "An array relationship"
  product_tags(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): [product_tags!]!
  "An aggregate relationship"
  product_tags_aggregate(
    "distinct select on columns"
    distinct_on: [product_tags_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_tags_order_by!],
    "filter the rows returned"
    where: product_tags_bool_exp
  ): product_tags_aggregate!
  "fetch data from the table: \"product_tags\" using primary key columns"
  product_tags_by_pk(id: uuid!): product_tags
  "fetch data from the table in a streaming manner: \"product_tags\""
  product_tags_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [product_tags_stream_cursor_input]!,
    "filter the rows returned"
    where: product_tags_bool_exp
  ): [product_tags!]!
  "An array relationship"
  products(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An aggregate relationship"
  products_aggregate(
    "distinct select on columns"
    distinct_on: [products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_order_by!],
    "filter the rows returned"
    where: products_bool_exp
  ): products_aggregate!
  "fetch data from the table: \"products\" using primary key columns"
  products_by_pk(id: uuid!): products
  "fetch data from the table in a streaming manner: \"products\""
  products_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [products_stream_cursor_input]!,
    "filter the rows returned"
    where: products_bool_exp
  ): [products!]!
  "An array relationship"
  products_translations(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): [products_translations!]!
  "An aggregate relationship"
  products_translations_aggregate(
    "distinct select on columns"
    distinct_on: [products_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [products_translations_order_by!],
    "filter the rows returned"
    where: products_translations_bool_exp
  ): products_translations_aggregate!
  "fetch data from the table: \"products_translations\" using primary key columns"
  products_translations_by_pk(id: Int!): products_translations
  "fetch data from the table in a streaming manner: \"products_translations\""
  products_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [products_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: products_translations_bool_exp
  ): [products_translations!]!
  "fetch data from the table: \"question_sets\""
  question_sets(
    "distinct select on columns"
    distinct_on: [question_sets_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [question_sets_order_by!],
    "filter the rows returned"
    where: question_sets_bool_exp
  ): [question_sets!]!
  "fetch data from the table: \"question_sets\" using primary key columns"
  question_sets_by_pk(id: uuid!): question_sets
  "fetch data from the table in a streaming manner: \"question_sets\""
  question_sets_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [question_sets_stream_cursor_input]!,
    "filter the rows returned"
    where: question_sets_bool_exp
  ): [question_sets!]!
  "fetch data from the table: \"retail_associates\""
  retail_associates(
    "distinct select on columns"
    distinct_on: [retail_associates_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_associates_order_by!],
    "filter the rows returned"
    where: retail_associates_bool_exp
  ): [retail_associates!]!
  "fetch data from the table: \"retail_associates\" using primary key columns"
  retail_associates_by_pk(id: uuid!): retail_associates
  "fetch data from the table in a streaming manner: \"retail_associates\""
  retail_associates_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [retail_associates_stream_cursor_input]!,
    "filter the rows returned"
    where: retail_associates_bool_exp
  ): [retail_associates!]!
  "fetch data from the table: \"retail_store_addresses\""
  retail_store_addresses(
    "distinct select on columns"
    distinct_on: [retail_store_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_store_addresses_order_by!],
    "filter the rows returned"
    where: retail_store_addresses_bool_exp
  ): [retail_store_addresses!]!
  "fetch data from the table in a streaming manner: \"retail_store_addresses\""
  retail_store_addresses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [retail_store_addresses_stream_cursor_input]!,
    "filter the rows returned"
    where: retail_store_addresses_bool_exp
  ): [retail_store_addresses!]!
  "fetch data from the table: \"retail_store_brand_uses\""
  retail_store_brand_uses(
    "distinct select on columns"
    distinct_on: [retail_store_brand_uses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_store_brand_uses_order_by!],
    "filter the rows returned"
    where: retail_store_brand_uses_bool_exp
  ): [retail_store_brand_uses!]!
  "fetch data from the table: \"retail_store_brand_uses\" using primary key columns"
  retail_store_brand_uses_by_pk(brand_id: uuid!, retail_store_id: uuid!, use_case: retail_store_use_cases_enum!): retail_store_brand_uses
  "fetch data from the table in a streaming manner: \"retail_store_brand_uses\""
  retail_store_brand_uses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [retail_store_brand_uses_stream_cursor_input]!,
    "filter the rows returned"
    where: retail_store_brand_uses_bool_exp
  ): [retail_store_brand_uses!]!
  "fetch data from the table: \"retail_stores\""
  retail_stores(
    "distinct select on columns"
    distinct_on: [retail_stores_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_order_by!],
    "filter the rows returned"
    where: retail_stores_bool_exp
  ): [retail_stores!]!
  "fetch data from the table: \"retail_stores\" using primary key columns"
  retail_stores_by_pk(id: uuid!): retail_stores
  "fetch data from the table in a streaming manner: \"retail_stores\""
  retail_stores_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [retail_stores_stream_cursor_input]!,
    "filter the rows returned"
    where: retail_stores_bool_exp
  ): [retail_stores!]!
  "fetch data from the table: \"retail_stores_translations\""
  retail_stores_translations(
    "distinct select on columns"
    distinct_on: [retail_stores_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [retail_stores_translations_order_by!],
    "filter the rows returned"
    where: retail_stores_translations_bool_exp
  ): [retail_stores_translations!]!
  "fetch data from the table: \"retail_stores_translations\" using primary key columns"
  retail_stores_translations_by_pk(id: Int!): retail_stores_translations
  "fetch data from the table in a streaming manner: \"retail_stores_translations\""
  retail_stores_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [retail_stores_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: retail_stores_translations_bool_exp
  ): [retail_stores_translations!]!
  "An array relationship"
  return_items(
    "distinct select on columns"
    distinct_on: [return_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [return_items_order_by!],
    "filter the rows returned"
    where: return_items_bool_exp
  ): [return_items!]!
  "fetch data from the table: \"return_items\" using primary key columns"
  return_items_by_pk(id: uuid!): return_items
  "fetch data from the table in a streaming manner: \"return_items\""
  return_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [return_items_stream_cursor_input]!,
    "filter the rows returned"
    where: return_items_bool_exp
  ): [return_items!]!
  "fetch data from the table: \"returns\""
  returns(
    "distinct select on columns"
    distinct_on: [returns_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [returns_order_by!],
    "filter the rows returned"
    where: returns_bool_exp
  ): [returns!]!
  "fetch data from the table: \"returns\" using primary key columns"
  returns_by_pk(id: uuid!): returns
  "fetch data from the table in a streaming manner: \"returns\""
  returns_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [returns_stream_cursor_input]!,
    "filter the rows returned"
    where: returns_bool_exp
  ): [returns!]!
  "fetch data from the table: \"roles\""
  roles(
    "distinct select on columns"
    distinct_on: [roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [roles_order_by!],
    "filter the rows returned"
    where: roles_bool_exp
  ): [roles!]!
  "fetch data from the table: \"roles\" using primary key columns"
  roles_by_pk(role: String!): roles
  "fetch data from the table in a streaming manner: \"roles\""
  roles_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [roles_stream_cursor_input]!,
    "filter the rows returned"
    where: roles_bool_exp
  ): [roles!]!
  "execute function \"search_listings\" which returns \"unique_listings_results\""
  search_listings(
    "input parameters for function \"search_listings\""
    args: search_listings_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "execute function \"search_listings_31pl\" which returns \"unique_listings_results_tnf\""
  search_listings_31pl(
    "input parameters for function \"search_listings_31pl\""
    args: search_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"search_listings_31pl\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  search_listings_31pl_aggregate(
    "input parameters for function \"search_listings_31pl_aggregate\""
    args: search_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "execute function \"search_listings\" and query aggregates on result of table type \"unique_listings_results\""
  search_listings_aggregate(
    "input parameters for function \"search_listings_aggregate\""
    args: search_listings_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "execute function \"search_listings_tnf\" which returns \"unique_listings_results_tnf\""
  search_listings_tnf(
    "input parameters for function \"search_listings_tnf\""
    args: search_listings_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"search_listings_tnf\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  search_listings_tnf_aggregate(
    "input parameters for function \"search_listings_tnf_aggregate\""
    args: search_listings_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "An array relationship"
  search_page_translations(
    "distinct select on columns"
    distinct_on: [search_page_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_page_translations_order_by!],
    "filter the rows returned"
    where: search_page_translations_bool_exp
  ): [search_page_translations!]!
  "fetch data from the table: \"search_page_translations\" using primary key columns"
  search_page_translations_by_pk(id: Int!): search_page_translations
  "fetch data from the table in a streaming manner: \"search_page_translations\""
  search_page_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [search_page_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: search_page_translations_bool_exp
  ): [search_page_translations!]!
  "fetch data from the table: \"search_pages\""
  search_pages(
    "distinct select on columns"
    distinct_on: [search_pages_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [search_pages_order_by!],
    "filter the rows returned"
    where: search_pages_bool_exp
  ): [search_pages!]!
  "fetch data from the table: \"search_pages\" using primary key columns"
  search_pages_by_pk(id: uuid!): search_pages
  "fetch data from the table in a streaming manner: \"search_pages\""
  search_pages_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [search_pages_stream_cursor_input]!,
    "filter the rows returned"
    where: search_pages_bool_exp
  ): [search_pages!]!
  "execute function \"search_products\" which returns \"searchable_products_results\""
  search_products(
    "input parameters for function \"search_products\""
    args: search_products_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "execute function \"search_products\" and query aggregates on result of table type \"searchable_products_results\""
  search_products_aggregate(
    "input parameters for function \"search_products_aggregate\""
    args: search_products_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "execute function \"search_products_by_sku\" which returns \"searchable_products_results\""
  search_products_by_sku(
    "input parameters for function \"search_products_by_sku\""
    args: search_products_by_sku_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "execute function \"search_products_by_sku\" and query aggregates on result of table type \"searchable_products_results\""
  search_products_by_sku_aggregate(
    "input parameters for function \"search_products_by_sku_aggregate\""
    args: search_products_by_sku_args!,
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "execute function \"search_products_by_sku_collapsed\" which returns \"collapsed_product_results\""
  search_products_by_sku_collapsed(
    "input parameters for function \"search_products_by_sku_collapsed\""
    args: search_products_by_sku_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "execute function \"search_products_by_sku_collapsed\" and query aggregates on result of table type \"collapsed_product_results\""
  search_products_by_sku_collapsed_aggregate(
    "input parameters for function \"search_products_by_sku_collapsed_aggregate\""
    args: search_products_by_sku_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "execute function \"search_products_collapsed\" which returns \"collapsed_product_results\""
  search_products_collapsed(
    "input parameters for function \"search_products_collapsed\""
    args: search_products_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): [collapsed_product_results!]!
  "execute function \"search_products_collapsed\" and query aggregates on result of table type \"collapsed_product_results\""
  search_products_collapsed_aggregate(
    "input parameters for function \"search_products_collapsed_aggregate\""
    args: search_products_collapsed_args!,
    "distinct select on columns"
    distinct_on: [collapsed_product_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [collapsed_product_results_order_by!],
    "filter the rows returned"
    where: collapsed_product_results_bool_exp
  ): collapsed_product_results_aggregate!
  "execute function \"search_styles\" which returns \"product_styles\""
  search_styles(
    "input parameters for function \"search_styles\""
    args: search_styles_args!,
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): [product_styles!]!
  "execute function \"search_styles\" and query aggregates on result of table type \"product_styles\""
  search_styles_aggregate(
    "input parameters for function \"search_styles_aggregate\""
    args: search_styles_args!,
    "distinct select on columns"
    distinct_on: [product_styles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_order_by!],
    "filter the rows returned"
    where: product_styles_bool_exp
  ): product_styles_aggregate!
  "execute function \"search_unique_listed_product_styles_tnf\" which returns \"product_styles_listed\""
  search_unique_listed_product_styles_tnf(
    "input parameters for function \"search_unique_listed_product_styles_tnf\""
    args: search_unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "execute function \"search_unique_listed_product_styles_tnf\" and query aggregates on result of table type \"product_styles_listed\""
  search_unique_listed_product_styles_tnf_aggregate(
    "input parameters for function \"search_unique_listed_product_styles_tnf_aggregate\""
    args: search_unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "execute function \"search_users\" which returns \"users\""
  search_users(
    "input parameters for function \"search_users\""
    args: search_users_args!,
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch data from the table: \"searchable_products\""
  searchable_products(
    "distinct select on columns"
    distinct_on: [searchable_products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_order_by!],
    "filter the rows returned"
    where: searchable_products_bool_exp
  ): [searchable_products!]!
  "fetch aggregated fields from the table: \"searchable_products\""
  searchable_products_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_order_by!],
    "filter the rows returned"
    where: searchable_products_bool_exp
  ): searchable_products_aggregate!
  "An array relationship"
  searchable_products_results(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "An aggregate relationship"
  searchable_products_results_aggregate(
    "distinct select on columns"
    distinct_on: [searchable_products_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [searchable_products_results_order_by!],
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): searchable_products_results_aggregate!
  "fetch data from the table: \"searchable_products_results\" using primary key columns"
  searchable_products_results_by_pk(id: uuid!): searchable_products_results
  "fetch data from the table in a streaming manner: \"searchable_products_results\""
  searchable_products_results_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [searchable_products_results_stream_cursor_input]!,
    "filter the rows returned"
    where: searchable_products_results_bool_exp
  ): [searchable_products_results!]!
  "fetch data from the table in a streaming manner: \"searchable_products\""
  searchable_products_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [searchable_products_stream_cursor_input]!,
    "filter the rows returned"
    where: searchable_products_bool_exp
  ): [searchable_products!]!
  "fetch data from the table: \"seller_ratings\""
  seller_ratings(
    "distinct select on columns"
    distinct_on: [seller_ratings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [seller_ratings_order_by!],
    "filter the rows returned"
    where: seller_ratings_bool_exp
  ): [seller_ratings!]!
  "fetch data from the table: \"seller_ratings\" using primary key columns"
  seller_ratings_by_pk(id: uuid!): seller_ratings
  "fetch data from the table in a streaming manner: \"seller_ratings\""
  seller_ratings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [seller_ratings_stream_cursor_input]!,
    "filter the rows returned"
    where: seller_ratings_bool_exp
  ): [seller_ratings!]!
  "fetch data from the table: \"shipping_carriers\""
  shipping_carriers(
    "distinct select on columns"
    distinct_on: [shipping_carriers_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_carriers_order_by!],
    "filter the rows returned"
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!
  "fetch data from the table: \"shipping_carriers\" using primary key columns"
  shipping_carriers_by_pk(carrier: String!): shipping_carriers
  "fetch data from the table in a streaming manner: \"shipping_carriers\""
  shipping_carriers_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [shipping_carriers_stream_cursor_input]!,
    "filter the rows returned"
    where: shipping_carriers_bool_exp
  ): [shipping_carriers!]!
  "fetch data from the table: \"shipping_information\""
  shipping_information(
    "distinct select on columns"
    distinct_on: [shipping_information_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_information_order_by!],
    "filter the rows returned"
    where: shipping_information_bool_exp
  ): [shipping_information!]!
  "fetch data from the table: \"shipping_information\" using primary key columns"
  shipping_information_by_pk(id: uuid!): shipping_information
  "fetch data from the table in a streaming manner: \"shipping_information\""
  shipping_information_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [shipping_information_stream_cursor_input]!,
    "filter the rows returned"
    where: shipping_information_bool_exp
  ): [shipping_information!]!
  "An array relationship"
  shipping_labels(
    "distinct select on columns"
    distinct_on: [shipping_labels_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_labels_order_by!],
    "filter the rows returned"
    where: shipping_labels_bool_exp
  ): [shipping_labels!]!
  "fetch data from the table: \"shipping_labels\" using primary key columns"
  shipping_labels_by_pk(id: uuid!): shipping_labels
  "fetch data from the table: \"shipping_labels_private\""
  shipping_labels_private(
    "distinct select on columns"
    distinct_on: [shipping_labels_private_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_labels_private_order_by!],
    "filter the rows returned"
    where: shipping_labels_private_bool_exp
  ): [shipping_labels_private!]!
  "fetch data from the table in a streaming manner: \"shipping_labels_private\""
  shipping_labels_private_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [shipping_labels_private_stream_cursor_input]!,
    "filter the rows returned"
    where: shipping_labels_private_bool_exp
  ): [shipping_labels_private!]!
  "fetch data from the table in a streaming manner: \"shipping_labels\""
  shipping_labels_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [shipping_labels_stream_cursor_input]!,
    "filter the rows returned"
    where: shipping_labels_bool_exp
  ): [shipping_labels!]!
  "fetch data from the table: \"shipping_statuses\""
  shipping_statuses(
    "distinct select on columns"
    distinct_on: [shipping_statuses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shipping_statuses_order_by!],
    "filter the rows returned"
    where: shipping_statuses_bool_exp
  ): [shipping_statuses!]!
  "fetch data from the table: \"shipping_statuses\" using primary key columns"
  shipping_statuses_by_pk(status: String!): shipping_statuses
  "fetch data from the table in a streaming manner: \"shipping_statuses\""
  shipping_statuses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [shipping_statuses_stream_cursor_input]!,
    "filter the rows returned"
    where: shipping_statuses_bool_exp
  ): [shipping_statuses!]!
  "fetch data from the table: \"short_links\""
  short_links(
    "distinct select on columns"
    distinct_on: [short_links_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [short_links_order_by!],
    "filter the rows returned"
    where: short_links_bool_exp
  ): [short_links!]!
  "fetch data from the table: \"short_links\" using primary key columns"
  short_links_by_pk(id: uuid!): short_links
  "fetch data from the table in a streaming manner: \"short_links\""
  short_links_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [short_links_stream_cursor_input]!,
    "filter the rows returned"
    where: short_links_bool_exp
  ): [short_links!]!
  "fetch data from the table: \"sku_images\""
  sku_images(
    "distinct select on columns"
    distinct_on: [sku_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_order_by!],
    "filter the rows returned"
    where: sku_images_bool_exp
  ): [sku_images!]!
  "fetch data from the table: \"sku_images\" using primary key columns"
  sku_images_by_pk(id: uuid!): sku_images
  "fetch data from the table in a streaming manner: \"sku_images\""
  sku_images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [sku_images_stream_cursor_input]!,
    "filter the rows returned"
    where: sku_images_bool_exp
  ): [sku_images!]!
  "fetch data from the table: \"sku_images_translations\""
  sku_images_translations(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): [sku_images_translations!]!
  "fetch aggregated fields from the table: \"sku_images_translations\""
  sku_images_translations_aggregate(
    "distinct select on columns"
    distinct_on: [sku_images_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_images_translations_order_by!],
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): sku_images_translations_aggregate!
  "fetch data from the table: \"sku_images_translations\" using primary key columns"
  sku_images_translations_by_pk(id: Int!): sku_images_translations
  "fetch data from the table in a streaming manner: \"sku_images_translations\""
  sku_images_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [sku_images_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: sku_images_translations_bool_exp
  ): [sku_images_translations!]!
  "An array relationship"
  sku_variant_type_options(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): [sku_variant_type_options!]!
  "An aggregate relationship"
  sku_variant_type_options_aggregate(
    "distinct select on columns"
    distinct_on: [sku_variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sku_variant_type_options_order_by!],
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): sku_variant_type_options_aggregate!
  "fetch data from the table: \"sku_variant_type_options\" using primary key columns"
  sku_variant_type_options_by_pk(id: uuid!): sku_variant_type_options
  "fetch data from the table in a streaming manner: \"sku_variant_type_options\""
  sku_variant_type_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [sku_variant_type_options_stream_cursor_input]!,
    "filter the rows returned"
    where: sku_variant_type_options_bool_exp
  ): [sku_variant_type_options!]!
  "An array relationship"
  skus(
    "distinct select on columns"
    distinct_on: [skus_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_order_by!],
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  "fetch data from the table: \"skus\" using primary key columns"
  skus_by_pk(id: uuid!): skus
  "fetch data from the table in a streaming manner: \"skus\""
  skus_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [skus_stream_cursor_input]!,
    "filter the rows returned"
    where: skus_bool_exp
  ): [skus!]!
  "An array relationship"
  skus_translations(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): [skus_translations!]!
  "An aggregate relationship"
  skus_translations_aggregate(
    "distinct select on columns"
    distinct_on: [skus_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [skus_translations_order_by!],
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): skus_translations_aggregate!
  "fetch data from the table: \"skus_translations\" using primary key columns"
  skus_translations_by_pk(id: bigint!): skus_translations
  "fetch data from the table in a streaming manner: \"skus_translations\""
  skus_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [skus_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: skus_translations_bool_exp
  ): [skus_translations!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_options\""
  storefront_fulfillment_in_store_options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_options_bool_exp
  ): [storefront_fulfillment_in_store_options!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_options\" using primary key columns"
  storefront_fulfillment_in_store_options_by_pk(id: uuid!): storefront_fulfillment_in_store_options
  "fetch data from the table in a streaming manner: \"storefront_fulfillment_in_store_options\""
  storefront_fulfillment_in_store_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_fulfillment_in_store_options_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_fulfillment_in_store_options_bool_exp
  ): [storefront_fulfillment_in_store_options!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_settings\""
  storefront_fulfillment_in_store_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_in_store_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_in_store_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_in_store_settings_bool_exp
  ): [storefront_fulfillment_in_store_settings!]!
  "fetch data from the table: \"storefront_fulfillment_in_store_settings\" using primary key columns"
  storefront_fulfillment_in_store_settings_by_pk(id: uuid!): storefront_fulfillment_in_store_settings
  "fetch data from the table in a streaming manner: \"storefront_fulfillment_in_store_settings\""
  storefront_fulfillment_in_store_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_fulfillment_in_store_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_fulfillment_in_store_settings_bool_exp
  ): [storefront_fulfillment_in_store_settings!]!
  "fetch data from the table: \"storefront_fulfillment_postal_options\""
  storefront_fulfillment_postal_options(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_options_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_options_bool_exp
  ): [storefront_fulfillment_postal_options!]!
  "fetch data from the table: \"storefront_fulfillment_postal_options\" using primary key columns"
  storefront_fulfillment_postal_options_by_pk(id: uuid!): storefront_fulfillment_postal_options
  "fetch data from the table in a streaming manner: \"storefront_fulfillment_postal_options\""
  storefront_fulfillment_postal_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_fulfillment_postal_options_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_fulfillment_postal_options_bool_exp
  ): [storefront_fulfillment_postal_options!]!
  "fetch data from the table: \"storefront_fulfillment_postal_settings\""
  storefront_fulfillment_postal_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_postal_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_postal_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_postal_settings_bool_exp
  ): [storefront_fulfillment_postal_settings!]!
  "fetch data from the table: \"storefront_fulfillment_postal_settings\" using primary key columns"
  storefront_fulfillment_postal_settings_by_pk(id: uuid!): storefront_fulfillment_postal_settings
  "fetch data from the table in a streaming manner: \"storefront_fulfillment_postal_settings\""
  storefront_fulfillment_postal_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_fulfillment_postal_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_fulfillment_postal_settings_bool_exp
  ): [storefront_fulfillment_postal_settings!]!
  "fetch data from the table: \"storefront_fulfillment_settings\""
  storefront_fulfillment_settings(
    "distinct select on columns"
    distinct_on: [storefront_fulfillment_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_fulfillment_settings_order_by!],
    "filter the rows returned"
    where: storefront_fulfillment_settings_bool_exp
  ): [storefront_fulfillment_settings!]!
  "fetch data from the table: \"storefront_fulfillment_settings\" using primary key columns"
  storefront_fulfillment_settings_by_pk(id: uuid!): storefront_fulfillment_settings
  "fetch data from the table in a streaming manner: \"storefront_fulfillment_settings\""
  storefront_fulfillment_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_fulfillment_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_fulfillment_settings_bool_exp
  ): [storefront_fulfillment_settings!]!
  "fetch data from the table: \"storefront_images\""
  storefront_images(
    "distinct select on columns"
    distinct_on: [storefront_images_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_images_order_by!],
    "filter the rows returned"
    where: storefront_images_bool_exp
  ): [storefront_images!]!
  "fetch data from the table: \"storefront_images\" using primary key columns"
  storefront_images_by_pk(id: uuid!): storefront_images
  "fetch data from the table in a streaming manner: \"storefront_images\""
  storefront_images_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_images_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_images_bool_exp
  ): [storefront_images!]!
  "fetch data from the table: \"storefront_payout_settings\""
  storefront_payout_settings(
    "distinct select on columns"
    distinct_on: [storefront_payout_settings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_payout_settings_order_by!],
    "filter the rows returned"
    where: storefront_payout_settings_bool_exp
  ): [storefront_payout_settings!]!
  "fetch data from the table in a streaming manner: \"storefront_payout_settings\""
  storefront_payout_settings_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_payout_settings_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_payout_settings_bool_exp
  ): [storefront_payout_settings!]!
  "fetch data from the table: \"storefront_reviews\""
  storefront_reviews(
    "distinct select on columns"
    distinct_on: [storefront_reviews_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_reviews_order_by!],
    "filter the rows returned"
    where: storefront_reviews_bool_exp
  ): [storefront_reviews!]!
  "fetch aggregated fields from the table: \"storefront_reviews\""
  storefront_reviews_aggregate(
    "distinct select on columns"
    distinct_on: [storefront_reviews_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_reviews_order_by!],
    "filter the rows returned"
    where: storefront_reviews_bool_exp
  ): storefront_reviews_aggregate!
  "fetch data from the table: \"storefront_reviews\" using primary key columns"
  storefront_reviews_by_pk(id: uuid!): storefront_reviews
  "fetch data from the table in a streaming manner: \"storefront_reviews\""
  storefront_reviews_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_reviews_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_reviews_bool_exp
  ): [storefront_reviews!]!
  "fetch data from the table: \"storefront_verified_attributes\""
  storefront_verified_attributes(
    "distinct select on columns"
    distinct_on: [storefront_verified_attributes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefront_verified_attributes_order_by!],
    "filter the rows returned"
    where: storefront_verified_attributes_bool_exp
  ): [storefront_verified_attributes!]!
  "fetch data from the table: \"storefront_verified_attributes\" using primary key columns"
  storefront_verified_attributes_by_pk(attribute: verified_identity_attributes_enum!, storefront_id: uuid!): storefront_verified_attributes
  "fetch data from the table in a streaming manner: \"storefront_verified_attributes\""
  storefront_verified_attributes_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefront_verified_attributes_stream_cursor_input]!,
    "filter the rows returned"
    where: storefront_verified_attributes_bool_exp
  ): [storefront_verified_attributes!]!
  "An array relationship"
  storefronts(
    "distinct select on columns"
    distinct_on: [storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefronts_order_by!],
    "filter the rows returned"
    where: storefronts_bool_exp
  ): [storefronts!]!
  "fetch data from the table: \"storefronts\" using primary key columns"
  storefronts_by_pk(id: uuid!): storefronts
  "fetch data from the table in a streaming manner: \"storefronts\""
  storefronts_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [storefronts_stream_cursor_input]!,
    "filter the rows returned"
    where: storefronts_bool_exp
  ): [storefronts!]!
  "An array relationship"
  takeback_items(
    "distinct select on columns"
    distinct_on: [takeback_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takeback_items_order_by!],
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  "fetch data from the table: \"takeback_items\" using primary key columns"
  takeback_items_by_pk(id: uuid!): takeback_items
  "fetch data from the table in a streaming manner: \"takeback_items\""
  takeback_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [takeback_items_stream_cursor_input]!,
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  "fetch data from the table: \"takebacks\""
  takebacks(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): [takebacks!]!
  "fetch aggregated fields from the table: \"takebacks\""
  takebacks_aggregate(
    "distinct select on columns"
    distinct_on: [takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takebacks_order_by!],
    "filter the rows returned"
    where: takebacks_bool_exp
  ): takebacks_aggregate!
  "fetch data from the table: \"takebacks\" using primary key columns"
  takebacks_by_pk(id: uuid!): takebacks
  "fetch data from the table in a streaming manner: \"takebacks\""
  takebacks_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [takebacks_stream_cursor_input]!,
    "filter the rows returned"
    where: takebacks_bool_exp
  ): [takebacks!]!
  "fetch data from the table: \"transaction_types\""
  transaction_types(
    "distinct select on columns"
    distinct_on: [transaction_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transaction_types_order_by!],
    "filter the rows returned"
    where: transaction_types_bool_exp
  ): [transaction_types!]!
  "fetch data from the table: \"transaction_types\" using primary key columns"
  transaction_types_by_pk(type: String!): transaction_types
  "fetch data from the table in a streaming manner: \"transaction_types\""
  transaction_types_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [transaction_types_stream_cursor_input]!,
    "filter the rows returned"
    where: transaction_types_bool_exp
  ): [transaction_types!]!
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "fetch data from the table: \"transactions\" using primary key columns"
  transactions_by_pk(id: uuid!): transactions
  "fetch data from the table in a streaming manner: \"transactions\""
  transactions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [transactions_stream_cursor_input]!,
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "fetch data from the table: \"unassociated_listing_data\""
  unassociated_listing_data(
    "distinct select on columns"
    distinct_on: [unassociated_listing_data_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unassociated_listing_data_order_by!],
    "filter the rows returned"
    where: unassociated_listing_data_bool_exp
  ): [unassociated_listing_data!]!
  "fetch data from the table: \"unassociated_listing_data\" using primary key columns"
  unassociated_listing_data_by_pk(id: uuid!): unassociated_listing_data
  "fetch data from the table: \"unassociated_listing_data_schemas\""
  unassociated_listing_data_schemas(
    "distinct select on columns"
    distinct_on: [unassociated_listing_data_schemas_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unassociated_listing_data_schemas_order_by!],
    "filter the rows returned"
    where: unassociated_listing_data_schemas_bool_exp
  ): [unassociated_listing_data_schemas!]!
  "fetch data from the table: \"unassociated_listing_data_schemas\" using primary key columns"
  unassociated_listing_data_schemas_by_pk(id: uuid!): unassociated_listing_data_schemas
  "fetch data from the table in a streaming manner: \"unassociated_listing_data_schemas\""
  unassociated_listing_data_schemas_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [unassociated_listing_data_schemas_stream_cursor_input]!,
    "filter the rows returned"
    where: unassociated_listing_data_schemas_bool_exp
  ): [unassociated_listing_data_schemas!]!
  "fetch data from the table in a streaming manner: \"unassociated_listing_data\""
  unassociated_listing_data_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [unassociated_listing_data_stream_cursor_input]!,
    "filter the rows returned"
    where: unassociated_listing_data_bool_exp
  ): [unassociated_listing_data!]!
  "execute function \"unique_listed_product_styles_tnf\" which returns \"product_styles_listed\""
  unique_listed_product_styles_tnf(
    "input parameters for function \"unique_listed_product_styles_tnf\""
    args: unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): [product_styles_listed!]!
  "execute function \"unique_listed_product_styles_tnf\" and query aggregates on result of table type \"product_styles_listed\""
  unique_listed_product_styles_tnf_aggregate(
    "input parameters for function \"unique_listed_product_styles_tnf_aggregate\""
    args: unique_listed_product_styles_tnf_args!,
    "distinct select on columns"
    distinct_on: [product_styles_listed_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [product_styles_listed_order_by!],
    "filter the rows returned"
    where: product_styles_listed_bool_exp
  ): product_styles_listed_aggregate!
  "execute function \"unique_listing_tags_by_brand\" which returns \"unique_tags_results\""
  unique_listing_tags_by_brand(
    "input parameters for function \"unique_listing_tags_by_brand\""
    args: unique_listing_tags_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "execute function \"unique_listing_tags_by_brand\" and query aggregates on result of table type \"unique_tags_results\""
  unique_listing_tags_by_brand_aggregate(
    "input parameters for function \"unique_listing_tags_by_brand_aggregate\""
    args: unique_listing_tags_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "execute function \"unique_listing_tags_by_brand_collection\" which returns \"unique_tags_results\""
  unique_listing_tags_by_brand_collection(
    "input parameters for function \"unique_listing_tags_by_brand_collection\""
    args: unique_listing_tags_by_brand_collection_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "execute function \"unique_listing_tags_by_brand_collection\" and query aggregates on result of table type \"unique_tags_results\""
  unique_listing_tags_by_brand_collection_aggregate(
    "input parameters for function \"unique_listing_tags_by_brand_collection_aggregate\""
    args: unique_listing_tags_by_brand_collection_args!,
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "execute function \"unique_listings_31pl\" which returns \"unique_listings_results_tnf\""
  unique_listings_31pl(
    "input parameters for function \"unique_listings_31pl\""
    args: unique_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"unique_listings_31pl\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  unique_listings_31pl_aggregate(
    "input parameters for function \"unique_listings_31pl_aggregate\""
    args: unique_listings_31pl_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "execute function \"unique_listings_by_brand\" which returns \"unique_listings_results\""
  unique_listings_by_brand(
    "input parameters for function \"unique_listings_by_brand\""
    args: unique_listings_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "execute function \"unique_listings_by_brand\" and query aggregates on result of table type \"unique_listings_results\""
  unique_listings_by_brand_aggregate(
    "input parameters for function \"unique_listings_by_brand_aggregate\""
    args: unique_listings_by_brand_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "execute function \"unique_listings_by_brand_tnf\" which returns \"unique_listings_results_tnf\""
  unique_listings_by_brand_tnf(
    "input parameters for function \"unique_listings_by_brand_tnf\""
    args: unique_listings_by_brand_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "execute function \"unique_listings_by_brand_tnf\" and query aggregates on result of table type \"unique_listings_results_tnf\""
  unique_listings_by_brand_tnf_aggregate(
    "input parameters for function \"unique_listings_by_brand_tnf_aggregate\""
    args: unique_listings_by_brand_tnf_args!,
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "fetch data from the table: \"unique_listings_results\""
  unique_listings_results(
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "fetch aggregated fields from the table: \"unique_listings_results\""
  unique_listings_results_aggregate(
    "distinct select on columns"
    distinct_on: [unique_listings_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_order_by!],
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): unique_listings_results_aggregate!
  "fetch data from the table: \"unique_listings_results\" using primary key columns"
  unique_listings_results_by_pk(product_id: uuid!): unique_listings_results
  "fetch data from the table in a streaming manner: \"unique_listings_results\""
  unique_listings_results_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [unique_listings_results_stream_cursor_input]!,
    "filter the rows returned"
    where: unique_listings_results_bool_exp
  ): [unique_listings_results!]!
  "fetch data from the table: \"unique_listings_results_tnf\""
  unique_listings_results_tnf(
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "fetch aggregated fields from the table: \"unique_listings_results_tnf\""
  unique_listings_results_tnf_aggregate(
    "distinct select on columns"
    distinct_on: [unique_listings_results_tnf_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_listings_results_tnf_order_by!],
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): unique_listings_results_tnf_aggregate!
  "fetch data from the table: \"unique_listings_results_tnf\" using primary key columns"
  unique_listings_results_tnf_by_pk(product_id: uuid!): unique_listings_results_tnf
  "fetch data from the table in a streaming manner: \"unique_listings_results_tnf\""
  unique_listings_results_tnf_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [unique_listings_results_tnf_stream_cursor_input]!,
    "filter the rows returned"
    where: unique_listings_results_tnf_bool_exp
  ): [unique_listings_results_tnf!]!
  "fetch data from the table: \"unique_tags_results\""
  unique_tags_results(
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "fetch aggregated fields from the table: \"unique_tags_results\""
  unique_tags_results_aggregate(
    "distinct select on columns"
    distinct_on: [unique_tags_results_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [unique_tags_results_order_by!],
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): unique_tags_results_aggregate!
  "fetch data from the table: \"unique_tags_results\" using primary key columns"
  unique_tags_results_by_pk(value: String!): unique_tags_results
  "fetch data from the table in a streaming manner: \"unique_tags_results\""
  unique_tags_results_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [unique_tags_results_stream_cursor_input]!,
    "filter the rows returned"
    where: unique_tags_results_bool_exp
  ): [unique_tags_results!]!
  "fetch data from the table: \"user_addresses\""
  user_addresses(
    "distinct select on columns"
    distinct_on: [user_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_addresses_order_by!],
    "filter the rows returned"
    where: user_addresses_bool_exp
  ): [user_addresses!]!
  "fetch data from the table: \"user_addresses\" using primary key columns"
  user_addresses_by_pk(id: uuid!): user_addresses
  "fetch data from the table in a streaming manner: \"user_addresses\""
  user_addresses_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_addresses_stream_cursor_input]!,
    "filter the rows returned"
    where: user_addresses_bool_exp
  ): [user_addresses!]!
  "fetch data from the table: \"user_alerts\""
  user_alerts(
    "distinct select on columns"
    distinct_on: [user_alerts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_alerts_order_by!],
    "filter the rows returned"
    where: user_alerts_bool_exp
  ): [user_alerts!]!
  "fetch data from the table: \"user_alerts\" using primary key columns"
  user_alerts_by_pk(id: uuid!): user_alerts
  "fetch data from the table in a streaming manner: \"user_alerts\""
  user_alerts_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_alerts_stream_cursor_input]!,
    "filter the rows returned"
    where: user_alerts_bool_exp
  ): [user_alerts!]!
  "An array relationship"
  user_balances(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): [user_balances!]!
  "An aggregate relationship"
  user_balances_aggregate(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): user_balances_aggregate!
  "fetch data from the table: \"user_balances\" using primary key columns"
  user_balances_by_pk(id: uuid!): user_balances
  "fetch data from the table in a streaming manner: \"user_balances\""
  user_balances_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_balances_stream_cursor_input]!,
    "filter the rows returned"
    where: user_balances_bool_exp
  ): [user_balances!]!
  "fetch data from the table: \"user_favorites\""
  user_favorites(
    "distinct select on columns"
    distinct_on: [user_favorites_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_favorites_order_by!],
    "filter the rows returned"
    where: user_favorites_bool_exp
  ): [user_favorites!]!
  "fetch data from the table: \"user_favorites\" using primary key columns"
  user_favorites_by_pk(id: uuid!): user_favorites
  "fetch data from the table in a streaming manner: \"user_favorites\""
  user_favorites_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_favorites_stream_cursor_input]!,
    "filter the rows returned"
    where: user_favorites_bool_exp
  ): [user_favorites!]!
  "fetch data from the table: \"user_metadata\""
  user_metadata(
    "distinct select on columns"
    distinct_on: [user_metadata_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_metadata_order_by!],
    "filter the rows returned"
    where: user_metadata_bool_exp
  ): [user_metadata!]!
  "fetch data from the table: \"user_metadata\" using primary key columns"
  user_metadata_by_pk(id: uuid!): user_metadata
  "fetch data from the table in a streaming manner: \"user_metadata\""
  user_metadata_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_metadata_stream_cursor_input]!,
    "filter the rows returned"
    where: user_metadata_bool_exp
  ): [user_metadata!]!
  "fetch data from the table: \"user_roles\""
  user_roles(
    "distinct select on columns"
    distinct_on: [user_roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_roles_order_by!],
    "filter the rows returned"
    where: user_roles_bool_exp
  ): [user_roles!]!
  "fetch data from the table: \"user_roles\" using primary key columns"
  user_roles_by_pk(id: uuid!): user_roles
  "fetch data from the table in a streaming manner: \"user_roles\""
  user_roles_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_roles_stream_cursor_input]!,
    "filter the rows returned"
    where: user_roles_bool_exp
  ): [user_roles!]!
  "fetch data from the table: \"user_verification_checks\""
  user_verification_checks(
    "distinct select on columns"
    distinct_on: [user_verification_checks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_verification_checks_order_by!],
    "filter the rows returned"
    where: user_verification_checks_bool_exp
  ): [user_verification_checks!]!
  "fetch data from the table: \"user_verification_checks\" using primary key columns"
  user_verification_checks_by_pk(id: uuid!): user_verification_checks
  "fetch data from the table in a streaming manner: \"user_verification_checks\""
  user_verification_checks_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [user_verification_checks_stream_cursor_input]!,
    "filter the rows returned"
    where: user_verification_checks_bool_exp
  ): [user_verification_checks!]!
  "fetch data from the table: \"users\""
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_order_by!],
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch data from the table: \"users\" using primary key columns"
  users_by_pk(id: String!): users
  "fetch data from the table: \"users_private\""
  users_private(
    "distinct select on columns"
    distinct_on: [users_private_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [users_private_order_by!],
    "filter the rows returned"
    where: users_private_bool_exp
  ): [users_private!]!
  "fetch data from the table in a streaming manner: \"users_private\""
  users_private_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [users_private_stream_cursor_input]!,
    "filter the rows returned"
    where: users_private_bool_exp
  ): [users_private!]!
  "fetch data from the table in a streaming manner: \"users\""
  users_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [users_stream_cursor_input]!,
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "An array relationship"
  variant_type_options(
    "distinct select on columns"
    distinct_on: [variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_order_by!],
    "filter the rows returned"
    where: variant_type_options_bool_exp
  ): [variant_type_options!]!
  "fetch data from the table: \"variant_type_options\" using primary key columns"
  variant_type_options_by_pk(id: uuid!): variant_type_options
  "fetch data from the table in a streaming manner: \"variant_type_options\""
  variant_type_options_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [variant_type_options_stream_cursor_input]!,
    "filter the rows returned"
    where: variant_type_options_bool_exp
  ): [variant_type_options!]!
  "An array relationship"
  variant_type_options_translations(
    "distinct select on columns"
    distinct_on: [variant_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_translations_order_by!],
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]!
  "fetch data from the table: \"variant_type_options_translations\" using primary key columns"
  variant_type_options_translations_by_pk(id: Int!): variant_type_options_translations
  "fetch data from the table in a streaming manner: \"variant_type_options_translations\""
  variant_type_options_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [variant_type_options_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]!
  "fetch data from the table: \"variant_types\""
  variant_types(
    "distinct select on columns"
    distinct_on: [variant_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_order_by!],
    "filter the rows returned"
    where: variant_types_bool_exp
  ): [variant_types!]!
  "fetch aggregated fields from the table: \"variant_types\""
  variant_types_aggregate(
    "distinct select on columns"
    distinct_on: [variant_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_order_by!],
    "filter the rows returned"
    where: variant_types_bool_exp
  ): variant_types_aggregate!
  "fetch data from the table: \"variant_types\" using primary key columns"
  variant_types_by_pk(id: uuid!): variant_types
  "fetch data from the table in a streaming manner: \"variant_types\""
  variant_types_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [variant_types_stream_cursor_input]!,
    "filter the rows returned"
    where: variant_types_bool_exp
  ): [variant_types!]!
  "An array relationship"
  variant_types_translations(
    "distinct select on columns"
    distinct_on: [variant_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_translations_order_by!],
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]!
  "fetch data from the table: \"variant_types_translations\" using primary key columns"
  variant_types_translations_by_pk(id: Int!): variant_types_translations
  "fetch data from the table in a streaming manner: \"variant_types_translations\""
  variant_types_translations_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [variant_types_translations_stream_cursor_input]!,
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]!
  "An array relationship"
  wms_items(
    "distinct select on columns"
    distinct_on: [wms_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [wms_items_order_by!],
    "filter the rows returned"
    where: wms_items_bool_exp
  ): [wms_items!]!
  "fetch data from the table: \"wms_items\" using primary key columns"
  wms_items_by_pk(id: uuid!): wms_items
  "fetch data from the table in a streaming manner: \"wms_items\""
  wms_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [wms_items_stream_cursor_input]!,
    "filter the rows returned"
    where: wms_items_bool_exp
  ): [wms_items!]!
  "fetch data from the table: \"workflow_definitions\""
  workflow_definitions(
    "distinct select on columns"
    distinct_on: [workflow_definitions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_definitions_order_by!],
    "filter the rows returned"
    where: workflow_definitions_bool_exp
  ): [workflow_definitions!]!
  "fetch data from the table: \"workflow_definitions\" using primary key columns"
  workflow_definitions_by_pk(id: uuid!): workflow_definitions
  "fetch data from the table in a streaming manner: \"workflow_definitions\""
  workflow_definitions_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [workflow_definitions_stream_cursor_input]!,
    "filter the rows returned"
    where: workflow_definitions_bool_exp
  ): [workflow_definitions!]!
  "fetch data from the table: \"workflow_item_event_types\""
  workflow_item_event_types(
    "distinct select on columns"
    distinct_on: [workflow_item_event_types_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_item_event_types_order_by!],
    "filter the rows returned"
    where: workflow_item_event_types_bool_exp
  ): [workflow_item_event_types!]!
  "fetch data from the table: \"workflow_item_event_types\" using primary key columns"
  workflow_item_event_types_by_pk(type: String!): workflow_item_event_types
  "fetch data from the table in a streaming manner: \"workflow_item_event_types\""
  workflow_item_event_types_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [workflow_item_event_types_stream_cursor_input]!,
    "filter the rows returned"
    where: workflow_item_event_types_bool_exp
  ): [workflow_item_event_types!]!
  "An array relationship"
  workflow_item_events(
    "distinct select on columns"
    distinct_on: [workflow_item_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_item_events_order_by!],
    "filter the rows returned"
    where: workflow_item_events_bool_exp
  ): [workflow_item_events!]!
  "fetch data from the table: \"workflow_item_events\" using primary key columns"
  workflow_item_events_by_pk(id: uuid!): workflow_item_events
  "fetch data from the table in a streaming manner: \"workflow_item_events\""
  workflow_item_events_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [workflow_item_events_stream_cursor_input]!,
    "filter the rows returned"
    where: workflow_item_events_bool_exp
  ): [workflow_item_events!]!
  "An array relationship"
  workflow_items(
    "distinct select on columns"
    distinct_on: [workflow_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_items_order_by!],
    "filter the rows returned"
    where: workflow_items_bool_exp
  ): [workflow_items!]!
  "fetch data from the table: \"workflow_items\" using primary key columns"
  workflow_items_by_pk(id: uuid!): workflow_items
  "fetch data from the table in a streaming manner: \"workflow_items\""
  workflow_items_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [workflow_items_stream_cursor_input]!,
    "filter the rows returned"
    where: workflow_items_bool_exp
  ): [workflow_items!]!
  "An array relationship"
  workflows(
    "distinct select on columns"
    distinct_on: [workflows_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflows_order_by!],
    "filter the rows returned"
    where: workflows_bool_exp
  ): [workflows!]!
  "fetch data from the table: \"workflows\" using primary key columns"
  workflows_by_pk(id: uuid!): workflows
  "fetch data from the table in a streaming manner: \"workflows\""
  workflows_stream(
    "maximum number of rows returned in a single batch"
    batch_size: Int!,
    "cursor to stream the results returned by the query"
    cursor: [workflows_stream_cursor_input]!,
    "filter the rows returned"
    where: workflows_bool_exp
  ): [workflows!]!
}

"columns and relationships of \"takeback_items\""
type takeback_items {
  created_at: timestamptz!
  "An object relationship"
  credit: credit
  credit_id: uuid
  "An object relationship"
  estimate_credit: credit
  estimate_credit_id: uuid
  "An object relationship"
  form_submission: form_submissions
  form_submission_id: uuid
  id: uuid!
  lpn: String
  "An object relationship"
  product: products
  "An object relationship"
  product_style: product_styles
  status: takeback_item_statuses_enum!
  style_code: String
  "An object relationship"
  takeback: takebacks!
  takeback_id: uuid!
  updated_at: timestamptz!
}

"columns and relationships of \"takebacks\""
type takebacks {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  created_at: timestamptz!
  "An object relationship"
  credit: credit
  credit_id: uuid
  "An object relationship"
  estimate_credit: credit
  estimate_credit_id: uuid
  id: uuid!
  status: takeback_statuses_enum
  store_number: String
  "An object relationship"
  storefront: storefronts
  "An array relationship"
  takeback_items(
    "distinct select on columns"
    distinct_on: [takeback_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [takeback_items_order_by!],
    "filter the rows returned"
    where: takeback_items_bool_exp
  ): [takeback_items!]!
  "An array relationship"
  takeback_mail_takeback(
    "distinct select on columns"
    distinct_on: [mail_takebacks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [mail_takebacks_order_by!],
    "filter the rows returned"
    where: mail_takebacks_bool_exp
  ): [mail_takebacks!]!
  takeback_number: String
  "An object relationship"
  transaction: transactions
  transaction_id: uuid
  updated_at: timestamptz!
  "An object relationship"
  user: users!
  user_id: String!
}

"aggregated selection of \"takebacks\""
type takebacks_aggregate {
  aggregate: takebacks_aggregate_fields
  nodes: [takebacks!]!
}

"aggregate fields of \"takebacks\""
type takebacks_aggregate_fields {
  count(columns: [takebacks_select_column!], distinct: Boolean): Int!
  max: takebacks_max_fields
  min: takebacks_min_fields
}

"aggregate max on columns"
type takebacks_max_fields {
  brand_id: uuid
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  id: uuid
  store_number: String
  takeback_number: String
  transaction_id: uuid
  updated_at: timestamptz
  user_id: String
}

"aggregate min on columns"
type takebacks_min_fields {
  brand_id: uuid
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  id: uuid
  store_number: String
  takeback_number: String
  transaction_id: uuid
  updated_at: timestamptz
  user_id: String
}

"columns and relationships of \"transaction_types\""
type transaction_types {
  type: String!
}

"columns and relationships of \"transactions\""
type transactions {
  amount: Int!
  "An object relationship"
  brand: brands
  brand_id: uuid
  created_at: timestamptz
  fee: Int!
  "An array relationship"
  gift_cards(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): [gift_cards!]!
  "An aggregate relationship"
  gift_cards_aggregate(
    "distinct select on columns"
    distinct_on: [gift_cards_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gift_cards_order_by!],
    "filter the rows returned"
    where: gift_cards_bool_exp
  ): gift_cards_aggregate!
  id: uuid!
  "An object relationship"
  listing: listings
  listing_id: uuid
  type: transaction_types_enum!
  "An object relationship"
  user: users!
  user_id: String!
}

"aggregated selection of \"transactions\""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

"aggregate fields of \"transactions\""
type transactions_aggregate_fields {
  avg: transactions_avg_fields
  count(columns: [transactions_select_column!], distinct: Boolean): Int!
  max: transactions_max_fields
  min: transactions_min_fields
  stddev: transactions_stddev_fields
  stddev_pop: transactions_stddev_pop_fields
  stddev_samp: transactions_stddev_samp_fields
  sum: transactions_sum_fields
  var_pop: transactions_var_pop_fields
  var_samp: transactions_var_samp_fields
  variance: transactions_variance_fields
}

"aggregate avg on columns"
type transactions_avg_fields {
  amount: Float
  fee: Float
}

"aggregate max on columns"
type transactions_max_fields {
  amount: Int
  brand_id: uuid
  created_at: timestamptz
  fee: Int
  id: uuid
  listing_id: uuid
  user_id: String
}

"aggregate min on columns"
type transactions_min_fields {
  amount: Int
  brand_id: uuid
  created_at: timestamptz
  fee: Int
  id: uuid
  listing_id: uuid
  user_id: String
}

"aggregate stddev on columns"
type transactions_stddev_fields {
  amount: Float
  fee: Float
}

"aggregate stddev_pop on columns"
type transactions_stddev_pop_fields {
  amount: Float
  fee: Float
}

"aggregate stddev_samp on columns"
type transactions_stddev_samp_fields {
  amount: Float
  fee: Float
}

"aggregate sum on columns"
type transactions_sum_fields {
  amount: Int
  fee: Int
}

"aggregate var_pop on columns"
type transactions_var_pop_fields {
  amount: Float
  fee: Float
}

"aggregate var_samp on columns"
type transactions_var_samp_fields {
  amount: Float
  fee: Float
}

"aggregate variance on columns"
type transactions_variance_fields {
  amount: Float
  fee: Float
}

"columns and relationships of \"unassociated_listing_data\""
type unassociated_listing_data {
  brand_id: uuid!
  "An object relationship"
  category: brand_categories!
  category_id: uuid!
  created_at: timestamptz!
  custom_metadata(
    "JSON select path"
    path: String
  ): jsonb!
  description: String!
  id: uuid!
  name: String!
  original_price: Int
  storefront_id: uuid
  updated_at: timestamptz!
  user_id: String!
  variant_data(
    "JSON select path"
    path: String
  ): jsonb!
}

"columns and relationships of \"unassociated_listing_data_schemas\""
type unassociated_listing_data_schemas {
  brand_id: uuid!
  category_id: uuid
  created_at: timestamptz!
  id: uuid!
  question_set_id: uuid!
  schema(
    "JSON select path"
    path: String
  ): jsonb!
  updated_at: timestamptz!
}

"columns and relationships of \"unique_listings_results\""
type unique_listings_results {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  color: String!
  color_mapping: String!
  latest_created_at: timestamptz!
  max_price: Int!
  min_price: Int!
  name: String!
  priority: Int
  "An object relationship"
  product: products!
  product_id: uuid!
  sizes: String!
  type: String!
}

type unique_listings_results_aggregate {
  aggregate: unique_listings_results_aggregate_fields
  nodes: [unique_listings_results!]!
}

"aggregate fields of \"unique_listings_results\""
type unique_listings_results_aggregate_fields {
  avg: unique_listings_results_avg_fields
  count(columns: [unique_listings_results_select_column!], distinct: Boolean): Int!
  max: unique_listings_results_max_fields
  min: unique_listings_results_min_fields
  stddev: unique_listings_results_stddev_fields
  stddev_pop: unique_listings_results_stddev_pop_fields
  stddev_samp: unique_listings_results_stddev_samp_fields
  sum: unique_listings_results_sum_fields
  var_pop: unique_listings_results_var_pop_fields
  var_samp: unique_listings_results_var_samp_fields
  variance: unique_listings_results_variance_fields
}

"aggregate avg on columns"
type unique_listings_results_avg_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate max on columns"
type unique_listings_results_max_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  sizes: String
  type: String
}

"aggregate min on columns"
type unique_listings_results_min_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  sizes: String
  type: String
}

"aggregate stddev on columns"
type unique_listings_results_stddev_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate stddev_pop on columns"
type unique_listings_results_stddev_pop_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate stddev_samp on columns"
type unique_listings_results_stddev_samp_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate sum on columns"
type unique_listings_results_sum_fields {
  max_price: Int
  min_price: Int
  priority: Int
}

"columns and relationships of \"unique_listings_results_tnf\""
type unique_listings_results_tnf {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  color: String!
  color_mapping: String!
  latest_created_at: timestamptz!
  max_price: Int!
  min_price: Int!
  name: String!
  priority: Int
  "An object relationship"
  product: products!
  product_id: uuid!
  size_groupings: String!
  sizes: String!
  tags: String!
  type: String!
}

type unique_listings_results_tnf_aggregate {
  aggregate: unique_listings_results_tnf_aggregate_fields
  nodes: [unique_listings_results_tnf!]!
}

"aggregate fields of \"unique_listings_results_tnf\""
type unique_listings_results_tnf_aggregate_fields {
  avg: unique_listings_results_tnf_avg_fields
  count(columns: [unique_listings_results_tnf_select_column!], distinct: Boolean): Int!
  max: unique_listings_results_tnf_max_fields
  min: unique_listings_results_tnf_min_fields
  stddev: unique_listings_results_tnf_stddev_fields
  stddev_pop: unique_listings_results_tnf_stddev_pop_fields
  stddev_samp: unique_listings_results_tnf_stddev_samp_fields
  sum: unique_listings_results_tnf_sum_fields
  var_pop: unique_listings_results_tnf_var_pop_fields
  var_samp: unique_listings_results_tnf_var_samp_fields
  variance: unique_listings_results_tnf_variance_fields
}

"aggregate avg on columns"
type unique_listings_results_tnf_avg_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate max on columns"
type unique_listings_results_tnf_max_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  size_groupings: String
  sizes: String
  tags: String
  type: String
}

"aggregate min on columns"
type unique_listings_results_tnf_min_fields {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  size_groupings: String
  sizes: String
  tags: String
  type: String
}

"aggregate stddev on columns"
type unique_listings_results_tnf_stddev_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate stddev_pop on columns"
type unique_listings_results_tnf_stddev_pop_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate stddev_samp on columns"
type unique_listings_results_tnf_stddev_samp_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate sum on columns"
type unique_listings_results_tnf_sum_fields {
  max_price: Int
  min_price: Int
  priority: Int
}

"aggregate var_pop on columns"
type unique_listings_results_tnf_var_pop_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate var_samp on columns"
type unique_listings_results_tnf_var_samp_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate variance on columns"
type unique_listings_results_tnf_variance_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate var_pop on columns"
type unique_listings_results_var_pop_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate var_samp on columns"
type unique_listings_results_var_samp_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"aggregate variance on columns"
type unique_listings_results_variance_fields {
  max_price: Float
  min_price: Float
  priority: Float
}

"columns and relationships of \"unique_tags_results\""
type unique_tags_results {
  value: String!
}

type unique_tags_results_aggregate {
  aggregate: unique_tags_results_aggregate_fields
  nodes: [unique_tags_results!]!
}

"aggregate fields of \"unique_tags_results\""
type unique_tags_results_aggregate_fields {
  count(columns: [unique_tags_results_select_column!], distinct: Boolean): Int!
  max: unique_tags_results_max_fields
  min: unique_tags_results_min_fields
}

"aggregate max on columns"
type unique_tags_results_max_fields {
  value: String
}

"aggregate min on columns"
type unique_tags_results_min_fields {
  value: String
}

"columns and relationships of \"user_addresses\""
type user_addresses {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String!
  created_at: timestamptz!
  floors: Int
  id: uuid!
  locality: String!
  name: String!
  organization: String
  phone_number: String
  postal_code: String!
  updated_at: timestamptz!
  "An object relationship"
  user: users!
  user_id: String!
}

"response of any mutation on the table \"user_addresses\""
type user_addresses_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [user_addresses!]!
}

"columns and relationships of \"user_alerts\""
type user_alerts {
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  product: products!
  product_id: uuid!
  "An object relationship"
  sku: skus!
  sku_id: uuid!
  uid: String!
  "An object relationship"
  user: users!
  user_id: String!
}

"response of any mutation on the table \"user_alerts\""
type user_alerts_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [user_alerts!]!
}

"columns and relationships of \"user_balances\""
type user_balances {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  current_balance: Int!
  id: uuid!
  "An object relationship"
  storefront: storefronts
  storefront_id: uuid
  "An object relationship"
  user: users!
  user_id: String!
}

"aggregated selection of \"user_balances\""
type user_balances_aggregate {
  aggregate: user_balances_aggregate_fields
  nodes: [user_balances!]!
}

"aggregate fields of \"user_balances\""
type user_balances_aggregate_fields {
  avg: user_balances_avg_fields
  count(columns: [user_balances_select_column!], distinct: Boolean): Int!
  max: user_balances_max_fields
  min: user_balances_min_fields
  stddev: user_balances_stddev_fields
  stddev_pop: user_balances_stddev_pop_fields
  stddev_samp: user_balances_stddev_samp_fields
  sum: user_balances_sum_fields
  var_pop: user_balances_var_pop_fields
  var_samp: user_balances_var_samp_fields
  variance: user_balances_variance_fields
}

"aggregate avg on columns"
type user_balances_avg_fields {
  current_balance: Float
}

"aggregate max on columns"
type user_balances_max_fields {
  brand_id: uuid
  current_balance: Int
  id: uuid
  storefront_id: uuid
  user_id: String
}

"aggregate min on columns"
type user_balances_min_fields {
  brand_id: uuid
  current_balance: Int
  id: uuid
  storefront_id: uuid
  user_id: String
}

"aggregate stddev on columns"
type user_balances_stddev_fields {
  current_balance: Float
}

"aggregate stddev_pop on columns"
type user_balances_stddev_pop_fields {
  current_balance: Float
}

"aggregate stddev_samp on columns"
type user_balances_stddev_samp_fields {
  current_balance: Float
}

"aggregate sum on columns"
type user_balances_sum_fields {
  current_balance: Int
}

"aggregate var_pop on columns"
type user_balances_var_pop_fields {
  current_balance: Float
}

"aggregate var_samp on columns"
type user_balances_var_samp_fields {
  current_balance: Float
}

"aggregate variance on columns"
type user_balances_variance_fields {
  current_balance: Float
}

"columns and relationships of \"user_favorites\""
type user_favorites {
  created_at: timestamptz!
  id: uuid!
  "An object relationship"
  listing: listings
  listing_id: uuid
  "An object relationship"
  product: products
  product_id: uuid
  "An object relationship"
  user: users!
  user_id: String!
}

"response of any mutation on the table \"user_favorites\""
type user_favorites_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [user_favorites!]!
}

"columns and relationships of \"user_metadata\""
type user_metadata {
  brand_id: uuid!
  id: uuid!
  key: String!
  user_id: String!
  value(
    "JSON select path"
    path: String
  ): jsonb!
}

"columns and relationships of \"user_roles\""
type user_roles {
  brand_id: uuid!
  id: uuid!
  role: roles_enum!
  user_id: String!
}

"columns and relationships of \"user_verification_checks\""
type user_verification_checks {
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  status: user_verification_check_statuses_enum!
  stripe_verification_response_id: String
  stripe_verification_session_id: String
  updated_at: timestamptz!
  user_id: String!
}

"response of any mutation on the table \"user_verification_checks\""
type user_verification_checks_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [user_verification_checks!]!
}

"columns and relationships of \"users\""
type users {
  "An array relationship"
  addresses(
    "distinct select on columns"
    distinct_on: [user_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_addresses_order_by!],
    "filter the rows returned"
    where: user_addresses_bool_exp
  ): [user_addresses!]!
  "An array relationship"
  annual_sales_totals(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An aggregate relationship"
  annual_sales_totals_aggregate(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): annual_sales_totals_aggregate!
  "An object relationship"
  brand: brands
  "An object relationship"
  default_shipping_address: user_addresses
  first_name: String
  id: String!
  last_name: String
  "An array relationship"
  listings(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): [listings!]!
  "An aggregate relationship"
  listings_aggregate(
    "distinct select on columns"
    distinct_on: [listings_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [listings_order_by!],
    "filter the rows returned"
    where: listings_bool_exp
  ): listings_aggregate!
  "An array relationship"
  orders(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): [orders!]!
  "An aggregate relationship"
  orders_aggregate(
    "distinct select on columns"
    distinct_on: [orders_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [orders_order_by!],
    "filter the rows returned"
    where: orders_bool_exp
  ): orders_aggregate!
  "An array relationship"
  owned_storefronts(
    "distinct select on columns"
    distinct_on: [storefronts_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [storefronts_order_by!],
    "filter the rows returned"
    where: storefronts_bool_exp
  ): [storefronts!]!
  "An object relationship"
  private: users_private
  "An array relationship"
  roles(
    "distinct select on columns"
    distinct_on: [user_roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_roles_order_by!],
    "filter the rows returned"
    where: user_roles_bool_exp
  ): [user_roles!]!
  state: String
  "An array relationship"
  transactions(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): [transactions!]!
  "An aggregate relationship"
  transactions_aggregate(
    "distinct select on columns"
    distinct_on: [transactions_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [transactions_order_by!],
    "filter the rows returned"
    where: transactions_bool_exp
  ): transactions_aggregate!
  "An array relationship"
  user_balances(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): [user_balances!]!
  "An aggregate relationship"
  user_balances_aggregate(
    "distinct select on columns"
    distinct_on: [user_balances_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_balances_order_by!],
    "filter the rows returned"
    where: user_balances_bool_exp
  ): user_balances_aggregate!
  "An array relationship"
  verification_checks(
    "distinct select on columns"
    distinct_on: [user_verification_checks_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_verification_checks_order_by!],
    "filter the rows returned"
    where: user_verification_checks_bool_exp
  ): [user_verification_checks!]!
}

"response of any mutation on the table \"users\""
type users_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [users!]!
}

"columns and relationships of \"users_private\""
type users_private {
  "An array relationship"
  addresses(
    "distinct select on columns"
    distinct_on: [user_addresses_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_addresses_order_by!],
    "filter the rows returned"
    where: user_addresses_bool_exp
  ): [user_addresses!]!
  "An array relationship"
  annual_sales_totals(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): [annual_sales_totals!]!
  "An aggregate relationship"
  annual_sales_totals_aggregate(
    "distinct select on columns"
    distinct_on: [annual_sales_totals_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [annual_sales_totals_order_by!],
    "filter the rows returned"
    where: annual_sales_totals_bool_exp
  ): annual_sales_totals_aggregate!
  brand_id: uuid
  created_at: timestamptz
  current_balance: Int
  "An object relationship"
  default_shipping_address: user_addresses
  default_shipping_address_id: uuid
  email: String
  is_manager: Boolean
  "An array relationship"
  roles(
    "distinct select on columns"
    distinct_on: [user_roles_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_roles_order_by!],
    "filter the rows returned"
    where: user_roles_bool_exp
  ): [user_roles!]!
  stripe_account_id: String
  updated_at: timestamptz
  user_id: String
}

"columns and relationships of \"variant_type_options\""
type variant_type_options {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "A computed field, executes function \"vto_content\""
  content(
    "distinct select on columns"
    distinct_on: [variant_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_translations_order_by!],
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]
  created_at: timestamptz!
  id: uuid!
  option: String!
  updated_at: timestamptz!
  "An object relationship"
  variant_type: variant_types!
  variant_type_id: uuid!
  "An array relationship"
  variant_type_options_translations(
    "distinct select on columns"
    distinct_on: [variant_type_options_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_translations_order_by!],
    "filter the rows returned"
    where: variant_type_options_translations_bool_exp
  ): [variant_type_options_translations!]!
}

"columns and relationships of \"variant_type_options_translations\""
type variant_type_options_translations {
  display: String!
  id: Int!
  lang: String!
  variant_type_option_id: uuid!
}

"columns and relationships of \"variant_types\""
type variant_types {
  "An object relationship"
  brand: brands!
  brand_id: uuid!
  "A computed field, executes function \"vt_content\""
  content(
    "distinct select on columns"
    distinct_on: [variant_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_translations_order_by!],
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]
  id: uuid!
  type: String!
  "An array relationship"
  variant_type_options(
    "distinct select on columns"
    distinct_on: [variant_type_options_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_type_options_order_by!],
    "filter the rows returned"
    where: variant_type_options_bool_exp
  ): [variant_type_options!]!
  "An array relationship"
  variant_types_translations(
    "distinct select on columns"
    distinct_on: [variant_types_translations_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [variant_types_translations_order_by!],
    "filter the rows returned"
    where: variant_types_translations_bool_exp
  ): [variant_types_translations!]!
}

"aggregated selection of \"variant_types\""
type variant_types_aggregate {
  aggregate: variant_types_aggregate_fields
  nodes: [variant_types!]!
}

"aggregate fields of \"variant_types\""
type variant_types_aggregate_fields {
  count(columns: [variant_types_select_column!], distinct: Boolean): Int!
  max: variant_types_max_fields
  min: variant_types_min_fields
}

"aggregate max on columns"
type variant_types_max_fields {
  brand_id: uuid
  id: uuid
  type: String
}

"aggregate min on columns"
type variant_types_min_fields {
  brand_id: uuid
  id: uuid
  type: String
}

"columns and relationships of \"variant_types_translations\""
type variant_types_translations {
  display: String!
  id: Int!
  lang: String!
  variant_type_id: uuid!
}

"columns and relationships of \"wms_items\""
type wms_items {
  "An object relationship"
  brand: brands!
  "An object relationship"
  brand_category: brand_categories
  id: uuid!
  "An object relationship"
  listing: listings
  listing_id: uuid
  lpn: String!
  "An object relationship"
  product: products
  "An object relationship"
  product_style: product_styles
  "An object relationship"
  sku: skus
}

"columns and relationships of \"workflow_definitions\""
type workflow_definitions {
  callbacks(
    "JSON select path"
    path: String
  ): jsonb
  created_at: timestamptz!
  id: uuid!
  schema(
    "JSON select path"
    path: String
  ): jsonb!
  type: String!
  updated_at: timestamptz!
  "An array relationship"
  workflow_items(
    "distinct select on columns"
    distinct_on: [workflow_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_items_order_by!],
    "filter the rows returned"
    where: workflow_items_bool_exp
  ): [workflow_items!]!
  "An array relationship"
  workflows(
    "distinct select on columns"
    distinct_on: [workflows_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflows_order_by!],
    "filter the rows returned"
    where: workflows_bool_exp
  ): [workflows!]!
}

"columns and relationships of \"workflow_item_event_types\""
type workflow_item_event_types {
  type: String!
}

"columns and relationships of \"workflow_item_events\""
type workflow_item_events {
  event_type: workflow_item_event_types_enum!
  id: uuid!
  payload(
    "JSON select path"
    path: String
  ): jsonb
  timestamp: timestamptz!
  "An object relationship"
  user: users
  value: String!
  "An object relationship"
  workflow_item: workflow_items!
  "An object relationship"
  workflow_item_event_type: workflow_item_event_types!
  workflow_item_id: uuid!
}

"columns and relationships of \"workflow_items\""
type workflow_items {
  brand_id: uuid!
  created_at: timestamptz!
  data(
    "JSON select path"
    path: String
  ): jsonb!
  id: uuid!
  state: String!
  updated_at: timestamptz!
  "An object relationship"
  workflow: workflows!
  "An object relationship"
  workflow_definition: workflow_definitions!
  workflow_definition_id: uuid!
  workflow_id: uuid!
  "An array relationship"
  workflow_item_events(
    "distinct select on columns"
    distinct_on: [workflow_item_events_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_item_events_order_by!],
    "filter the rows returned"
    where: workflow_item_events_bool_exp
  ): [workflow_item_events!]!
}

"response of any mutation on the table \"workflow_items\""
type workflow_items_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [workflow_items!]!
}

"columns and relationships of \"workflows\""
type workflows {
  brand_id: uuid!
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!
  "An object relationship"
  workflow_definition: workflow_definitions!
  workflow_definition_id: uuid!
  "An array relationship"
  workflow_items(
    "distinct select on columns"
    distinct_on: [workflow_items_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [workflow_items_order_by!],
    "filter the rows returned"
    where: workflow_items_bool_exp
  ): [workflow_items!]!
}

enum AddressField {
  ADDRESS_LINE_1
  ADDRESS_LINE_2
  ADMINISTRATIVE_AREA
  COUNTRY
  LOCALITY
  NAME
  PHONE_NUMBER
  POSTAL_CODE
}

enum CollectionType {
  manual
  rule
}

enum CreateStoreTakebackMetadataSchemas {
  LululemonTakebackInputV1
}

enum DiscountErrorCode {
  DOES_NOT_APPLY
  EMAIL_REQUIRED
  UNKNOWN_CODE
  USES_EXCEEDED
}

enum GetStoreTakebackMetadataSchemas {
  LululemonTakebackResultV1
}

enum ItemFulfillmentType {
  LISTING
}

enum LookupTakebacksOrderBy {
  default
}

enum ReturnChargeType {
  RETURN_SHIPPING
}

enum TakebackItemIdType {
  PRODUCT_ID
  PRODUCT_STYLE_CODE
  PRODUCT_STYLE_ID
}

enum TakebackRequestStoreCreditStatus {
  REQUEST_ERROR
  SUCCESS
}

enum TakebackType {
  MAIL_IN
  STORE
}

enum ValidateAddressV2AddressType {
  BUSINESS
  RESIDENTIAL
  UNKNOWN
}

enum ValidateAddressV2ResultValidationReasonCode {
  ADDRESS_NOT_FOUND
  EXCEEDS_35_CHARACTER_LIMIT
  EXCEEDS_50_CHARACTER_LIMIT
  GENERIC_VALIDATION_ERROR
  GEOCODE_NOT_SPECIFIC
  INELIGIBLE_REGION
  INELIGIBLE_SHIP_TO_PO_BOX
  INVALID_POSTAL_CODE
  MISSING_PREMISE
  MISSING_SUBPREMISE
  MULTIPLE_MATCHES_FOUND
  STREET_NOT_DELIVERABLE
  STREET_NOT_FOUND
  UNVERIFIED_PREMISE
  UNVERIFIED_SUBPREMISE
}

enum ValidateAddressV2ResultValidationReasonType {
  BLOCKED
  WARNING
}

enum ValidateAddressV2ResultValidationResult {
  BLOCKED
  UNVERIFIED
  VERIFIED
}

"unique or primary key constraints on table \"addresses\""
enum addresses_constraint {
  "unique or primary key constraint on columns \"id\""
  addresses_pkey
}

"select columns of table \"addresses\""
enum addresses_select_column {
  "column name"
  administrative_area
  "column name"
  country
  "column name"
  id
  "column name"
  locality
  "column name"
  longlat_pub
}

"placeholder for update columns of table \"addresses\" (current role has no relevant permissions)"
enum addresses_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column {
  "column name"
  country
  "column name"
  storefront_id
  "column name"
  tax_year
  "column name"
  total
  "column name"
  total_sales_count
  "column name"
  user_id
}

"select \"annual_sales_totals_aggregate_bool_exp_avg_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_avg_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_corr_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_corr_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_covar_samp_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_covar_samp_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_max_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_max_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_min_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_min_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_stddev_samp_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_stddev_samp_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_sum_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_sum_arguments_columns {
  "column name"
  tax_year
}

"select \"annual_sales_totals_aggregate_bool_exp_var_samp_arguments_columns\" columns of table \"annual_sales_totals\""
enum annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_var_samp_arguments_columns {
  "column name"
  tax_year
}

"select columns of table \"applied_discount_codes\""
enum applied_discount_codes_select_column {
  "column name"
  discount_amount
  "column name"
  id
  "column name"
  order_id
}

"unique or primary key constraints on table \"attempted_discount_codes\""
enum attempted_discount_codes_constraint {
  "unique or primary key constraint on columns \"id\""
  attempted_discount_codes_pkey
}

"select columns of table \"attempted_discount_codes\""
enum attempted_discount_codes_select_column {
  "column name"
  discount_amount
  "column name"
  id
  "column name"
  order_intent_id
}

"placeholder for update columns of table \"attempted_discount_codes\" (current role has no relevant permissions)"
enum attempted_discount_codes_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"attribute_type_options\""
enum attribute_type_options_select_column {
  "column name"
  attribute_type_id
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  option
  "column name"
  updated_at
}

"select columns of table \"attribute_type_options_translations\""
enum attribute_type_options_translations_select_column {
  "column name"
  attribute_type_option_id
  "column name"
  display
  "column name"
  id
  "column name"
  lang
}

"select columns of table \"attribute_types\""
enum attribute_types_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  type
}

"select columns of table \"attribute_types_translations\""
enum attribute_types_translations_select_column {
  "column name"
  attribute_type_id
  "column name"
  display
  "column name"
  id
  "column name"
  lang
}

"unique or primary key constraints on table \"auction_bids\""
enum auction_bids_constraint {
  "unique or primary key constraint on columns \"id\""
  auction_bids_pkey
}

"select columns of table \"auction_bids_history\""
enum auction_bids_history_select_column {
  "column name"
  amount
  "column name"
  auction_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  order
  "column name"
  user_id
}

"select columns of table \"auction_bids\""
enum auction_bids_select_column {
  "column name"
  address_id
  "column name"
  amount
  "column name"
  auction_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  order
  "column name"
  payment_intent_id
  "column name"
  user_id
}

"placeholder for update columns of table \"auction_bids\" (current role has no relevant permissions)"
enum auction_bids_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"auctions\""
enum auctions_select_column {
  "column name"
  end
  "column name"
  id
  "column name"
  listing_id
  "column name"
  max_price
  "column name"
  start
}

"select columns of table \"brand_categories\""
enum brand_categories_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  default_price_multiplier
  "column name"
  id
  "column name"
  name
  "column name"
  parent_id
  "column name"
  singular
  "column name"
  uid
  "column name"
  updated_at
}

"select columns of table \"brand_categories_translations\""
enum brand_categories_translations_select_column {
  "column name"
  category_id
  "column name"
  id
  "column name"
  lang
  "column name"
  name
  "column name"
  singular
}

"select columns of table \"brand_fulfillment_in_store_options\""
enum brand_fulfillment_in_store_options_select_column {
  "column name"
  brand_fulfillment_in_store_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  retail_store_id
  "column name"
  shipping_fee
  "column name"
  updated_at
}

"select columns of table \"brand_fulfillment_in_store_settings\""
enum brand_fulfillment_in_store_settings_select_column {
  "column name"
  brand_fulfillment_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  updated_at
}

"select columns of table \"brand_fulfillment_postal_options\""
enum brand_fulfillment_postal_options_select_column {
  "column name"
  brand_fulfillment_postal_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  postal_options_id
  "column name"
  shipping_fee
  "column name"
  updated_at
}

"select columns of table \"brand_fulfillment_postal_settings\""
enum brand_fulfillment_postal_settings_select_column {
  "column name"
  brand_fulfillment_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  updated_at
}

"select columns of table \"brand_fulfillment_settings\""
enum brand_fulfillment_settings_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  fulfillment_type
  "column name"
  id
  "column name"
  name
  "column name"
  updated_at
}

"select columns of table \"brand_passwords\""
enum brand_passwords_select_column {
  "column name"
  brand_id
  "column name"
  enabled
}

"select columns of table \"brands\""
enum brands_select_column {
  "column name"
  content
  "column name"
  created_at
  "column name"
  id
  "column name"
  name
  "column name"
  settings
  "column name"
  slug
  "column name"
  updated_at
}

enum building_access_types_enum {
  elevator
  ground_floor
  walkup
}

enum chat_channel_types_enum {
  livestream
  messaging
}

"select columns of table \"chat_channels\""
enum chat_channels_select_column {
  "column name"
  brand_id
  "column name"
  channel_external_identifier
  "column name"
  channel_type
  "column name"
  created_at
  "column name"
  key
  "column name"
  updated_at
}

"select columns of table \"collapsed_product_results\""
enum collapsed_product_results_select_column {
  "column name"
  part_id
  "column name"
  product_id
}

"select columns of table \"collection_media_groups\""
enum collection_media_groups_select_column {
  "column name"
  collection_id
  "column name"
  created_at
  "column name"
  media_group_id
  "column name"
  updated_at
}

enum collection_types_enum {
  manual
  rule
}

"select columns of table \"collections\""
enum collections_select_column {
  "column name"
  active
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  read_only
  "column name"
  slug
  "column name"
  type
  "column name"
  updated_at
}

"select columns of table \"collections_translations\""
enum collections_translations_select_column {
  "column name"
  collection_id
  "column name"
  description
  "column name"
  display_name
  "column name"
  id
  "column name"
  locale
}

"select columns of table \"condition_questions\""
enum condition_questions_select_column {
  "column name"
  addl_info_comment
  "column name"
  addl_info_comment_required
  "column name"
  addl_info_images
  "column name"
  addl_info_images_required
  "column name"
  addl_info_on_response_value
  "column name"
  addl_info_prompt
  "column name"
  brand_id
  "column name"
  depends_on_question_id
  "column name"
  depends_on_response_value
  "column name"
  fail_description
  "column name"
  fail_on_response_value
  "column name"
  help_text
  "column name"
  hidden
  "column name"
  id
  "column name"
  index
  "column name"
  listing_description_false
  "column name"
  listing_description_true
  "column name"
  question_set_id
  "column name"
  score_false
  "column name"
  score_true
  "column name"
  severity
  "column name"
  severity_on_response_value
  "column name"
  severity_text
  "column name"
  text
}

"select columns of table \"condition_questions_translations\""
enum condition_questions_translations_select_column {
  "column name"
  addl_info_prompt
  "column name"
  condition_question_id
  "column name"
  fail_description
  "column name"
  help_text
  "column name"
  id
  "column name"
  lang
  "column name"
  listing_description_false
  "column name"
  listing_description_true
  "column name"
  severity_text
  "column name"
  text
}

"unique or primary key constraints on table \"condition_responses\""
enum condition_responses_constraint {
  "unique or primary key constraint on columns \"id\""
  condition_question_responses_pkey
}

"select columns of table \"condition_responses\""
enum condition_responses_select_column {
  "column name"
  comment
  "column name"
  condition_question_id
  "column name"
  id
  "column name"
  listing_id
  "column name"
  response
  "column name"
  score
  "column name"
  severity
  "column name"
  user_id
}

"placeholder for update columns of table \"condition_responses\" (current role has no relevant permissions)"
enum condition_responses_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"credit\""
enum credit_select_column {
  "column name"
  credit_type
  "column name"
  currency_code
  "column name"
  currency_value
  "column name"
  id
}

enum credit_types_enum {
  conditional_coupon
  fixed_amount
  static_conditional_coupon
}

"ordering argument of a cursor"
enum cursor_ordering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}

"select columns of table \"dac7_verified_storefronts\""
enum dac7_verified_storefronts_select_column {
  "column name"
  storefront_id
}

"unique or primary key constraints on table \"email_signups\""
enum email_signups_constraint {
  "unique or primary key constraint on columns \"brand_id\", \"type\", \"email\""
  email_signups_email_brand_id_type_key
  "unique or primary key constraint on columns \"id\""
  email_signups_pkey
}

"update columns of table \"email_signups\""
enum email_signups_update_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  email
  "column name"
  id
  "column name"
  interest_in_selling
  "column name"
  payload
  "column name"
  type
}

"select columns of table \"external_sku_ids\""
enum external_sku_ids_select_column {
  "column name"
  brand_id
  "column name"
  external_id
  "column name"
  external_id_type
  "column name"
  id
  "column name"
  sku_id
}

"unique or primary key constraints on table \"form_submissions\""
enum form_submissions_constraint {
  "unique or primary key constraint on columns \"id\""
  form_submissions_pkey
}

"select columns of table \"form_submissions\""
enum form_submissions_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  form_id
  "column name"
  id
  "column name"
  submission_data
  "column name"
  user_id
}

"placeholder for update columns of table \"form_submissions\" (current role has no relevant permissions)"
enum form_submissions_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"forms\""
enum forms_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  schema
  "column name"
  type
}

"select columns of table \"fulfillment_intents\""
enum fulfillment_intents_select_column {
  "column name"
  id
}

"select columns of table \"fulfillment_services\""
enum fulfillment_services_select_column {
  "column name"
  id
  "column name"
  type
}

enum fulfillment_types_enum {
  archive_p2p
  archive_wms
  bergen
}

enum fulfillment_types_v2_enum {
  in_store_purchase
  pickup
  pickup_and_delivery
  pickup_point
  shipping
}

"select columns of table \"fulfillments\""
enum fulfillments_select_column {
  "column name"
  fulfillment_service_id
  "column name"
  id
}

enum gift_card_statuses_enum {
  disabled
  expired
  fulfilled
  redeemed
  submitted
  unsubmitted
}

"select columns of table \"gift_cards\""
enum gift_cards_select_column {
  "column name"
  external_id
  "column name"
  id
  "column name"
  status
  "column name"
  transaction_id
}

"select columns of table \"images\""
enum images_select_column {
  "column name"
  alt
  "column name"
  created_at
  "column name"
  href
  "column name"
  id
  "column name"
  updated_at
}

enum in_store_pickup_statuses_enum {
  awaiting_pickup
  awaiting_receipt
  cancelled
  picked_up
}

"select columns of table \"in_store_pickups\""
enum in_store_pickups_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  identifier
  "column name"
  shipping_information_id
  "column name"
  status
  "column name"
  updated_at
}

"unique or primary key constraints on table \"listing_auto_price_reduce\""
enum listing_auto_price_reduce_constraint {
  "unique or primary key constraint on columns \"listing_id\""
  listing_auto_price_reduce_listing_id_key
  "unique or primary key constraint on columns \"id\""
  listing_auto_price_reduce_pkey
}

"select columns of table \"listing_auto_price_reduce\""
enum listing_auto_price_reduce_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  interval_days
  "column name"
  listing_id
  "column name"
  min_price
  "column name"
  percent
  "column name"
  price_updated_at
  "column name"
  updated_at
  "column name"
  user_id
}

"update columns of table \"listing_auto_price_reduce\""
enum listing_auto_price_reduce_update_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  interval_days
  "column name"
  listing_id
  "column name"
  min_price
  "column name"
  percent
  "column name"
  price_updated_at
  "column name"
  updated_at
  "column name"
  user_id
}

"select columns of table \"listing_channels\""
enum listing_channels_select_column {
  "column name"
  brand_id
  "column name"
  display
  "column name"
  id
  "column name"
  platform_id
}

enum listing_event_types_enum {
  price_change
  sale_change
  status_change
  user_action
  visibility_change
}

"select columns of table \"listing_event_types\""
enum listing_event_types_select_column {
  "column name"
  type
}

"select columns of table \"listing_events\""
enum listing_events_select_column {
  "column name"
  event_type
  "column name"
  id
  "column name"
  listing_id
  "column name"
  listing_status
  "column name"
  payload
  "column name"
  timestamp
  "column name"
  value
}

"unique or primary key constraints on table \"listing_images\""
enum listing_images_constraint {
  "unique or primary key constraint on columns \"id\""
  listing_images_pkey
}

"select columns of table \"listing_images\""
enum listing_images_select_column {
  "column name"
  alt
  "column name"
  condition_response_id
  "column name"
  created_at
  "column name"
  hidden
  "column name"
  id
  "column name"
  index
  "column name"
  listing_id
  "column name"
  path
  "column name"
  src
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"listing_images\" (current role has no relevant permissions)"
enum listing_images_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"listing_metadata\""
enum listing_metadata_constraint {
  "unique or primary key constraint on columns \"key\", \"listing_id\""
  listing_metadata_listing_id_key_key
  "unique or primary key constraint on columns \"id\""
  listing_metadata_pkey
}

"select columns of table \"listing_metadata\""
enum listing_metadata_select_column {
  "column name"
  id
  "column name"
  key
  "column name"
  listing_id
  "column name"
  value
}

"update columns of table \"listing_metadata\""
enum listing_metadata_update_column {
  "column name"
  id
  "column name"
  key
  "column name"
  listing_id
  "column name"
  value
}

enum listing_platform_types_enum {
  archive
  ebay
}

"select columns of table \"listing_platforms\""
enum listing_platforms_select_column {
  "column name"
  id
  "column name"
  type
}

"select columns of table \"listing_relistings\""
enum listing_relistings_select_column {
  "column name"
  new_listing_id
  "column name"
  previous_listing_id
}

enum listing_review_outcomes_enum {
  approved
  changes_requested
  rejected
}

"unique or primary key constraints on table \"listing_reviews\""
enum listing_reviews_constraint {
  "unique or primary key constraint on columns \"id\""
  listing_reviews_pkey
}

"placeholder for update columns of table \"listing_reviews\" (current role has no relevant permissions)"
enum listing_reviews_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum listing_statuses_enum {
  accepted
  cancelled_by_buyer
  cancelled_by_channel_update
  cancelled_by_seller
  changes_requested
  completed
  delayed
  deleted
  delivered
  disputed
  dropped_off
  in_review
  listed
  lost
  never_picked_up
  payment_disputed_lost
  payment_processing
  pending_email_verification
  rejected
  return_delivered
  return_lost
  return_returned_to_sender
  return_shipped
  return_verified
  returned_to_sender
  shipped
  sold
  unlisted
}

"select columns of table \"listing_statuses\""
enum listing_statuses_select_column {
  "column name"
  status
}

"select columns of table \"listing_user_action_timestamp\""
enum listing_user_action_timestamp_select_column {
  "column name"
  id
  "column name"
  listing_id
  "column name"
  user_action_timestamp
}

enum listing_visibilities_enum {
  HIDDEN
  PUBLIC
}

"select columns of table \"listings\""
enum listings_select_column {
  "column name"
  brand_id
  "column name"
  bumped_at
  "column name"
  channel_id
  "column name"
  condition_score
  "column name"
  confidence_score
  "column name"
  created_at
  "column name"
  id
  "column name"
  original_price
  "column name"
  price
  "column name"
  product_id
  "column name"
  return_shipping_label_id
  "column name"
  seller_comment
  "column name"
  shipping_label_id
  "column name"
  sku_id
  "column name"
  status
  "column name"
  storefront_id
  "column name"
  unassociated_listing_data_id
  "column name"
  updated_at
  "column name"
  user_id
  "column name"
  visibility
}

"select columns of table \"mail_takebacks\""
enum mail_takebacks_select_column {
  "column name"
  id
  "column name"
  return_shipping_address_id
  "column name"
  shipping_label_id
  "column name"
  takeback_id
}

"select columns of table \"media_group_items\""
enum media_group_items_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  image_id
  "column name"
  media_group_id
  "column name"
  position
  "column name"
  updated_at
}

"select columns of table \"media_groups\""
enum media_groups_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  type
  "column name"
  updated_at
}

"unique or primary key constraints on table \"mobile_uploads\""
enum mobile_uploads_constraint {
  "unique or primary key constraint on columns \"id\""
  mobile_uploads_pkey
}

"select columns of table \"mobile_uploads\""
enum mobile_uploads_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  path
  "column name"
  session_id
}

"placeholder for update columns of table \"mobile_uploads\" (current role has no relevant permissions)"
enum mobile_uploads_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"order_addresses\""
enum order_addresses_constraint {
  "unique or primary key constraint on columns \"id\""
  order_addresses_pkey
}

"select columns of table \"order_addresses\""
enum order_addresses_select_column {
  "column name"
  address_line_1
  "column name"
  address_line_2
  "column name"
  administrative_area
  "column name"
  country
  "column name"
  id
  "column name"
  locality
  "column name"
  name
  "column name"
  organization
  "column name"
  phone_number
  "column name"
  postal_code
  "column name"
  user_id
}

"placeholder for update columns of table \"order_addresses\" (current role has no relevant permissions)"
enum order_addresses_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"unique or primary key constraints on table \"order_intent_items\""
enum order_intent_items_constraint {
  "unique or primary key constraint on columns \"id\""
  order_intent_items_pkey
  "unique or primary key constraint on columns \"purchasing_partner_id\", \"order_item_number\""
  order_intent_items_purchasing_partner_id_order_item_number_key
}

"select columns of table \"order_intent_items\""
enum order_intent_items_select_column {
  "column name"
  id
  "column name"
  listing_id
  "column name"
  order_intent_id
  "column name"
  price
  "column name"
  shipping_information_id
  "column name"
  tax
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"order_intent_items\" (current role has no relevant permissions)"
enum order_intent_items_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum order_intent_statuses_enum {
  blocked
  failed
  paid
  pending
}

"unique or primary key constraints on table \"order_intents\""
enum order_intents_constraint {
  "unique or primary key constraint on columns \"id\""
  order_intents_pkey
  "unique or primary key constraint on columns \"purchasing_partner_id\", \"order_number\""
  order_intents_purchasing_partner_id_order_number_key
}

"select columns of table \"order_intents\""
enum order_intents_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  order_number
  "column name"
  preferred_language
  "column name"
  shipping
  "column name"
  shipping_address_id
  "column name"
  shipping_tax
  "column name"
  status
  "column name"
  stripe_payment_id
  "column name"
  subtotal
  "column name"
  tax
  "column name"
  total
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"order_intents\" (current role has no relevant permissions)"
enum order_intents_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"order_items\""
enum order_items_constraint {
  "unique or primary key constraint on columns \"listing_id\""
  order_items_listing_id_key
  "unique or primary key constraint on columns \"id\""
  order_items_pkey
  "unique or primary key constraint on columns \"purchasing_partner_id\", \"order_item_number\""
  order_items_purchasing_partner_id_order_item_number_key
}

"select columns of table \"order_items\""
enum order_items_select_column {
  "column name"
  id
  "column name"
  listing_id
  "column name"
  order_id
  "column name"
  price
  "column name"
  tax
  "column name"
  user_id
}

"placeholder for update columns of table \"order_items\" (current role has no relevant permissions)"
enum order_items_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum order_statuses_enum {
  paid
  pending
  unpackable
  unpickable
}

"select columns of table \"order_statuses\""
enum order_statuses_select_column {
  "column name"
  status
}

"unique or primary key constraints on table \"orders\""
enum orders_constraint {
  "unique or primary key constraint on columns \"id\""
  orders_pkey
  "unique or primary key constraint on columns \"purchasing_partner_id\", \"order_number\""
  orders_purchasing_partner_id_order_number_key
}

"select columns of table \"orders\""
enum orders_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  order_number
  "column name"
  preferred_language
  "column name"
  shipping
  "column name"
  shipping_address_id
  "column name"
  shipping_tax
  "column name"
  status
  "column name"
  stripe_payment_id
  "column name"
  subtotal
  "column name"
  tax
  "column name"
  total
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"orders\" (current role has no relevant permissions)"
enum orders_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"orphan_condition_responses\""
enum orphan_condition_responses_constraint {
  "unique or primary key constraint on columns \"id\""
  orphan_condition_responses_pkey
}

"select columns of table \"orphan_condition_responses\""
enum orphan_condition_responses_select_column {
  "column name"
  comment
  "column name"
  condition_question_id
  "column name"
  id
  "column name"
  listing_id
  "column name"
  response
  "column name"
  score
  "column name"
  severity
  "column name"
  user_id
}

"placeholder for update columns of table \"orphan_condition_responses\" (current role has no relevant permissions)"
enum orphan_condition_responses_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"orphan_listings\""
enum orphan_listings_constraint {
  "unique or primary key constraint on columns \"id\""
  orphan_listings_pkey
}

"unique or primary key constraints on table \"orphan_listings_images\""
enum orphan_listings_images_constraint {
  "unique or primary key constraint on columns \"id\""
  orphan_listings_images_pkey
}

"select columns of table \"orphan_listings_images\""
enum orphan_listings_images_select_column {
  "column name"
  alt
  "column name"
  created_at
  "column name"
  id
  "column name"
  index
  "column name"
  listing_id
  "column name"
  path
  "column name"
  src
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"orphan_listings_images\" (current role has no relevant permissions)"
enum orphan_listings_images_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"orphan_listings\""
enum orphan_listings_select_column {
  "column name"
  brand_id
  "column name"
  color
  "column name"
  created_at
  "column name"
  description
  "column name"
  id
  "column name"
  product_link
  "column name"
  size
  "column name"
  title
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"orphan_listings\" (current role has no relevant permissions)"
enum orphan_listings_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum photo_enhancement_request_statuses_enum {
  complete
  error
  pending
}

"select columns of table \"photo_enhancement_requests\""
enum photo_enhancement_requests_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  external_id
  "column name"
  id
  "column name"
  image_id
  "column name"
  listing_image_id
  "column name"
  original_src
  "column name"
  product_image_id
  "column name"
  sku_image_id
  "column name"
  src
  "column name"
  status
  "column name"
  type
  "column name"
  updated_at
  "column name"
  user_id
}

enum photo_enhancement_types_enum {
  bg_removal
  bg_removal_ai
  bg_removal_manual
}

"unique or primary key constraints on table \"pos_events\""
enum pos_events_constraint {
  "unique or primary key constraint on columns \"id\""
  pos_events_pkey
}

"placeholder for update columns of table \"pos_events\" (current role has no relevant permissions)"
enum pos_events_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"select columns of table \"pos_stations\""
enum pos_stations_select_column {
  "column name"
  active
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  name
  "column name"
  retail_store_id
  "column name"
  updated_at
}

"select columns of table \"postal_options\""
enum postal_options_select_column {
  "column name"
  carrier
  "column name"
  created_at
  "column name"
  id
  "column name"
  method
  "column name"
  service
  "column name"
  updated_at
}

"select columns of table \"product_attribute_type_options\""
enum product_attribute_type_options_select_column {
  "column name"
  attribute_type_id
  "column name"
  attribute_type_option_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  product_id
  "column name"
  updated_at
}

"select columns of table \"product_colors\""
enum product_colors_select_column {
  "column name"
  color
  "column name"
  id
  "column name"
  product_id
  "column name"
  uid
}

"select columns of table \"product_colors_translations\""
enum product_colors_translations_select_column {
  "column name"
  color
  "column name"
  id
  "column name"
  lang
  "column name"
  product_color_id
}

"select columns of table \"product_images\""
enum product_images_select_column {
  "column name"
  alt
  "column name"
  created_at
  "column name"
  detail
  "column name"
  id
  "column name"
  index
  "column name"
  primary
  "column name"
  primary_hover
  "column name"
  product_id
  "column name"
  src
  "column name"
  swatch
  "column name"
  uid
  "column name"
  updated_at
}

"select columns of table \"product_images_translations\""
enum product_images_translations_select_column {
  "column name"
  alt
  "column name"
  id
  "column name"
  lang
  "column name"
  product_image_id
}

"select columns of table \"product_style_attribute_type_options\""
enum product_style_attribute_type_options_select_column {
  "column name"
  attribute_type_id
  "column name"
  attribute_type_option_id
  "column name"
  id
  "column name"
  product_style_id
}

enum product_style_sources_enum {
  imported
  user_generated
}

"select columns of table \"product_style_variant_media_groups\""
enum product_style_variant_media_groups_select_column {
  "column name"
  created_at
  "column name"
  media_group_id
  "column name"
  product_style_variant_id
  "column name"
  updated_at
}

"select columns of table \"product_style_variant_options\""
enum product_style_variant_options_select_column {
  "column name"
  product_style_variant_id
  "column name"
  variant_type_id
  "column name"
  variant_type_option_id
}

"select columns of table \"product_style_variants\""
enum product_style_variants_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  price
  "column name"
  product_style_id
  "column name"
  product_style_variant
  "column name"
  updated_at
}

"select columns of table \"product_styles_listed\""
enum product_styles_listed_select_column {
  "column name"
  latest_created_at
  "column name"
  max_price
  "column name"
  min_price
  "column name"
  product_style_id
  "column name"
  sizes
}

"select columns of table \"product_styles\""
enum product_styles_select_column {
  "column name"
  brand_id
  "column name"
  category_id
  "column name"
  disallow_listing
  "column name"
  id
  "column name"
  price
  "column name"
  product_style
  "column name"
  source
}

"select columns of table \"product_styles_translations\""
enum product_styles_translations_select_column {
  "column name"
  description
  "column name"
  id
  "column name"
  lang
  "column name"
  name
  "column name"
  product_style_id
}

"select columns of table \"product_tags\""
enum product_tags_select_column {
  "column name"
  id
  "column name"
  product_id
  "column name"
  value
}

"select columns of table \"products\""
enum products_select_column {
  "column name"
  brand_id
  "column name"
  care
  "column name"
  category_id
  "column name"
  color
  "column name"
  created_at
  "column name"
  current_price
  "column name"
  default_price_multiplier
  "column name"
  description
  "column name"
  disallow_listing
  "column name"
  fit
  "column name"
  id
  "column name"
  lowest_price
  "column name"
  material
  "column name"
  name
  "column name"
  normalized_name
  "column name"
  original_price
  "column name"
  parent_product_id
  "column name"
  product_style_id
  "column name"
  question_set_id
  "column name"
  sale_price
  "column name"
  super_category_id
  "column name"
  uid
  "column name"
  updated_at
  "column name"
  url
}

"select \"products_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"products\""
enum products_select_column_products_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  disallow_listing
}

"select \"products_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"products\""
enum products_select_column_products_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  disallow_listing
}

"select columns of table \"products_translations\""
enum products_translations_select_column {
  "column name"
  care
  "column name"
  color
  "column name"
  description
  "column name"
  fit
  "column name"
  id
  "column name"
  lang
  "column name"
  material
  "column name"
  name
  "column name"
  normalized_name
  "column name"
  product_id
}

"select columns of table \"question_sets\""
enum question_sets_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  name
  "column name"
  notes
  "column name"
  uid
  "column name"
  updated_at
}

"select columns of table \"retail_associates\""
enum retail_associates_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  retail_store_id
  "column name"
  store_number
  "column name"
  user_id
}

"select columns of table \"retail_store_addresses\""
enum retail_store_addresses_select_column {
  "column name"
  address_line_1
  "column name"
  address_line_2
  "column name"
  administrative_area
  "column name"
  country
  "column name"
  id
  "column name"
  locality
  "column name"
  name
  "column name"
  postal_code
}

"select columns of table \"retail_store_brand_uses\""
enum retail_store_brand_uses_select_column {
  "column name"
  brand_id
  "column name"
  retail_store_id
  "column name"
  use_case
}

enum retail_store_use_cases_enum {
  TAKEBACK
}

"select columns of table \"retail_stores\""
enum retail_stores_select_column {
  "column name"
  address_id
  "column name"
  created_at
  "column name"
  external_identifier
  "column name"
  id
  "column name"
  updated_at
}

"select columns of table \"retail_stores_translations\""
enum retail_stores_translations_select_column {
  "column name"
  id
  "column name"
  lang
  "column name"
  name
  "column name"
  retail_store_id
}

enum return_item_statuses_enum {
  damaged
  initiated
  missing
  received
  refunded
}

"unique or primary key constraints on table \"return_items\""
enum return_items_constraint {
  "unique or primary key constraint on columns \"id\""
  return_items_pkey
}

"select columns of table \"return_items\""
enum return_items_select_column {
  "column name"
  created_at
  "column name"
  damage_type
  "column name"
  id
  "column name"
  order_item_id
  "column name"
  return_id
  "column name"
  return_reason
  "column name"
  status
  "column name"
  updated_at
}

"placeholder for update columns of table \"return_items\" (current role has no relevant permissions)"
enum return_items_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum return_statuses_enum {
  initiated
  received
  refunded
}

"unique or primary key constraints on table \"returns\""
enum returns_constraint {
  "unique or primary key constraint on columns \"id\""
  returns_pkey
}

"select columns of table \"returns\""
enum returns_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  email
  "column name"
  id
  "column name"
  preferred_language
  "column name"
  return_shipping_address_id
  "column name"
  return_shipping_label_id
  "column name"
  status
  "column name"
  stripe_refund_id
  "column name"
  subtotal
  "column name"
  tax
  "column name"
  total
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"returns\" (current role has no relevant permissions)"
enum returns_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum review_statuses_enum {
  approved
  in_review
  rejected
}

enum roles_enum {
  admin_app_access
  curator
  inventory_manager
  listing_reviewer
  manager
  photo_enhancer
  previewer
  retail_associate
  verified_seller
  view_orphan_listings
}

"select columns of table \"roles\""
enum roles_select_column {
  "column name"
  role
}

"select columns of table \"search_page_translations\""
enum search_page_translations_select_column {
  "column name"
  created_at
  "column name"
  description
  "column name"
  display_name
  "column name"
  id
  "column name"
  locale
  "column name"
  search_page_id
  "column name"
  updated_at
}

"select columns of table \"search_pages\""
enum search_pages_select_column {
  "column name"
  active
  "column name"
  brand_id
  "column name"
  collection_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  slug
  "column name"
  updated_at
}

"select columns of table \"searchable_products_results\""
enum searchable_products_results_select_column {
  "column name"
  brand_id
  "column name"
  color
  "column name"
  color_mapping
  "column name"
  id
  "column name"
  name
  "column name"
  sizes
  "column name"
  skus
  "column name"
  type
}

"select columns of table \"searchable_products\""
enum searchable_products_select_column {
  "column name"
  color
  "column name"
  color_mapping
  "column name"
  id
  "column name"
  name
  "column name"
  product_brand_id
  "column name"
  sizes
  "column name"
  skus
  "column name"
  type
}

"unique or primary key constraints on table \"seller_ratings\""
enum seller_ratings_constraint {
  "unique or primary key constraint on columns \"listing_id\""
  seller_ratings_listing_id_key
  "unique or primary key constraint on columns \"id\""
  seller_ratings_pkey
}

"select columns of table \"seller_ratings\""
enum seller_ratings_select_column {
  "column name"
  comment
  "column name"
  created_at
  "column name"
  id
  "column name"
  listing_id
  "column name"
  rating
  "column name"
  seller_id
  "column name"
  storefront_id
  "column name"
  user_id
  "column name"
  user_rated
}

"update columns of table \"seller_ratings\""
enum seller_ratings_update_column {
  "column name"
  comment
  "column name"
  created_at
  "column name"
  id
  "column name"
  listing_id
  "column name"
  rating
  "column name"
  seller_id
  "column name"
  storefront_id
  "column name"
  user_id
  "column name"
  user_rated
}

enum shipping_carriers_enum {
  aptdeco
  canada_post
  colissimo
  dhl_express
  dpd_de
  dpd_uk
  evri
  fedex
  posti
  postnl
  postnord
  ups
  usps
}

"select columns of table \"shipping_carriers\""
enum shipping_carriers_select_column {
  "column name"
  carrier
}

"unique or primary key constraints on table \"shipping_information\""
enum shipping_information_constraint {
  "unique or primary key constraint on columns \"id\""
  shipping_information_pkey
}

"select columns of table \"shipping_information\""
enum shipping_information_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  shipping_method
  "column name"
  shipping_method_identifier
  "column name"
  updated_at
}

"update columns of table \"shipping_information\""
enum shipping_information_update_column {
  "column name"
  updated_at
}

"select columns of table \"shipping_labels_private\""
enum shipping_labels_private_select_column {
  "column name"
  id
  "column name"
  label_url
  "column name"
  metadata
}

"select columns of table \"shipping_labels\""
enum shipping_labels_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  listing_id
  "column name"
  shipping_carrier
  "column name"
  shipping_service
  "column name"
  shipping_service_id
  "column name"
  status
  "column name"
  tracking_number
  "column name"
  tracking_url
  "column name"
  updated_at
  "column name"
  user_id
}

enum shipping_methods_enum {
  aptdeco
  canada_post_regular_parcel
  colissimo_home
  dhl_express_worldwide
  dpd_de_classic
  dpd_uk_next_day
  fedex_2_day
  fedex_ground
  fedex_home_delivery
  fedex_priority_overnight
  fedex_standard_overnight
  hermes_uk_parcelshop_dropoff
  in_person_fulfillment
  in_store_pickup
  in_store_purchase
  posti_home_parcel
  posti_postal_parcel
  postnl_standard
  postnord_my_pack_collect
  ups_ground
  ups_surepost
  usps_priority
}

enum shipping_services_enum {
  dpd
  fedex_cafe
  posti
  postnl
  postnord
  shippo
}

enum shipping_statuses_enum {
  AWAITING_PICKUP
  DELIVERED
  FAILURE
  PRE_TRANSIT
  RETURNED
  TRANSIT
  UNKNOWN
}

"select columns of table \"shipping_statuses\""
enum shipping_statuses_select_column {
  "column name"
  status
}

"select columns of table \"short_links\""
enum short_links_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  identifier
  "column name"
  path
  "column name"
  query_params
  "column name"
  updated_at
}

"select columns of table \"sku_images\""
enum sku_images_select_column {
  "column name"
  alt
  "column name"
  created_at
  "column name"
  detail
  "column name"
  id
  "column name"
  index
  "column name"
  primary
  "column name"
  primary_hover
  "column name"
  sku_id
  "column name"
  src
  "column name"
  swatch
  "column name"
  uid
  "column name"
  updated_at
}

"select columns of table \"sku_images_translations\""
enum sku_images_translations_select_column {
  "column name"
  alt
  "column name"
  id
  "column name"
  lang
  "column name"
  sku_image_id
}

"select columns of table \"sku_variant_type_options\""
enum sku_variant_type_options_select_column {
  "column name"
  id
  "column name"
  sku_id
  "column name"
  variant_type_id
  "column name"
  variant_type_option_id
}

"select columns of table \"skus\""
enum skus_select_column {
  "column name"
  brand_id
  "column name"
  care
  "column name"
  created_at
  "column name"
  description
  "column name"
  dimensions
  "column name"
  dimensions_lite
  "column name"
  id
  "column name"
  is_material
  "column name"
  luggage_sleeve
  "column name"
  new_logo
  "column name"
  original_price
  "column name"
  product_id
  "column name"
  product_style_id
  "column name"
  size
  "column name"
  sku
  "column name"
  uid
  "column name"
  updated_at
  "column name"
  weight
  "column name"
  weight_unit
}

"select columns of table \"skus_translations\""
enum skus_translations_select_column {
  "column name"
  care
  "column name"
  description
  "column name"
  dimensions
  "column name"
  dimensions_lite
  "column name"
  id
  "column name"
  lang
  "column name"
  size
  "column name"
  sku_id
}

"select columns of table \"storefront_fulfillment_in_store_options\""
enum storefront_fulfillment_in_store_options_select_column {
  "column name"
  brand_fulfillment_in_store_options_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  shipping_fee
  "column name"
  storefront_fulfillment_in_store_settings_id
  "column name"
  updated_at
}

"select columns of table \"storefront_fulfillment_in_store_settings\""
enum storefront_fulfillment_in_store_settings_select_column {
  "column name"
  brand_fulfillment_in_store_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  storefront_fulfillment_settings_id
  "column name"
  updated_at
}

"select columns of table \"storefront_fulfillment_postal_options\""
enum storefront_fulfillment_postal_options_select_column {
  "column name"
  brand_fulfillment_postal_options_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  shipping_fee
  "column name"
  storefront_fulfillment_postal_settings_id
  "column name"
  updated_at
}

"select columns of table \"storefront_fulfillment_postal_settings\""
enum storefront_fulfillment_postal_settings_select_column {
  "column name"
  brand_fulfillment_postal_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  storefront_fulfillment_settings_id
  "column name"
  updated_at
}

"select columns of table \"storefront_fulfillment_settings\""
enum storefront_fulfillment_settings_select_column {
  "column name"
  brand_fulfillment_settings_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  storefront_id
  "column name"
  updated_at
}

"select columns of table \"storefront_images\""
enum storefront_images_select_column {
  "column name"
  alt
  "column name"
  created_at
  "column name"
  id
  "column name"
  path
  "column name"
  src
  "column name"
  updated_at
}

"select columns of table \"storefront_payout_settings\""
enum storefront_payout_settings_select_column {
  "column name"
  cashout_percent
  "column name"
  store_credit_percent
  "column name"
  stripe_account_id
}

"unique or primary key constraints on table \"storefront_reviews\""
enum storefront_reviews_constraint {
  "unique or primary key constraint on columns \"order_id\", \"storefront_id\""
  storefront_reviews_order_id_storefront_id_key
  "unique or primary key constraint on columns \"id\""
  storefront_reviews_pkey
}

"select columns of table \"storefront_reviews\""
enum storefront_reviews_select_column {
  "column name"
  comment
  "column name"
  created_at
  "column name"
  id
  "column name"
  order_id
  "column name"
  rating
  "column name"
  status
  "column name"
  storefront_id
  "column name"
  updated_at
}

"placeholder for update columns of table \"storefront_reviews\" (current role has no relevant permissions)"
enum storefront_reviews_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

enum storefront_statuses_enum {
  active
  inactive
}

enum storefront_types_enum {
  business
  personal
}

"select columns of table \"storefront_verified_attributes\""
enum storefront_verified_attributes_select_column {
  "column name"
  attribute
  "column name"
  storefront_id
}

"select columns of table \"storefronts\""
enum storefronts_select_column {
  "column name"
  bio
  "column name"
  brand_id
  "column name"
  hide_address
  "column name"
  id
  "column name"
  links
  "column name"
  logo_id
  "column name"
  name
  "column name"
  primary_address_id
  "column name"
  slug
  "column name"
  status
  "column name"
  type
  "column name"
  verified
}

enum takeback_item_statuses_enum {
  accepted
  not_accepted
  pending
}

"select columns of table \"takeback_items\""
enum takeback_items_select_column {
  "column name"
  created_at
  "column name"
  credit_id
  "column name"
  estimate_credit_id
  "column name"
  form_submission_id
  "column name"
  id
  "column name"
  lpn
  "column name"
  status
  "column name"
  style_code
  "column name"
  takeback_id
  "column name"
  updated_at
}

enum takeback_statuses_enum {
  cancelled
  completed
  initiated
  ready
  received
}

"select columns of table \"takebacks\""
enum takebacks_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  credit_id
  "column name"
  estimate_credit_id
  "column name"
  id
  "column name"
  status
  "column name"
  store_number
  "column name"
  takeback_number
  "column name"
  transaction_id
  "column name"
  updated_at
  "column name"
  user_id
}

enum transaction_types_enum {
  archive_credit
  cash_out
  credit
  debit
  sale
  store_credit
  takeback_external_credit
  takeback_external_credit_reversed
}

"select columns of table \"transaction_types\""
enum transaction_types_select_column {
  "column name"
  type
}

"select columns of table \"transactions\""
enum transactions_select_column {
  "column name"
  amount
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  fee
  "column name"
  id
  "column name"
  listing_id
  "column name"
  type
  "column name"
  user_id
}

"select columns of table \"unassociated_listing_data_schemas\""
enum unassociated_listing_data_schemas_select_column {
  "column name"
  brand_id
  "column name"
  category_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  question_set_id
  "column name"
  schema
  "column name"
  updated_at
}

"select columns of table \"unassociated_listing_data\""
enum unassociated_listing_data_select_column {
  "column name"
  brand_id
  "column name"
  category_id
  "column name"
  created_at
  "column name"
  custom_metadata
  "column name"
  description
  "column name"
  id
  "column name"
  name
  "column name"
  original_price
  "column name"
  storefront_id
  "column name"
  updated_at
  "column name"
  user_id
  "column name"
  variant_data
}

"select columns of table \"unique_listings_results\""
enum unique_listings_results_select_column {
  "column name"
  brand_id
  "column name"
  color
  "column name"
  color_mapping
  "column name"
  latest_created_at
  "column name"
  max_price
  "column name"
  min_price
  "column name"
  name
  "column name"
  priority
  "column name"
  product_id
  "column name"
  sizes
  "column name"
  type
}

"select columns of table \"unique_listings_results_tnf\""
enum unique_listings_results_tnf_select_column {
  "column name"
  brand_id
  "column name"
  color
  "column name"
  color_mapping
  "column name"
  latest_created_at
  "column name"
  max_price
  "column name"
  min_price
  "column name"
  name
  "column name"
  priority
  "column name"
  product_id
  "column name"
  size_groupings
  "column name"
  sizes
  "column name"
  tags
  "column name"
  type
}

"select columns of table \"unique_tags_results\""
enum unique_tags_results_select_column {
  "column name"
  value
}

"unique or primary key constraints on table \"user_addresses\""
enum user_addresses_constraint {
  "unique or primary key constraint on columns \"id\""
  user_addresses_pkey
}

"select columns of table \"user_addresses\""
enum user_addresses_select_column {
  "column name"
  address_line_1
  "column name"
  address_line_2
  "column name"
  administrative_area
  "column name"
  building_access
  "column name"
  country
  "column name"
  created_at
  "column name"
  floors
  "column name"
  id
  "column name"
  locality
  "column name"
  name
  "column name"
  organization
  "column name"
  phone_number
  "column name"
  postal_code
  "column name"
  updated_at
  "column name"
  user_id
}

"update columns of table \"user_addresses\""
enum user_addresses_update_column {
  "column name"
  address_line_1
  "column name"
  address_line_2
  "column name"
  administrative_area
  "column name"
  building_access
  "column name"
  country
  "column name"
  created_at
  "column name"
  floors
  "column name"
  id
  "column name"
  locality
  "column name"
  name
  "column name"
  organization
  "column name"
  phone_number
  "column name"
  postal_code
  "column name"
  updated_at
}

"unique or primary key constraints on table \"user_alerts\""
enum user_alerts_constraint {
  "unique or primary key constraint on columns \"id\""
  user_alerts_id_key
  "unique or primary key constraint on columns \"id\""
  user_alerts_pkey
  "unique or primary key constraint on columns \"uid\""
  user_alerts_uid_key
}

"select columns of table \"user_alerts\""
enum user_alerts_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  product_id
  "column name"
  sku_id
  "column name"
  uid
  "column name"
  user_id
}

"update columns of table \"user_alerts\""
enum user_alerts_update_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  product_id
  "column name"
  sku_id
  "column name"
  uid
  "column name"
  user_id
}

"select columns of table \"user_balances\""
enum user_balances_select_column {
  "column name"
  brand_id
  "column name"
  current_balance
  "column name"
  id
  "column name"
  storefront_id
  "column name"
  user_id
}

"unique or primary key constraints on table \"user_favorites\""
enum user_favorites_constraint {
  "unique or primary key constraint on columns \"id\""
  user_favorites_pkey
}

"select columns of table \"user_favorites\""
enum user_favorites_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  listing_id
  "column name"
  product_id
  "column name"
  user_id
}

"update columns of table \"user_favorites\""
enum user_favorites_update_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  listing_id
  "column name"
  product_id
  "column name"
  user_id
}

"select columns of table \"user_metadata\""
enum user_metadata_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  key
  "column name"
  user_id
  "column name"
  value
}

"select columns of table \"user_roles\""
enum user_roles_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  role
  "column name"
  user_id
}

enum user_verification_check_statuses_enum {
  canceled
  error
  processing
  redacted
  requires_input
  unverified
  verified
}

"unique or primary key constraints on table \"user_verification_checks\""
enum user_verification_checks_constraint {
  "unique or primary key constraint on columns \"id\""
  user_verification_checks_pkey
}

"select columns of table \"user_verification_checks\""
enum user_verification_checks_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  status
  "column name"
  stripe_verification_response_id
  "column name"
  stripe_verification_session_id
  "column name"
  updated_at
  "column name"
  user_id
}

"placeholder for update columns of table \"user_verification_checks\" (current role has no relevant permissions)"
enum user_verification_checks_update_column {
  "placeholder (do not use)"
  _PLACEHOLDER
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
  "unique or primary key constraint on columns \"auth_tenant_id\", \"email\""
  users_email_key
  "unique or primary key constraint on columns \"id\""
  users_pkey
}

"select columns of table \"users_private\""
enum users_private_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  current_balance
  "column name"
  default_shipping_address_id
  "column name"
  email
  "column name"
  is_manager
  "column name"
  stripe_account_id
  "column name"
  updated_at
  "column name"
  user_id
}

"select columns of table \"users\""
enum users_select_column {
  "column name"
  first_name
  "column name"
  id
  "column name"
  last_name
  "column name"
  state
}

"update columns of table \"users\""
enum users_update_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  default_shipping_address_id
  "column name"
  email
  "column name"
  first_name
  "column name"
  id
  "column name"
  last_name
  "column name"
  state
  "column name"
  stripe_account_id
  "column name"
  updated_at
}

"select columns of table \"variant_type_options\""
enum variant_type_options_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  option
  "column name"
  updated_at
  "column name"
  variant_type_id
}

"select columns of table \"variant_type_options_translations\""
enum variant_type_options_translations_select_column {
  "column name"
  display
  "column name"
  id
  "column name"
  lang
  "column name"
  variant_type_option_id
}

"select columns of table \"variant_types\""
enum variant_types_select_column {
  "column name"
  brand_id
  "column name"
  id
  "column name"
  type
}

"select columns of table \"variant_types_translations\""
enum variant_types_translations_select_column {
  "column name"
  display
  "column name"
  id
  "column name"
  lang
  "column name"
  variant_type_id
}

enum verified_identity_attributes_enum {
  address
  name
  tax_id
}

"select columns of table \"wms_items\""
enum wms_items_select_column {
  "column name"
  id
  "column name"
  listing_id
  "column name"
  lpn
}

"select columns of table \"workflow_definitions\""
enum workflow_definitions_select_column {
  "column name"
  callbacks
  "column name"
  created_at
  "column name"
  id
  "column name"
  schema
  "column name"
  type
  "column name"
  updated_at
}

enum workflow_item_event_types_enum {
  state_change
}

"select columns of table \"workflow_item_event_types\""
enum workflow_item_event_types_select_column {
  "column name"
  type
}

"select columns of table \"workflow_item_events\""
enum workflow_item_events_select_column {
  "column name"
  event_type
  "column name"
  id
  "column name"
  payload
  "column name"
  timestamp
  "column name"
  value
  "column name"
  workflow_item_id
}

"select columns of table \"workflow_items\""
enum workflow_items_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  data
  "column name"
  id
  "column name"
  state
  "column name"
  updated_at
  "column name"
  workflow_definition_id
  "column name"
  workflow_id
}

"select columns of table \"workflows\""
enum workflows_select_column {
  "column name"
  brand_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  updated_at
  "column name"
  workflow_definition_id
}

scalar bigint

scalar float8

scalar geography

scalar geometry

scalar json

scalar jsonb

scalar numeric

scalar timestamptz

scalar uuid

input AddVariantOptionsToSkuInput {
  brand_id: uuid!
  sku_id: uuid!
  variant_options: [VariantOptionInput!]!
}

input AddressInput {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  country: String
  locality: String!
  name: String!
  phone_number: String
  postal_code: String!
}

input AddressInputV2 {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  building_access: String
  country: String!
  floors: Int
  locality: String!
  name: String!
  phone_number: String
  postal_code: String!
}

input AttributeOptionTranslationInput {
  display: String!
  lang: String!
}

input AttributeValueInput {
  id: uuid!
  type_id: uuid!
  value: String!
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input BulkCreateListingsInput {
  brand_id: uuid!
  listings: [CreateListingInput!]!
  storefront_id: String
  user_id: String
}

input CalculateCartEstimatesV2Input {
  brand_id: uuid!
  cart: CartInputV2!
  customer_information: CartCustomerInformationV2
}

input CalculateCartEstimatesV3Input {
  brand_id: uuid!
  cart: CartInputV3!
  customer_information: CartCustomerInformationV2
}

input CancelOrderInput {
  email: String
  order_id: uuid!
  order_items: [CancelOrderItemInput]!
}

input CancelOrderItemInput {
  id: uuid!
  reason: String
}

input CancelStoreTakebackInput {
  retail_store_id: uuid
  takeback_id: uuid!
}

input CartCustomerInformation {
  email: String
  preferred_language: String!
  shipping_address: AddressInput
}

input CartCustomerInformationV2 {
  email: String
  estimate_postal_code: EstimatePostalCodeInput
  shipping_address: AddressInputV2
}

input CartEstimates {
  shipping_amount: Int!
  storefront_carts: [CartEstimatesStorefrontCart!]!
}

input CartEstimatesCartItem {
  id: uuid!
}

input CartEstimatesStorefrontCart {
  items: [CartEstimatesCartItem!]!
  shipping_amount: Int!
  storefront_id: uuid!
}

input CartInput {
  discount_code: String
  items: [CartItemInput!]!
}

input CartInputV2 {
  discount_codes: [String!]!
  items: [CartItemInputV2!]!
}

input CartInputV3 {
  discount_codes: [String!]!
  items: [CartItemInputV3!]!
}

input CartItemInput {
  listing_id: uuid!
  shipping_information: CartItemShippingInformation
}

input CartItemInputV2 {
  listing_id: uuid!
  shipping_information: CartItemShippingInformation
}

input CartItemInputV3 {
  listing_id: uuid!
  selected_fulfillment_option_id: uuid
}

input CartItemShippingInformation {
  shipping_method: String!
  shipping_method_identifier: String
}

input CartPreCalculatedAttemptedDiscountCode {
  discount_amount: Int!
  discount_id: uuid!
}

input CartPreCalculatedItemValues {
  listing_id: uuid!
  price: Int
  shipping_information_id: uuid
  tax: Int
}

input CartPreCalculatedShippingInformation {
  id: uuid!
  shipping_method: String!
  shipping_method_identifier: String
}

input CartPreCalculatedValues {
  attempted_discount_codes: [CartPreCalculatedAttemptedDiscountCode!]
  cart_items: [CartPreCalculatedItemValues!]
  discount_total: Int
  shipping_information_objects: [CartPreCalculatedShippingInformation!]
  subtotal: Int
  tax: Int
  total: Int
}

input CategoryInfoInput {
  id: String!
  name: String!
  question_set_id: String!
}

input CheckPostalCodeRequest {
  country: String!
  postal_code: String!
  specific_region: SpecificRegion
}

input CheckoutCustomerInformationV2 {
  email: String!
  preferred_language: String!
  shipping_address: AddressInputV2
}

input CheckoutEstimatesV2 {
  shipping: DiscountableMoneyInput!
  subtotal: DiscountableMoneyInput!
  tax: MoneyInput!
  total: DiscountableMoneyInput!
}

input CheckoutFulfillmentGroupInput {
  fulfillment_option_id: uuid!
  items: [CheckoutItemInputV2!]!
  price: DiscountableMoneyInput!
}

input CheckoutInputV2 {
  discount_codes: [String!]!
  fulfillment_groups: [CheckoutFulfillmentGroupInput!]!
}

input CheckoutItemInputV2 {
  fulfillment_group_id: uuid
  listing_id: uuid!
  price: DiscountableMoneyInput!
}

input CollectionDetailsInput {
  description: String
  display_name: String!
  locale: String!
}

input CollectionMediaInput {
  alt: String
  href: String!
  position: Int!
}

input CreateCollectionInput {
  active: Boolean
  brand_id: uuid!
  collection_type: CollectionType!
  definition: jsonb
  media: [CollectionMediaInput!]
  slug: String!
  translations: [CollectionDetailsInput!]!
}

input CreateCreditCardHoldInput {
  amount: Int!
  currency: String
  idempotencyKey: String
  slug: String!
  statement_descriptor: String
}

input CreateDirectChatInput {
  auth_tenant_id: String
  brand_id: uuid!
  email: String!
  first_name: String
  language: String
  last_name: String
  listing_id: uuid!
}

input CreateDirectMessageInput {
  auth_tenant_id: String
  brand_id: uuid!
  email: String!
  first_name: String
  language: String
  last_name: String
  listing_id: uuid!
}

input CreateFormSubmissionInput {
  brand_id: uuid!
  form_id: uuid!
  submission_data: jsonb!
}

input CreateListingInput {
  condition_score: Int
  price: Int
  seller_comment: String
  sku_id: uuid!
  status: String
}

input CreateMailTakebackInput {
  return_shipping_address: AddressInput!
  storefront_id: uuid
  takeback_items: [CreateTakebackItemInput!]!
}

input CreateManualCollectionInput {
  brand_id: uuid!
  items: ManualCollectionItemsInput!
}

input CreateOrUpdateStorefrontInput {
  bio: String
  brand_id: String!
  email: String!
  enabled_in_store_fulfillment_option_ids: [String!]
  hide_address: Boolean
  links: jsonb
  logo: jsonb
  name: String!
  phone_number: String
  primary_address: jsonb
  slug: String
  storefront_id: String
}

input CreatePaymentIntentInput {
  amount: Int!
  currency: String
  idempotencyKey: String
  order_intent_id: String
  payment_method: String
  shipping_address: AddressInput
  slug: String!
  statement_descriptor: String
}

input CreateProductImagesInput {
  brand_id: String!
  product_id: uuid!
  product_images: [jsonb!]!
}

input CreateProductStyleInput {
  attribute_values: [AttributeValueInput!]!
  brand_id: String!
  product_style: jsonb!
  products: [jsonb!]
}

input CreateProductStyleV2Input {
  attribute_values: [AttributeValueInput!]
  brand_id: String!
  category_id: String
  disallow_listing: Boolean
  new_attribute_values: [NewAttributeInput!]
  price: Int!
  product_style: String!
  translations: [ProductStylesTranslationsInput!]!
}

input CreateProductStyleVariantInput {
  brand_id: uuid!
  media_groups: [MediaGroupInput!]
  price: Int
  product_style_id: uuid!
  product_style_variant: String!
  product_style_variant_options: [ProductStyleVariantOptionsInput!]!
}

input CreateProductStyleVariantMediaGroupsInput {
  brand_id: uuid!
  media_groups: [MediaGroupInput!]!
  product_style_variant_id: uuid!
}

input CreateProductsInput {
  brand_id: String!
  product_style_id: uuid!
  products: [jsonb!]!
}

input CreateSearchPageCustomPriorityInput {
  type: String!
  value: jsonb!
}

input CreateSearchPageInput {
  active: Boolean!
  brand_id: uuid!
  definition: jsonb!
  order_by: CreateSearchPageOrderByInput!
  slug: String!
  translations: [SearchPageTranslationInput!]!
}

input CreateSearchPageOrderByInput {
  custom_priority: CreateSearchPageCustomPriorityInput
  rule_priority: [jsonb!]
}

input CreateSingleSkuInput {
  brand_id: uuid!
  category_id: uuid!
  color: String!
  description: String!
  extra_product_data: String
  extra_product_translations_data: String
  extra_sku_data: String
  extra_sku_translations_data: String
  images: [String!]
  language_code: String!
  name: String!
  price: Int!
  product_tag_values: [String!]
  size: String!
  storefront_id: uuid
}

input CreateSkuImagesInput {
  brand_id: String!
  sku_id: uuid!
  sku_images: [SkuImageInput!]!
}

input CreateSkusInput {
  brand_id: String!
  product_id: uuid!
  skus: [jsonb!]!
}

input CreateStoreDonationInput {
  count: Int!
  retail_store_id: uuid!
}

input CreateStoreTakebackInput {
  metadata: StoreTakebackMetadataInput
  retail_store_id: uuid!
  takeback_items: [CreateTakebackItemInputV2!]!
  user: StoreTakebackUser!
}

input CreateStripeAccountInput {
  business_type: String
  country: String
  email: String!
  first_name: String!
  last_name: String!
  slug: String!
  storefront_id: String
  uid: String!
}

input CreateTakebackItemInput {
  credit_type: String
  form: FormSubmissionInput
  form_id: uuid
  form_submission_data: jsonb
  item_id: uuid!
  lpn: String
  product_id: String
  product_style_id: String
  sku_id: String
  style_code: String
}

input CreateTakebackItemInputV2 {
  credit_type: String
  form: FormSubmissionInput
  item_id: uuid!
  lpn: String
  product_id: String
  product_style_id: String
  sku_id: String
  style_code: String
}

input CreateVariantSkusInput {
  brand_id: uuid!
  product_style_id: uuid!
  skus: [SkuInput!]!
}

input CreateVariantTypeOptionInput {
  brand_id: uuid!
  option: String!
  translations: [VariantTypeOptionTranslationInput!]!
  variant_type_id: uuid!
}

input CreateVerificationSessionInput {
  brand_slug: String!
  user_id: String!
  user_verification_check_id: uuid!
}

input DeleteCollectionInput {
  brand_id: uuid!
  collection_id: uuid!
}

input DeleteProductImagesInput {
  brand_id: String!
  product_image_ids: [uuid!]!
}

input DeleteProductStyleVariantsInput {
  brand_id: String!
  product_style_variant_ids: [uuid!]!
}

input DeleteProductsInput {
  brand_id: String!
  product_ids: [uuid!]!
}

input DeleteSearchPageInput {
  brand_id: uuid!
  id: uuid!
}

input DeleteSkuImagesInput {
  brand_id: String!
  sku_image_ids: [uuid!]!
}

input DeleteSkusInput {
  brand_id: String!
  sku_ids: [uuid!]!
}

input DeleteVariantOptionFromSkuInput {
  brand_id: uuid!
  sku_id: uuid!
  variant_type_id: uuid!
  variant_type_option_id: uuid!
}

input DetectLanguageRequest {
  inputText: String!
}

input DiscountableMoneyInput {
  discounted: MoneyInput!
  original: MoneyInput!
}

input DonationItemInput {
  comment: String
  product_id: uuid!
}

input EditListingImageOrderInput {
  brand_id: uuid!
  images: jsonb!
  listing_id: uuid!
}

input EntityDistanceRequest {
  brandId: String!
  sourceLocation: SourceLocationInput!
  targetIds: [EntityIdInput!]!
  unitSystem: String!
}

input EntityIdInput {
  id: uuid!
  type: String!
}

input EstimatePostalCodeInput {
  country: String!
  postal_code: String!
}

input FormSubmissionInput {
  id: uuid!
  submission_data: jsonb!
}

input GenerateTestEmailInput {
  brand_id: String!
  locale: String!
  template_name: String!
  test_data: jsonb!
}

input GetAttributeOptionsInput {
  attribute_type: String!
  brand_id: uuid!
  locale: String!
}

input GetCheckoutFulfillmentOptionsInput {
  brand_id: uuid!
}

input GetCollectionDefinitionInput {
  brand_id: uuid!
  collection_id: uuid!
}

input GetFormSubmissionInput {
  brand_id: uuid!
  form_submission_id: uuid!
}

input GetFormSubmissionsRequest {
  brand_id: uuid!
  form_id: uuid!
  has_keys: [String]
  limit: Int!
  offset: Int!
}

input GetItemFulfillmentOptionsInput {
  brand_id: uuid!
  customer_information: ItemFulfillmentCustomerInformation
  item_id: String!
  item_type: ItemFulfillmentType!
}

input GetManualCollectionItemsInput {
  brand_id: uuid!
  collection_id: uuid!
}

input GetOrCreateStreamChatUserInput {
  brand_id: uuid!
}

input GetProductStyleSkusInput {
  brand_id: uuid!
  product_style_id: uuid!
}

input GetProductsXmlSitemapInput {
  brand_id: uuid!
}

input GetReturnEstimateInput {
  brand_id: uuid!
  return_items: [ReturnItemInput!]!
}

input GetSearchPageSortInput {
  brand_id: uuid!
  search_page_id: uuid!
}

input GetStoreTakebackInput {
  retail_store_id: uuid
  takeback_id: uuid!
}

input GetTakebackEstimateInput {
  takeback_items: [TakebackEstimateItemInput!]!
  takeback_type: TakebackType
}

input GetTakebackItemEstimatesInput {
  item_ids: [TakebackItemIdInput!]!
  takeback_type: TakebackType!
}

input GetUserPreferredLanguageInput {
  brand_id: String!
}

input GetVariantTypeOptionsInput {
  brand_id: uuid!
  variant_type_id: uuid!
}

input GetVariantsInput {
  brand_id: uuid!
}

input GetWorkflowDefinitionV1Input {
  brand_id: uuid!
  workflow_definition_id: uuid!
}

input GetWorkflowItemInput {
  brand_id: uuid!
  workflow_item_id: uuid!
}

input GetWorkflowItemsInput {
  brand_id: uuid!
  request: jsonb!
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input ItemFulfillmentCustomerInformation {
  email: String
  estimate_postal_code: EstimatePostalCodeInput
  shipping_address: AddressInputV2
}

input LinkExternalAccountInput {
  brand_id: uuid!
  email: String
  external_id: String
  storefront_id: uuid
}

input ListingReviewInput {
  comments: String
  outcome: String!
}

input LookupTakebacksDateRange {
  end_date: timestamptz
  start_date: timestamptz
}

input LookupTakebacksInput {
  limit: Int!
  locale: String!
  offset: Int!
  order_by: LookupTakebacksOrderBy!
  query: LookupTakebacksQuery!
  retail_store_id: uuid
}

input LookupTakebacksQuery {
  date_range: LookupTakebacksDateRange
  free_text_search: String
  retail_store_ids: [String!]
}

input ManualCollectionItemsInput {
  listing_ids: [uuid!]
  product_ids: [uuid!]
  product_style_ids: [uuid!]
  product_style_variant_ids: [uuid!]
}

input MediaGroupInput {
  items: [MediaGroupItemsInput!]!
  type: String!
}

input MediaGroupItemsInput {
  alt: String
  href: String!
  position: Int!
}

input MoneyInput {
  amount: Int!
  currency: String!
}

input NewAttributeInput {
  option: String!
  option_translations: [AttributeOptionTranslationInput!]!
  type: String!
}

input ProcessCartCheckoutInput {
  brand_id: uuid!
  cart: CartInput!
  cart_estimates: CartEstimates!
  customer_information: CartCustomerInformation!
  payment_method: String!
  pre_calculated_values: CartPreCalculatedValues
}

input ProcessCartCheckoutInputV2 {
  brand_id: uuid!
  cart: CheckoutInputV2!
  cart_estimates: CheckoutEstimatesV2!
  customer_information: CheckoutCustomerInformationV2!
  payment_method: String!
}

input ProductImageUpdateInput {
  id: uuid!
  index: Int!
  primary: Boolean!
}

input ProductStyleVariantOptionsInput {
  variant_type_id: uuid!
  variant_type_option_id: uuid!
}

input ProductStylesTranslationsInput {
  description: String
  lang: String!
  name: String!
}

input ProvisionUserInput {
  brand_id: String!
  first_name: String
  id_token: String!
  language: String
  last_name: String
}

input RecommendPriceInput {
  brandId: uuid!
  conditionInformation: jsonb!
  productInformation: jsonb!
}

input RecommendationsInput {
  brandId: uuid!
  context: jsonb!
  limit: Int!
  recommendationConfiguration: jsonb!
}

input RefreshStreamChatTokenInput {
  brand_id: uuid!
  stream_chat_user_id: String!
  verification_code: String
}

input ReissueStoreTakebackCreditInput {
  retail_store_id: uuid
  takeback_id: uuid!
}

input RequestPasswordResetEmailInput {
  brand_id: uuid!
  email: String!
}

input RequestPasswordResetEmailInputV2 {
  auth_tenant_id: String!
  email: String!
}

input ResetPasswordInput {
  auth_tenant_id: String
  email: String!
  password: String!
  token: String!
}

input ResolveExternalIdInput {
  brandId: uuid!
  externalId: String!
  externalIdType: String!
}

input ReturnItemInput {
  order_item_id: uuid!
  return_reason: String
}

input SearchPageTranslationInput {
  description: String
  display_name: String!
  locale: String!
}

input SellerCloneListingInput {
  brandId: uuid!
  listingId: uuid!
  updates: SellerCloneListingUpdates
}

input SellerCloneListingUpdates {
  channelId: uuid
}

input SetBrandSortInput {
  rule_priorities: [jsonb!]!
}

input SetListingImagesInput {
  brand_id: uuid!
  listing_id: uuid!
  listing_images: [jsonb!]!
}

input SetUserMetadataInput {
  brand_id: uuid!
  data: [UserMetadataInput!]!
}

input SetUserPreferredLanguageInput {
  brand_id: String!
  language: String!
}

input SkuImageInput {
  alt: String
  detail: Boolean!
  images_translations: [SkuImageTranslationInput!]!
  index: Int!
  primary: Boolean!
  primary_hover: Boolean
  src: String!
  swatch: Boolean!
}

input SkuImageTranslationInput {
  alt: String
  lang: String
}

input SkuImageUpdateInput {
  id: uuid!
  index: Int!
  primary: Boolean!
}

input SkuInput {
  sku: String!
  skus_translations: [SkuTranslationInput!]!
  variant_options: [VariantOptionInput!]!
}

input SkuTranslationInput {
  description: String!
  lang: String!
}

input SourceLocationInput {
  type: String!
  val: String!
}

input SpecificRegion {
  region_type: String!
  region_value: String!
}

input StoreTakebackMetadataInput {
  schema: CreateStoreTakebackMetadataSchemas!
  value: jsonb!
}

input StoreTakebackUser {
  auth_tenant_id: String
  email: String!
  email_marketing_consent: Boolean!
  first_name: String!
  last_name: String!
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

input SubmitWorkflowItemInput {
  action: String!
  brand_id: uuid!
  data: jsonb!
  workflow_item_id: uuid!
}

input TakebackEstimateItemInput {
  credit_type: String
  item_id: uuid!
  lpn: String
  product_id: String
  product_style_id: String
  style_code: String
}

input TakebackItemIdInput {
  id: String!
  id_type: TakebackItemIdType!
}

input TranslateRequest {
  inputLangCode: String
  inputText: String!
  outputLangCode: String!
}

input UpdateCollectionInput {
  active: Boolean
  brand_id: uuid!
  collection_id: uuid!
  definition: jsonb
  media: [CollectionMediaInput!]
  translations: [CollectionDetailsInput!]
}

input UpdateFormSubmissionInput {
  brand_id: uuid!
  form_submission_id: uuid!
  submission_data: jsonb
}

input UpdateManualCollectionItemsInput {
  brand_id: uuid!
  collection_id: uuid!
  deletions: ManualCollectionItemsInput
  insertions: ManualCollectionItemsInput
}

input UpdateMediaGroupInput {
  brand_id: uuid!
  items: [UpdateMediaGroupItemsInput!]!
  media_group_id: uuid!
}

input UpdateMediaGroupItemsInput {
  alt: String
  href: String!
  id: uuid!
  position: Int!
}

input UpdateProductImagesInput {
  brand_id: uuid!
  product_id: uuid!
  product_image_updates: [ProductImageUpdateInput!]!
}

input UpdateProductInput {
  brand_id: String!
  color: String
  product_id: uuid!
  product_translations: [UpdateProductTranslationInput!]
}

input UpdateProductStyleInput {
  brand_id: String!
  care: String
  category: CategoryInfoInput
  description: String
  disallow_listing: Boolean
  fit: String
  material: String
  original_price: Int
  product_ids: [uuid!]!
  product_name: String
  product_style: String
  product_style_id: uuid!
  product_tags: [String!]
  product_translations: [UpdateProductStyleTranslationInput!]
  set_attribute_values: [AttributeValueInput!]
}

input UpdateProductStyleTranslationInput {
  care: String
  description: String
  fit: String
  lang: String!
  material: String
  name: String
}

input UpdateProductStyleV2Input {
  attribute_values: [AttributeValueInput!]
  brand_id: String!
  category_id: String
  disallow_listing: Boolean
  new_attribute_values: [NewAttributeInput!]
  price: Int!
  product_style_id: uuid!
  translations: [ProductStylesTranslationsInput!]
}

input UpdateProductStyleVariantInput {
  price: Int
  product_style_variant_id: uuid!
}

input UpdateProductTranslationInput {
  color: String
  lang: String!
}

input UpdateSearchPageCustomPriorityInput {
  type: String!
  value: jsonb!
}

input UpdateSearchPageInput {
  active: Boolean!
  brand_id: uuid!
  definition: jsonb!
  id: uuid!
  order_by: UpdateSearchPageOrderByInput!
  translations: [SearchPageTranslationInput!]!
}

input UpdateSearchPageOrderByInput {
  custom_priority: UpdateSearchPageCustomPriorityInput
  rule_priority: [jsonb!]
}

input UpdateSkuFieldsInput {
  original_price: Int
  size: String
  sku: String
}

input UpdateSkuImagesInput {
  brand_id: uuid!
  sku_id: uuid!
  sku_image_updates: [SkuImageUpdateInput!]!
}

input UpdateSkuInput {
  sku_id: uuid!
  sku_update: UpdateSkuFieldsInput!
}

input UpdateSkusInput {
  brand_id: String!
  product_id: uuid
  skus_translations: [UpdateSkusTranslationsInput!]
  updates: [UpdateSkuInput!]!
}

input UpdateSkusTranslationsInput {
  description: String
  lang: String!
  size: String
  sku_id: uuid!
}

input UpdateStoreTakebackUserInput {
  auth_tenant_id: String
  new_email: String!
  retail_store_id: uuid
  takeback_id: uuid!
}

input UserMetadataInput {
  key: String!
  value: jsonb!
}

input ValidateAddressInput {
  address_line_1: String!
  address_line_2: String
  administrative_area: String
  country: String
  locality: String!
  name: String!
  postal_code: String!
}

input ValidateAddressV2FulfillmentInput {
  method: String!
}

input ValidateAddressV2Input {
  address: AddressInput!
  brand_id: uuid!
  fulfillment: ValidateAddressV2FulfillmentInput!
}

input ValidateAuthActionTokenInput {
  token: String!
  type: String!
}

input VariantOptionInput {
  option_id: uuid!
  type_id: uuid!
}

input VariantTypeOptionTranslationInput {
  display: String!
  lang: String!
}

input VerifyEmailInput {
  token: String!
}

"Boolean expression to filter rows from the table \"addresses\". All fields are combined with a logical 'AND'."
input addresses_bool_exp {
  _and: [addresses_bool_exp!]
  _not: addresses_bool_exp
  _or: [addresses_bool_exp!]
  administrative_area: String_comparison_exp
  country: String_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  longlat_pub: geography_comparison_exp
}

"input type for inserting data into table \"addresses\""
input addresses_insert_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
}

"input type for inserting object relation for remote table \"addresses\""
input addresses_obj_rel_insert_input {
  data: addresses_insert_input!
  "upsert condition"
  on_conflict: addresses_on_conflict
}

"on_conflict condition type for table \"addresses\""
input addresses_on_conflict {
  constraint: addresses_constraint!
  update_columns: [addresses_update_column!]! = []
  where: addresses_bool_exp
}

"Ordering options when selecting data from \"addresses\"."
input addresses_order_by {
  administrative_area: order_by
  country: order_by
  id: order_by
  locality: order_by
  longlat_pub: order_by
}

"Streaming cursor of the table \"addresses\""
input addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input addresses_stream_cursor_value_input {
  administrative_area: String
  country: String
  id: uuid
  locality: String
  longlat_pub: geography
}

input annual_sales_totals_aggregate_bool_exp {
  avg: annual_sales_totals_aggregate_bool_exp_avg
  corr: annual_sales_totals_aggregate_bool_exp_corr
  count: annual_sales_totals_aggregate_bool_exp_count
  covar_samp: annual_sales_totals_aggregate_bool_exp_covar_samp
  max: annual_sales_totals_aggregate_bool_exp_max
  min: annual_sales_totals_aggregate_bool_exp_min
  stddev_samp: annual_sales_totals_aggregate_bool_exp_stddev_samp
  sum: annual_sales_totals_aggregate_bool_exp_sum
  var_samp: annual_sales_totals_aggregate_bool_exp_var_samp
}

input annual_sales_totals_aggregate_bool_exp_avg {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_corr {
  arguments: annual_sales_totals_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_corr_arguments {
  X: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_corr_arguments_columns!
  Y: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_corr_arguments_columns!
}

input annual_sales_totals_aggregate_bool_exp_count {
  arguments: [annual_sales_totals_select_column!]
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: Int_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_covar_samp {
  arguments: annual_sales_totals_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_covar_samp_arguments {
  X: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_covar_samp_arguments_columns!
}

input annual_sales_totals_aggregate_bool_exp_max {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_min {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_stddev_samp {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_sum {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

input annual_sales_totals_aggregate_bool_exp_var_samp {
  arguments: annual_sales_totals_select_column_annual_sales_totals_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: annual_sales_totals_bool_exp
  predicate: float8_comparison_exp!
}

"order by aggregate values of table \"annual_sales_totals\""
input annual_sales_totals_aggregate_order_by {
  avg: annual_sales_totals_avg_order_by
  count: order_by
  max: annual_sales_totals_max_order_by
  min: annual_sales_totals_min_order_by
  stddev: annual_sales_totals_stddev_order_by
  stddev_pop: annual_sales_totals_stddev_pop_order_by
  stddev_samp: annual_sales_totals_stddev_samp_order_by
  sum: annual_sales_totals_sum_order_by
  var_pop: annual_sales_totals_var_pop_order_by
  var_samp: annual_sales_totals_var_samp_order_by
  variance: annual_sales_totals_variance_order_by
}

"order by avg() on columns of table \"annual_sales_totals\""
input annual_sales_totals_avg_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"Boolean expression to filter rows from the table \"annual_sales_totals\". All fields are combined with a logical 'AND'."
input annual_sales_totals_bool_exp {
  _and: [annual_sales_totals_bool_exp!]
  _not: annual_sales_totals_bool_exp
  _or: [annual_sales_totals_bool_exp!]
  country: String_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  tax_year: float8_comparison_exp
  total: bigint_comparison_exp
  total_sales_count: bigint_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"annual_sales_totals\""
input annual_sales_totals_max_order_by {
  country: order_by
  storefront_id: order_by
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
  user_id: order_by
}

"order by min() on columns of table \"annual_sales_totals\""
input annual_sales_totals_min_order_by {
  country: order_by
  storefront_id: order_by
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"annual_sales_totals\"."
input annual_sales_totals_order_by {
  country: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"annual_sales_totals\""
input annual_sales_totals_stddev_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by stddev_pop() on columns of table \"annual_sales_totals\""
input annual_sales_totals_stddev_pop_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by stddev_samp() on columns of table \"annual_sales_totals\""
input annual_sales_totals_stddev_samp_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"Streaming cursor of the table \"annual_sales_totals\""
input annual_sales_totals_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: annual_sales_totals_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input annual_sales_totals_stream_cursor_value_input {
  country: String
  storefront_id: uuid
  tax_year: float8
  total: bigint
  total_sales_count: bigint
  user_id: String
}

"order by sum() on columns of table \"annual_sales_totals\""
input annual_sales_totals_sum_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by var_pop() on columns of table \"annual_sales_totals\""
input annual_sales_totals_var_pop_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by var_samp() on columns of table \"annual_sales_totals\""
input annual_sales_totals_var_samp_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by variance() on columns of table \"annual_sales_totals\""
input annual_sales_totals_variance_order_by {
  tax_year: order_by
  total: order_by
  total_sales_count: order_by
}

"order by aggregate values of table \"applied_discount_codes\""
input applied_discount_codes_aggregate_order_by {
  avg: applied_discount_codes_avg_order_by
  count: order_by
  max: applied_discount_codes_max_order_by
  min: applied_discount_codes_min_order_by
  stddev: applied_discount_codes_stddev_order_by
  stddev_pop: applied_discount_codes_stddev_pop_order_by
  stddev_samp: applied_discount_codes_stddev_samp_order_by
  sum: applied_discount_codes_sum_order_by
  var_pop: applied_discount_codes_var_pop_order_by
  var_samp: applied_discount_codes_var_samp_order_by
  variance: applied_discount_codes_variance_order_by
}

"order by avg() on columns of table \"applied_discount_codes\""
input applied_discount_codes_avg_order_by {
  discount_amount: order_by
}

"Boolean expression to filter rows from the table \"applied_discount_codes\". All fields are combined with a logical 'AND'."
input applied_discount_codes_bool_exp {
  _and: [applied_discount_codes_bool_exp!]
  _not: applied_discount_codes_bool_exp
  _or: [applied_discount_codes_bool_exp!]
  discount_amount: numeric_comparison_exp
  id: uuid_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
}

"order by max() on columns of table \"applied_discount_codes\""
input applied_discount_codes_max_order_by {
  discount_amount: order_by
  id: order_by
  order_id: order_by
}

"order by min() on columns of table \"applied_discount_codes\""
input applied_discount_codes_min_order_by {
  discount_amount: order_by
  id: order_by
  order_id: order_by
}

"Ordering options when selecting data from \"applied_discount_codes\"."
input applied_discount_codes_order_by {
  discount_amount: order_by
  id: order_by
  order: orders_order_by
  order_id: order_by
}

"order by stddev() on columns of table \"applied_discount_codes\""
input applied_discount_codes_stddev_order_by {
  discount_amount: order_by
}

"order by stddev_pop() on columns of table \"applied_discount_codes\""
input applied_discount_codes_stddev_pop_order_by {
  discount_amount: order_by
}

"order by stddev_samp() on columns of table \"applied_discount_codes\""
input applied_discount_codes_stddev_samp_order_by {
  discount_amount: order_by
}

"Streaming cursor of the table \"applied_discount_codes\""
input applied_discount_codes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: applied_discount_codes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input applied_discount_codes_stream_cursor_value_input {
  discount_amount: numeric
  id: uuid
  order_id: uuid
}

"order by sum() on columns of table \"applied_discount_codes\""
input applied_discount_codes_sum_order_by {
  discount_amount: order_by
}

"order by var_pop() on columns of table \"applied_discount_codes\""
input applied_discount_codes_var_pop_order_by {
  discount_amount: order_by
}

"order by var_samp() on columns of table \"applied_discount_codes\""
input applied_discount_codes_var_samp_order_by {
  discount_amount: order_by
}

"order by variance() on columns of table \"applied_discount_codes\""
input applied_discount_codes_variance_order_by {
  discount_amount: order_by
}

"order by aggregate values of table \"attempted_discount_codes\""
input attempted_discount_codes_aggregate_order_by {
  avg: attempted_discount_codes_avg_order_by
  count: order_by
  max: attempted_discount_codes_max_order_by
  min: attempted_discount_codes_min_order_by
  stddev: attempted_discount_codes_stddev_order_by
  stddev_pop: attempted_discount_codes_stddev_pop_order_by
  stddev_samp: attempted_discount_codes_stddev_samp_order_by
  sum: attempted_discount_codes_sum_order_by
  var_pop: attempted_discount_codes_var_pop_order_by
  var_samp: attempted_discount_codes_var_samp_order_by
  variance: attempted_discount_codes_variance_order_by
}

"input type for inserting array relation for remote table \"attempted_discount_codes\""
input attempted_discount_codes_arr_rel_insert_input {
  data: [attempted_discount_codes_insert_input!]!
  "upsert condition"
  on_conflict: attempted_discount_codes_on_conflict
}

"order by avg() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_avg_order_by {
  discount_amount: order_by
}

"Boolean expression to filter rows from the table \"attempted_discount_codes\". All fields are combined with a logical 'AND'."
input attempted_discount_codes_bool_exp {
  _and: [attempted_discount_codes_bool_exp!]
  _not: attempted_discount_codes_bool_exp
  _or: [attempted_discount_codes_bool_exp!]
  discount_amount: numeric_comparison_exp
  id: uuid_comparison_exp
  order_intent: order_intents_bool_exp
  order_intent_id: uuid_comparison_exp
}

"input type for inserting data into table \"attempted_discount_codes\""
input attempted_discount_codes_insert_input {
  created_at: timestamptz
  discount_amount: numeric
  discount_code_id: uuid
  id: uuid
  order_intent: order_intents_obj_rel_insert_input
  order_intent_id: uuid
  updated_at: timestamptz
}

"order by max() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_max_order_by {
  discount_amount: order_by
  id: order_by
  order_intent_id: order_by
}

"order by min() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_min_order_by {
  discount_amount: order_by
  id: order_by
  order_intent_id: order_by
}

"on_conflict condition type for table \"attempted_discount_codes\""
input attempted_discount_codes_on_conflict {
  constraint: attempted_discount_codes_constraint!
  update_columns: [attempted_discount_codes_update_column!]! = []
  where: attempted_discount_codes_bool_exp
}

"Ordering options when selecting data from \"attempted_discount_codes\"."
input attempted_discount_codes_order_by {
  discount_amount: order_by
  id: order_by
  order_intent: order_intents_order_by
  order_intent_id: order_by
}

"order by stddev() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_stddev_order_by {
  discount_amount: order_by
}

"order by stddev_pop() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_stddev_pop_order_by {
  discount_amount: order_by
}

"order by stddev_samp() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_stddev_samp_order_by {
  discount_amount: order_by
}

"Streaming cursor of the table \"attempted_discount_codes\""
input attempted_discount_codes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attempted_discount_codes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attempted_discount_codes_stream_cursor_value_input {
  discount_amount: numeric
  id: uuid
  order_intent_id: uuid
}

"order by sum() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_sum_order_by {
  discount_amount: order_by
}

"order by var_pop() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_var_pop_order_by {
  discount_amount: order_by
}

"order by var_samp() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_var_samp_order_by {
  discount_amount: order_by
}

"order by variance() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_variance_order_by {
  discount_amount: order_by
}

"order by aggregate values of table \"attribute_type_options\""
input attribute_type_options_aggregate_order_by {
  count: order_by
  max: attribute_type_options_max_order_by
  min: attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"attribute_type_options\". All fields are combined with a logical 'AND'."
input attribute_type_options_bool_exp {
  _and: [attribute_type_options_bool_exp!]
  _not: attribute_type_options_bool_exp
  _or: [attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: attribute_type_options_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  option: String_comparison_exp
  translations: attribute_type_options_translations_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"attribute_type_options\""
input attribute_type_options_max_order_by {
  attribute_type_id: order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
}

"order by min() on columns of table \"attribute_type_options\""
input attribute_type_options_min_order_by {
  attribute_type_id: order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"attribute_type_options\"."
input attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: attribute_type_options_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  option: order_by
  translations_aggregate: attribute_type_options_translations_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"attribute_type_options\""
input attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  option: String
  updated_at: timestamptz
}

"order by aggregate values of table \"attribute_type_options_translations\""
input attribute_type_options_translations_aggregate_order_by {
  avg: attribute_type_options_translations_avg_order_by
  count: order_by
  max: attribute_type_options_translations_max_order_by
  min: attribute_type_options_translations_min_order_by
  stddev: attribute_type_options_translations_stddev_order_by
  stddev_pop: attribute_type_options_translations_stddev_pop_order_by
  stddev_samp: attribute_type_options_translations_stddev_samp_order_by
  sum: attribute_type_options_translations_sum_order_by
  var_pop: attribute_type_options_translations_var_pop_order_by
  var_samp: attribute_type_options_translations_var_samp_order_by
  variance: attribute_type_options_translations_variance_order_by
}

"order by avg() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"attribute_type_options_translations\". All fields are combined with a logical 'AND'."
input attribute_type_options_translations_bool_exp {
  _and: [attribute_type_options_translations_bool_exp!]
  _not: attribute_type_options_translations_bool_exp
  _or: [attribute_type_options_translations_bool_exp!]
  attribute_type_option_id: uuid_comparison_exp
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
}

"order by max() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_max_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by min() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_min_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"Ordering options when selecting data from \"attribute_type_options_translations\"."
input attribute_type_options_translations_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by stddev() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"attribute_type_options_translations\""
input attribute_type_options_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_type_options_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_type_options_translations_stream_cursor_value_input {
  attribute_type_option_id: uuid
  display: String
  id: Int
  lang: String
}

"order by sum() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"attribute_types\""
input attribute_types_aggregate_order_by {
  count: order_by
  max: attribute_types_max_order_by
  min: attribute_types_min_order_by
}

"Boolean expression to filter rows from the table \"attribute_types\". All fields are combined with a logical 'AND'."
input attribute_types_bool_exp {
  _and: [attribute_types_bool_exp!]
  _not: attribute_types_bool_exp
  _or: [attribute_types_bool_exp!]
  attribute_type_options: attribute_type_options_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: attribute_types_translations_bool_exp
  id: uuid_comparison_exp
  translations: attribute_types_translations_bool_exp
  type: String_comparison_exp
}

"order by max() on columns of table \"attribute_types\""
input attribute_types_max_order_by {
  brand_id: order_by
  id: order_by
  type: order_by
}

"order by min() on columns of table \"attribute_types\""
input attribute_types_min_order_by {
  brand_id: order_by
  id: order_by
  type: order_by
}

"Ordering options when selecting data from \"attribute_types\"."
input attribute_types_order_by {
  attribute_type_options_aggregate: attribute_type_options_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: attribute_types_translations_aggregate_order_by
  id: order_by
  translations_aggregate: attribute_types_translations_aggregate_order_by
  type: order_by
}

"Streaming cursor of the table \"attribute_types\""
input attribute_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_types_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  type: String
}

"order by aggregate values of table \"attribute_types_translations\""
input attribute_types_translations_aggregate_order_by {
  avg: attribute_types_translations_avg_order_by
  count: order_by
  max: attribute_types_translations_max_order_by
  min: attribute_types_translations_min_order_by
  stddev: attribute_types_translations_stddev_order_by
  stddev_pop: attribute_types_translations_stddev_pop_order_by
  stddev_samp: attribute_types_translations_stddev_samp_order_by
  sum: attribute_types_translations_sum_order_by
  var_pop: attribute_types_translations_var_pop_order_by
  var_samp: attribute_types_translations_var_samp_order_by
  variance: attribute_types_translations_variance_order_by
}

"order by avg() on columns of table \"attribute_types_translations\""
input attribute_types_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"attribute_types_translations\". All fields are combined with a logical 'AND'."
input attribute_types_translations_bool_exp {
  _and: [attribute_types_translations_bool_exp!]
  _not: attribute_types_translations_bool_exp
  _or: [attribute_types_translations_bool_exp!]
  attribute_type_id: uuid_comparison_exp
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
}

"order by max() on columns of table \"attribute_types_translations\""
input attribute_types_translations_max_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by min() on columns of table \"attribute_types_translations\""
input attribute_types_translations_min_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"Ordering options when selecting data from \"attribute_types_translations\"."
input attribute_types_translations_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by stddev() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"attribute_types_translations\""
input attribute_types_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_types_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_types_translations_stream_cursor_value_input {
  attribute_type_id: uuid
  display: String
  id: Int
  lang: String
}

"order by sum() on columns of table \"attribute_types_translations\""
input attribute_types_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"attribute_types_translations\""
input attribute_types_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"attribute_types_translations\""
input attribute_types_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"attribute_types_translations\""
input attribute_types_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"auction_bids\""
input auction_bids_aggregate_order_by {
  avg: auction_bids_avg_order_by
  count: order_by
  max: auction_bids_max_order_by
  min: auction_bids_min_order_by
  stddev: auction_bids_stddev_order_by
  stddev_pop: auction_bids_stddev_pop_order_by
  stddev_samp: auction_bids_stddev_samp_order_by
  sum: auction_bids_sum_order_by
  var_pop: auction_bids_var_pop_order_by
  var_samp: auction_bids_var_samp_order_by
  variance: auction_bids_variance_order_by
}

"order by avg() on columns of table \"auction_bids\""
input auction_bids_avg_order_by {
  amount: order_by
  order: order_by
}

"Boolean expression to filter rows from the table \"auction_bids\". All fields are combined with a logical 'AND'."
input auction_bids_bool_exp {
  _and: [auction_bids_bool_exp!]
  _not: auction_bids_bool_exp
  _or: [auction_bids_bool_exp!]
  address: addresses_bool_exp
  address_id: uuid_comparison_exp
  amount: bigint_comparison_exp
  auction: auctions_bool_exp
  auction_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  payment_intent_id: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by aggregate values of table \"auction_bids_history\""
input auction_bids_history_aggregate_order_by {
  avg: auction_bids_history_avg_order_by
  count: order_by
  max: auction_bids_history_max_order_by
  min: auction_bids_history_min_order_by
  stddev: auction_bids_history_stddev_order_by
  stddev_pop: auction_bids_history_stddev_pop_order_by
  stddev_samp: auction_bids_history_stddev_samp_order_by
  sum: auction_bids_history_sum_order_by
  var_pop: auction_bids_history_var_pop_order_by
  var_samp: auction_bids_history_var_samp_order_by
  variance: auction_bids_history_variance_order_by
}

"order by avg() on columns of table \"auction_bids_history\""
input auction_bids_history_avg_order_by {
  amount: order_by
  order: order_by
}

"Boolean expression to filter rows from the table \"auction_bids_history\". All fields are combined with a logical 'AND'."
input auction_bids_history_bool_exp {
  _and: [auction_bids_history_bool_exp!]
  _not: auction_bids_history_bool_exp
  _or: [auction_bids_history_bool_exp!]
  amount: bigint_comparison_exp
  auction: auctions_bool_exp
  auction_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"auction_bids_history\""
input auction_bids_history_max_order_by {
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user_id: order_by
}

"order by min() on columns of table \"auction_bids_history\""
input auction_bids_history_min_order_by {
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"auction_bids_history\"."
input auction_bids_history_order_by {
  amount: order_by
  auction: auctions_order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_pop() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_pop_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_samp() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_samp_order_by {
  amount: order_by
  order: order_by
}

"Streaming cursor of the table \"auction_bids_history\""
input auction_bids_history_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auction_bids_history_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auction_bids_history_stream_cursor_value_input {
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  user_id: String
}

"order by sum() on columns of table \"auction_bids_history\""
input auction_bids_history_sum_order_by {
  amount: order_by
  order: order_by
}

"order by var_pop() on columns of table \"auction_bids_history\""
input auction_bids_history_var_pop_order_by {
  amount: order_by
  order: order_by
}

"order by var_samp() on columns of table \"auction_bids_history\""
input auction_bids_history_var_samp_order_by {
  amount: order_by
  order: order_by
}

"order by variance() on columns of table \"auction_bids_history\""
input auction_bids_history_variance_order_by {
  amount: order_by
  order: order_by
}

"input type for inserting data into table \"auction_bids\""
input auction_bids_insert_input {
  address: addresses_obj_rel_insert_input
  address_id: uuid
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  payment_intent_id: String
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"auction_bids\""
input auction_bids_max_order_by {
  address_id: order_by
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"auction_bids\""
input auction_bids_min_order_by {
  address_id: order_by
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user_id: order_by
}

"on_conflict condition type for table \"auction_bids\""
input auction_bids_on_conflict {
  constraint: auction_bids_constraint!
  update_columns: [auction_bids_update_column!]! = []
  where: auction_bids_bool_exp
}

"Ordering options when selecting data from \"auction_bids\"."
input auction_bids_order_by {
  address: addresses_order_by
  address_id: order_by
  amount: order_by
  auction: auctions_order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"auction_bids\""
input auction_bids_stddev_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_pop() on columns of table \"auction_bids\""
input auction_bids_stddev_pop_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_samp() on columns of table \"auction_bids\""
input auction_bids_stddev_samp_order_by {
  amount: order_by
  order: order_by
}

"Streaming cursor of the table \"auction_bids\""
input auction_bids_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auction_bids_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auction_bids_stream_cursor_value_input {
  address_id: uuid
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  payment_intent_id: String
  user_id: String
}

"order by sum() on columns of table \"auction_bids\""
input auction_bids_sum_order_by {
  amount: order_by
  order: order_by
}

"order by var_pop() on columns of table \"auction_bids\""
input auction_bids_var_pop_order_by {
  amount: order_by
  order: order_by
}

"order by var_samp() on columns of table \"auction_bids\""
input auction_bids_var_samp_order_by {
  amount: order_by
  order: order_by
}

"order by variance() on columns of table \"auction_bids\""
input auction_bids_variance_order_by {
  amount: order_by
  order: order_by
}

"order by aggregate values of table \"auctions\""
input auctions_aggregate_order_by {
  avg: auctions_avg_order_by
  count: order_by
  max: auctions_max_order_by
  min: auctions_min_order_by
  stddev: auctions_stddev_order_by
  stddev_pop: auctions_stddev_pop_order_by
  stddev_samp: auctions_stddev_samp_order_by
  sum: auctions_sum_order_by
  var_pop: auctions_var_pop_order_by
  var_samp: auctions_var_samp_order_by
  variance: auctions_variance_order_by
}

"order by avg() on columns of table \"auctions\""
input auctions_avg_order_by {
  max_price: order_by
}

"Boolean expression to filter rows from the table \"auctions\". All fields are combined with a logical 'AND'."
input auctions_bool_exp {
  _and: [auctions_bool_exp!]
  _not: auctions_bool_exp
  _or: [auctions_bool_exp!]
  bids: auction_bids_bool_exp
  bids_histories: auction_bids_history_bool_exp
  end: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  max_price: Int_comparison_exp
  start: timestamptz_comparison_exp
}

"order by max() on columns of table \"auctions\""
input auctions_max_order_by {
  end: order_by
  id: order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"order by min() on columns of table \"auctions\""
input auctions_min_order_by {
  end: order_by
  id: order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"Ordering options when selecting data from \"auctions\"."
input auctions_order_by {
  bids_aggregate: auction_bids_aggregate_order_by
  bids_histories_aggregate: auction_bids_history_aggregate_order_by
  end: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"order by stddev() on columns of table \"auctions\""
input auctions_stddev_order_by {
  max_price: order_by
}

"order by stddev_pop() on columns of table \"auctions\""
input auctions_stddev_pop_order_by {
  max_price: order_by
}

"order by stddev_samp() on columns of table \"auctions\""
input auctions_stddev_samp_order_by {
  max_price: order_by
}

"Streaming cursor of the table \"auctions\""
input auctions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auctions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auctions_stream_cursor_value_input {
  end: timestamptz
  id: uuid
  listing_id: uuid
  max_price: Int
  start: timestamptz
}

"order by sum() on columns of table \"auctions\""
input auctions_sum_order_by {
  max_price: order_by
}

"order by var_pop() on columns of table \"auctions\""
input auctions_var_pop_order_by {
  max_price: order_by
}

"order by var_samp() on columns of table \"auctions\""
input auctions_var_samp_order_by {
  max_price: order_by
}

"order by variance() on columns of table \"auctions\""
input auctions_variance_order_by {
  max_price: order_by
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"order by aggregate values of table \"brand_categories\""
input brand_categories_aggregate_order_by {
  avg: brand_categories_avg_order_by
  count: order_by
  max: brand_categories_max_order_by
  min: brand_categories_min_order_by
  stddev: brand_categories_stddev_order_by
  stddev_pop: brand_categories_stddev_pop_order_by
  stddev_samp: brand_categories_stddev_samp_order_by
  sum: brand_categories_sum_order_by
  var_pop: brand_categories_var_pop_order_by
  var_samp: brand_categories_var_samp_order_by
  variance: brand_categories_variance_order_by
}

"order by avg() on columns of table \"brand_categories\""
input brand_categories_avg_order_by {
  default_price_multiplier: order_by
}

"Boolean expression to filter rows from the table \"brand_categories\". All fields are combined with a logical 'AND'."
input brand_categories_bool_exp {
  _and: [brand_categories_bool_exp!]
  _not: brand_categories_bool_exp
  _or: [brand_categories_bool_exp!]
  brand: brands_bool_exp
  brand_categories: brand_categories_bool_exp
  brand_category: brand_categories_bool_exp
  brand_id: uuid_comparison_exp
  category_translations: brand_categories_translations_bool_exp
  category_translations_aggregate: brand_categories_translations_aggregate_bool_exp
  content: brand_categories_translations_bool_exp
  created_at: timestamptz_comparison_exp
  default_price_multiplier: numeric_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  products: products_bool_exp
  productsBySuperCategoryId: products_bool_exp
  productsBySuperCategoryId_aggregate: products_aggregate_bool_exp
  products_aggregate: products_aggregate_bool_exp
  singular: String_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_categories\""
input brand_categories_max_order_by {
  brand_id: order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_categories\""
input brand_categories_min_order_by {
  brand_id: order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_categories\"."
input brand_categories_order_by {
  brand: brands_order_by
  brand_categories_aggregate: brand_categories_aggregate_order_by
  brand_category: brand_categories_order_by
  brand_id: order_by
  category_translations_aggregate: brand_categories_translations_aggregate_order_by
  content_aggregate: brand_categories_translations_aggregate_order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  productsBySuperCategoryId_aggregate: products_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_categories\""
input brand_categories_stddev_order_by {
  default_price_multiplier: order_by
}

"order by stddev_pop() on columns of table \"brand_categories\""
input brand_categories_stddev_pop_order_by {
  default_price_multiplier: order_by
}

"order by stddev_samp() on columns of table \"brand_categories\""
input brand_categories_stddev_samp_order_by {
  default_price_multiplier: order_by
}

"Streaming cursor of the table \"brand_categories\""
input brand_categories_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_categories_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_categories_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  default_price_multiplier: numeric
  id: uuid
  name: String
  parent_id: uuid
  singular: String
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_categories\""
input brand_categories_sum_order_by {
  default_price_multiplier: order_by
}

input brand_categories_translations_aggregate_bool_exp {
  count: brand_categories_translations_aggregate_bool_exp_count
}

input brand_categories_translations_aggregate_bool_exp_count {
  arguments: [brand_categories_translations_select_column!]
  distinct: Boolean
  filter: brand_categories_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"brand_categories_translations\""
input brand_categories_translations_aggregate_order_by {
  avg: brand_categories_translations_avg_order_by
  count: order_by
  max: brand_categories_translations_max_order_by
  min: brand_categories_translations_min_order_by
  stddev: brand_categories_translations_stddev_order_by
  stddev_pop: brand_categories_translations_stddev_pop_order_by
  stddev_samp: brand_categories_translations_stddev_samp_order_by
  sum: brand_categories_translations_sum_order_by
  var_pop: brand_categories_translations_var_pop_order_by
  var_samp: brand_categories_translations_var_samp_order_by
  variance: brand_categories_translations_variance_order_by
}

"order by avg() on columns of table \"brand_categories_translations\""
input brand_categories_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"brand_categories_translations\". All fields are combined with a logical 'AND'."
input brand_categories_translations_bool_exp {
  _and: [brand_categories_translations_bool_exp!]
  _not: brand_categories_translations_bool_exp
  _or: [brand_categories_translations_bool_exp!]
  category_id: uuid_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  singular: String_comparison_exp
}

"order by max() on columns of table \"brand_categories_translations\""
input brand_categories_translations_max_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"order by min() on columns of table \"brand_categories_translations\""
input brand_categories_translations_min_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"Ordering options when selecting data from \"brand_categories_translations\"."
input brand_categories_translations_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"order by stddev() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"brand_categories_translations\""
input brand_categories_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_categories_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_categories_translations_stream_cursor_value_input {
  category_id: uuid
  id: Int
  lang: String
  name: String
  singular: String
}

"order by sum() on columns of table \"brand_categories_translations\""
input brand_categories_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"brand_categories_translations\""
input brand_categories_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"brand_categories_translations\""
input brand_categories_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"brand_categories_translations\""
input brand_categories_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"brand_categories\""
input brand_categories_var_pop_order_by {
  default_price_multiplier: order_by
}

"order by var_samp() on columns of table \"brand_categories\""
input brand_categories_var_samp_order_by {
  default_price_multiplier: order_by
}

"order by variance() on columns of table \"brand_categories\""
input brand_categories_variance_order_by {
  default_price_multiplier: order_by
}

"order by aggregate values of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_aggregate_order_by {
  avg: brand_fulfillment_in_store_options_avg_order_by
  count: order_by
  max: brand_fulfillment_in_store_options_max_order_by
  min: brand_fulfillment_in_store_options_min_order_by
  stddev: brand_fulfillment_in_store_options_stddev_order_by
  stddev_pop: brand_fulfillment_in_store_options_stddev_pop_order_by
  stddev_samp: brand_fulfillment_in_store_options_stddev_samp_order_by
  sum: brand_fulfillment_in_store_options_sum_order_by
  var_pop: brand_fulfillment_in_store_options_var_pop_order_by
  var_samp: brand_fulfillment_in_store_options_var_samp_order_by
  variance: brand_fulfillment_in_store_options_variance_order_by
}

"order by avg() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_in_store_options\". All fields are combined with a logical 'AND'."
input brand_fulfillment_in_store_options_bool_exp {
  _and: [brand_fulfillment_in_store_options_bool_exp!]
  _not: brand_fulfillment_in_store_options_bool_exp
  _or: [brand_fulfillment_in_store_options_bool_exp!]
  brand_fulfillment_in_store_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_max_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_min_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_in_store_options\"."
input brand_fulfillment_in_store_options_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_in_store_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_in_store_options_stream_cursor_value_input {
  brand_fulfillment_in_store_settings_id: uuid
  created_at: timestamptz
  id: uuid
  retail_store_id: uuid
  shipping_fee: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_in_store_settings_max_order_by
  min: brand_fulfillment_in_store_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_in_store_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_in_store_settings_bool_exp {
  _and: [brand_fulfillment_in_store_settings_bool_exp!]
  _not: brand_fulfillment_in_store_settings_bool_exp
  _or: [brand_fulfillment_in_store_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: brand_fulfillment_in_store_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_in_store_settings\"."
input brand_fulfillment_in_store_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: brand_fulfillment_in_store_options_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_in_store_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_in_store_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_aggregate_order_by {
  avg: brand_fulfillment_postal_options_avg_order_by
  count: order_by
  max: brand_fulfillment_postal_options_max_order_by
  min: brand_fulfillment_postal_options_min_order_by
  stddev: brand_fulfillment_postal_options_stddev_order_by
  stddev_pop: brand_fulfillment_postal_options_stddev_pop_order_by
  stddev_samp: brand_fulfillment_postal_options_stddev_samp_order_by
  sum: brand_fulfillment_postal_options_sum_order_by
  var_pop: brand_fulfillment_postal_options_var_pop_order_by
  var_samp: brand_fulfillment_postal_options_var_samp_order_by
  variance: brand_fulfillment_postal_options_variance_order_by
}

"order by avg() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_postal_options\". All fields are combined with a logical 'AND'."
input brand_fulfillment_postal_options_bool_exp {
  _and: [brand_fulfillment_postal_options_bool_exp!]
  _not: brand_fulfillment_postal_options_bool_exp
  _or: [brand_fulfillment_postal_options_bool_exp!]
  brand_fulfillment_postal_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  postal_options_id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_max_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_min_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_postal_options\"."
input brand_fulfillment_postal_options_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_postal_options_stream_cursor_value_input {
  brand_fulfillment_postal_settings_id: uuid
  created_at: timestamptz
  id: uuid
  postal_options_id: uuid
  shipping_fee: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_postal_settings_max_order_by
  min: brand_fulfillment_postal_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_postal_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_postal_settings_bool_exp {
  _and: [brand_fulfillment_postal_settings_bool_exp!]
  _not: brand_fulfillment_postal_settings_bool_exp
  _or: [brand_fulfillment_postal_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: brand_fulfillment_postal_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_postal_settings\"."
input brand_fulfillment_postal_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: brand_fulfillment_postal_options_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_postal_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_postal_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_settings_max_order_by
  min: brand_fulfillment_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_settings_bool_exp {
  _and: [brand_fulfillment_settings_bool_exp!]
  _not: brand_fulfillment_settings_bool_exp
  _or: [brand_fulfillment_settings_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  fulfillment_type: fulfillment_types_enum_comparison_exp
  id: uuid_comparison_exp
  in_store_settings: brand_fulfillment_in_store_settings_bool_exp
  name: String_comparison_exp
  postal_settings: brand_fulfillment_postal_settings_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_settings\"."
input brand_fulfillment_settings_order_by {
  brand_id: order_by
  created_at: order_by
  fulfillment_type: order_by
  id: order_by
  in_store_settings_aggregate: brand_fulfillment_in_store_settings_aggregate_order_by
  name: order_by
  postal_settings_aggregate: brand_fulfillment_postal_settings_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_settings_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  fulfillment_type: fulfillment_types_enum
  id: uuid
  name: String
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_passwords\""
input brand_passwords_aggregate_order_by {
  count: order_by
  max: brand_passwords_max_order_by
  min: brand_passwords_min_order_by
}

"Boolean expression to filter rows from the table \"brand_passwords\". All fields are combined with a logical 'AND'."
input brand_passwords_bool_exp {
  _and: [brand_passwords_bool_exp!]
  _not: brand_passwords_bool_exp
  _or: [brand_passwords_bool_exp!]
  brand_id: uuid_comparison_exp
  enabled: Boolean_comparison_exp
}

"order by max() on columns of table \"brand_passwords\""
input brand_passwords_max_order_by {
  brand_id: order_by
}

"order by min() on columns of table \"brand_passwords\""
input brand_passwords_min_order_by {
  brand_id: order_by
}

"Ordering options when selecting data from \"brand_passwords\"."
input brand_passwords_order_by {
  brand_id: order_by
  enabled: order_by
}

"Streaming cursor of the table \"brand_passwords\""
input brand_passwords_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_passwords_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_passwords_stream_cursor_value_input {
  brand_id: uuid
  enabled: Boolean
}

"Boolean expression to filter rows from the table \"brands\". All fields are combined with a logical 'AND'."
input brands_bool_exp {
  _and: [brands_bool_exp!]
  _not: brands_bool_exp
  _or: [brands_bool_exp!]
  attribute_type_options: attribute_type_options_bool_exp
  attribute_types: attribute_types_bool_exp
  categories: brand_categories_bool_exp
  condition_questions: condition_questions_bool_exp
  content: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  fulfillment_settings: brand_fulfillment_settings_bool_exp
  id: uuid_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  name: String_comparison_exp
  passwords: brand_passwords_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  searchable_products_results: searchable_products_results_bool_exp
  searchable_products_results_aggregate: searchable_products_results_aggregate_bool_exp
  settings: jsonb_comparison_exp
  skus: skus_bool_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"brands\"."
input brands_order_by {
  attribute_type_options_aggregate: attribute_type_options_aggregate_order_by
  attribute_types_aggregate: attribute_types_aggregate_order_by
  categories_aggregate: brand_categories_aggregate_order_by
  condition_questions_aggregate: condition_questions_aggregate_order_by
  content: order_by
  created_at: order_by
  fulfillment_settings_aggregate: brand_fulfillment_settings_aggregate_order_by
  id: order_by
  listings_aggregate: listings_aggregate_order_by
  name: order_by
  passwords_aggregate: brand_passwords_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  searchable_products_results_aggregate: searchable_products_results_aggregate_order_by
  settings: order_by
  skus_aggregate: skus_aggregate_order_by
  slug: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brands\""
input brands_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brands_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brands_stream_cursor_value_input {
  content: jsonb
  created_at: timestamptz
  id: uuid
  name: String
  settings: jsonb
  slug: String
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"building_access_types_enum\". All fields are combined with logical 'AND'."
input building_access_types_enum_comparison_exp {
  _eq: building_access_types_enum
  _in: [building_access_types_enum!]
  _is_null: Boolean
  _neq: building_access_types_enum
  _nin: [building_access_types_enum!]
}

"Boolean expression to compare columns of type \"chat_channel_types_enum\". All fields are combined with logical 'AND'."
input chat_channel_types_enum_comparison_exp {
  _eq: chat_channel_types_enum
  _in: [chat_channel_types_enum!]
  _is_null: Boolean
  _neq: chat_channel_types_enum
  _nin: [chat_channel_types_enum!]
}

"Boolean expression to filter rows from the table \"chat_channels\". All fields are combined with a logical 'AND'."
input chat_channels_bool_exp {
  _and: [chat_channels_bool_exp!]
  _not: chat_channels_bool_exp
  _or: [chat_channels_bool_exp!]
  brand_id: uuid_comparison_exp
  channel_external_identifier: String_comparison_exp
  channel_type: chat_channel_types_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  key: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"chat_channels\"."
input chat_channels_order_by {
  brand_id: order_by
  channel_external_identifier: order_by
  channel_type: order_by
  created_at: order_by
  key: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"chat_channels\""
input chat_channels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: chat_channels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input chat_channels_stream_cursor_value_input {
  brand_id: uuid
  channel_external_identifier: String
  channel_type: chat_channel_types_enum
  created_at: timestamptz
  key: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"collapsed_product_results\". All fields are combined with a logical 'AND'."
input collapsed_product_results_bool_exp {
  _and: [collapsed_product_results_bool_exp!]
  _not: collapsed_product_results_bool_exp
  _or: [collapsed_product_results_bool_exp!]
  part_id: String_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"collapsed_product_results\"."
input collapsed_product_results_order_by {
  part_id: order_by
  product: products_order_by
  product_id: order_by
}

"Streaming cursor of the table \"collapsed_product_results\""
input collapsed_product_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collapsed_product_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collapsed_product_results_stream_cursor_value_input {
  part_id: String
  product_id: uuid
}

"Boolean expression to filter rows from the table \"collection_media_groups\". All fields are combined with a logical 'AND'."
input collection_media_groups_bool_exp {
  _and: [collection_media_groups_bool_exp!]
  _not: collection_media_groups_bool_exp
  _or: [collection_media_groups_bool_exp!]
  collection_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  media_group_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"collection_media_groups\"."
input collection_media_groups_order_by {
  collection_id: order_by
  created_at: order_by
  media_group_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"collection_media_groups\""
input collection_media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collection_media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collection_media_groups_stream_cursor_value_input {
  collection_id: uuid
  created_at: timestamptz
  media_group_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"collection_types_enum\". All fields are combined with logical 'AND'."
input collection_types_enum_comparison_exp {
  _eq: collection_types_enum
  _in: [collection_types_enum!]
  _is_null: Boolean
  _neq: collection_types_enum
  _nin: [collection_types_enum!]
}

"Boolean expression to filter rows from the table \"collections\". All fields are combined with a logical 'AND'."
input collections_bool_exp {
  _and: [collections_bool_exp!]
  _not: collections_bool_exp
  _or: [collections_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: collections_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  read_only: Boolean_comparison_exp
  slug: String_comparison_exp
  translations: collections_translations_bool_exp
  type: collection_types_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"collections\"."
input collections_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: collections_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  read_only: order_by
  slug: order_by
  translations_aggregate: collections_translations_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"collections\""
input collections_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collections_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collections_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  read_only: Boolean
  slug: String
  type: collection_types_enum
  updated_at: timestamptz
}

"order by aggregate values of table \"collections_translations\""
input collections_translations_aggregate_order_by {
  avg: collections_translations_avg_order_by
  count: order_by
  max: collections_translations_max_order_by
  min: collections_translations_min_order_by
  stddev: collections_translations_stddev_order_by
  stddev_pop: collections_translations_stddev_pop_order_by
  stddev_samp: collections_translations_stddev_samp_order_by
  sum: collections_translations_sum_order_by
  var_pop: collections_translations_var_pop_order_by
  var_samp: collections_translations_var_samp_order_by
  variance: collections_translations_variance_order_by
}

"order by avg() on columns of table \"collections_translations\""
input collections_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"collections_translations\". All fields are combined with a logical 'AND'."
input collections_translations_bool_exp {
  _and: [collections_translations_bool_exp!]
  _not: collections_translations_bool_exp
  _or: [collections_translations_bool_exp!]
  collection_id: uuid_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: Int_comparison_exp
  locale: String_comparison_exp
}

"order by max() on columns of table \"collections_translations\""
input collections_translations_max_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"order by min() on columns of table \"collections_translations\""
input collections_translations_min_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"Ordering options when selecting data from \"collections_translations\"."
input collections_translations_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"order by stddev() on columns of table \"collections_translations\""
input collections_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"collections_translations\""
input collections_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"collections_translations\""
input collections_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"collections_translations\""
input collections_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collections_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collections_translations_stream_cursor_value_input {
  collection_id: uuid
  description: String
  display_name: String
  id: Int
  locale: String
}

"order by sum() on columns of table \"collections_translations\""
input collections_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"collections_translations\""
input collections_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"collections_translations\""
input collections_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"collections_translations\""
input collections_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"condition_questions\""
input condition_questions_aggregate_order_by {
  avg: condition_questions_avg_order_by
  count: order_by
  max: condition_questions_max_order_by
  min: condition_questions_min_order_by
  stddev: condition_questions_stddev_order_by
  stddev_pop: condition_questions_stddev_pop_order_by
  stddev_samp: condition_questions_stddev_samp_order_by
  sum: condition_questions_sum_order_by
  var_pop: condition_questions_var_pop_order_by
  var_samp: condition_questions_var_samp_order_by
  variance: condition_questions_variance_order_by
}

"order by avg() on columns of table \"condition_questions\""
input condition_questions_avg_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"Boolean expression to filter rows from the table \"condition_questions\". All fields are combined with a logical 'AND'."
input condition_questions_bool_exp {
  _and: [condition_questions_bool_exp!]
  _not: condition_questions_bool_exp
  _or: [condition_questions_bool_exp!]
  addl_info_comment: Boolean_comparison_exp
  addl_info_comment_required: Boolean_comparison_exp
  addl_info_images: Boolean_comparison_exp
  addl_info_images_required: Boolean_comparison_exp
  addl_info_on_response_value: Boolean_comparison_exp
  addl_info_prompt: String_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: condition_questions_translations_bool_exp
  depends_on_question: condition_questions_bool_exp
  depends_on_question_id: uuid_comparison_exp
  depends_on_response_value: Boolean_comparison_exp
  fail_description: String_comparison_exp
  fail_on_response_value: Boolean_comparison_exp
  help_text: String_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing_description_false: String_comparison_exp
  listing_description_true: String_comparison_exp
  question_set_id: uuid_comparison_exp
  score_false: Int_comparison_exp
  score_true: Int_comparison_exp
  severity: Boolean_comparison_exp
  severity_on_response_value: Boolean_comparison_exp
  severity_text: String_comparison_exp
  text: String_comparison_exp
}

"order by max() on columns of table \"condition_questions\""
input condition_questions_max_order_by {
  addl_info_prompt: order_by
  brand_id: order_by
  depends_on_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity_text: order_by
  text: order_by
}

"order by min() on columns of table \"condition_questions\""
input condition_questions_min_order_by {
  addl_info_prompt: order_by
  brand_id: order_by
  depends_on_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity_text: order_by
  text: order_by
}

"Ordering options when selecting data from \"condition_questions\"."
input condition_questions_order_by {
  addl_info_comment: order_by
  addl_info_comment_required: order_by
  addl_info_images: order_by
  addl_info_images_required: order_by
  addl_info_on_response_value: order_by
  addl_info_prompt: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: condition_questions_translations_aggregate_order_by
  depends_on_question: condition_questions_order_by
  depends_on_question_id: order_by
  depends_on_response_value: order_by
  fail_description: order_by
  fail_on_response_value: order_by
  help_text: order_by
  hidden: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity: order_by
  severity_on_response_value: order_by
  severity_text: order_by
  text: order_by
}

"order by stddev() on columns of table \"condition_questions\""
input condition_questions_stddev_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by stddev_pop() on columns of table \"condition_questions\""
input condition_questions_stddev_pop_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by stddev_samp() on columns of table \"condition_questions\""
input condition_questions_stddev_samp_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"Streaming cursor of the table \"condition_questions\""
input condition_questions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_questions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_questions_stream_cursor_value_input {
  addl_info_comment: Boolean
  addl_info_comment_required: Boolean
  addl_info_images: Boolean
  addl_info_images_required: Boolean
  addl_info_on_response_value: Boolean
  addl_info_prompt: String
  brand_id: uuid
  depends_on_question_id: uuid
  depends_on_response_value: Boolean
  fail_description: String
  fail_on_response_value: Boolean
  help_text: String
  hidden: Boolean
  id: uuid
  index: Int
  listing_description_false: String
  listing_description_true: String
  question_set_id: uuid
  score_false: Int
  score_true: Int
  severity: Boolean
  severity_on_response_value: Boolean
  severity_text: String
  text: String
}

"order by sum() on columns of table \"condition_questions\""
input condition_questions_sum_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by aggregate values of table \"condition_questions_translations\""
input condition_questions_translations_aggregate_order_by {
  avg: condition_questions_translations_avg_order_by
  count: order_by
  max: condition_questions_translations_max_order_by
  min: condition_questions_translations_min_order_by
  stddev: condition_questions_translations_stddev_order_by
  stddev_pop: condition_questions_translations_stddev_pop_order_by
  stddev_samp: condition_questions_translations_stddev_samp_order_by
  sum: condition_questions_translations_sum_order_by
  var_pop: condition_questions_translations_var_pop_order_by
  var_samp: condition_questions_translations_var_samp_order_by
  variance: condition_questions_translations_variance_order_by
}

"order by avg() on columns of table \"condition_questions_translations\""
input condition_questions_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"condition_questions_translations\". All fields are combined with a logical 'AND'."
input condition_questions_translations_bool_exp {
  _and: [condition_questions_translations_bool_exp!]
  _not: condition_questions_translations_bool_exp
  _or: [condition_questions_translations_bool_exp!]
  addl_info_prompt: String_comparison_exp
  condition_question_id: uuid_comparison_exp
  fail_description: String_comparison_exp
  help_text: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  listing_description_false: String_comparison_exp
  listing_description_true: String_comparison_exp
  severity_text: String_comparison_exp
  text: String_comparison_exp
}

"order by max() on columns of table \"condition_questions_translations\""
input condition_questions_translations_max_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"order by min() on columns of table \"condition_questions_translations\""
input condition_questions_translations_min_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"Ordering options when selecting data from \"condition_questions_translations\"."
input condition_questions_translations_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"order by stddev() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"condition_questions_translations\""
input condition_questions_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_questions_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_questions_translations_stream_cursor_value_input {
  addl_info_prompt: String
  condition_question_id: uuid
  fail_description: String
  help_text: String
  id: Int
  lang: String
  listing_description_false: String
  listing_description_true: String
  severity_text: String
  text: String
}

"order by sum() on columns of table \"condition_questions_translations\""
input condition_questions_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"condition_questions_translations\""
input condition_questions_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"condition_questions_translations\""
input condition_questions_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"condition_questions_translations\""
input condition_questions_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"condition_questions\""
input condition_questions_var_pop_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by var_samp() on columns of table \"condition_questions\""
input condition_questions_var_samp_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by variance() on columns of table \"condition_questions\""
input condition_questions_variance_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by aggregate values of table \"condition_responses\""
input condition_responses_aggregate_order_by {
  avg: condition_responses_avg_order_by
  count: order_by
  max: condition_responses_max_order_by
  min: condition_responses_min_order_by
  stddev: condition_responses_stddev_order_by
  stddev_pop: condition_responses_stddev_pop_order_by
  stddev_samp: condition_responses_stddev_samp_order_by
  sum: condition_responses_sum_order_by
  var_pop: condition_responses_var_pop_order_by
  var_samp: condition_responses_var_samp_order_by
  variance: condition_responses_variance_order_by
}

"order by avg() on columns of table \"condition_responses\""
input condition_responses_avg_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"condition_responses\". All fields are combined with a logical 'AND'."
input condition_responses_bool_exp {
  _and: [condition_responses_bool_exp!]
  _not: condition_responses_bool_exp
  _or: [condition_responses_bool_exp!]
  comment: String_comparison_exp
  condition_question: condition_questions_bool_exp
  condition_question_id: uuid_comparison_exp
  id: uuid_comparison_exp
  images: listing_images_bool_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  response: Boolean_comparison_exp
  score: Int_comparison_exp
  severity: Int_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"condition_responses\""
input condition_responses_insert_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  images: listing_images_arr_rel_insert_input
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by max() on columns of table \"condition_responses\""
input condition_responses_max_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by min() on columns of table \"condition_responses\""
input condition_responses_min_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"condition_responses\""
input condition_responses_obj_rel_insert_input {
  data: condition_responses_insert_input!
  "upsert condition"
  on_conflict: condition_responses_on_conflict
}

"on_conflict condition type for table \"condition_responses\""
input condition_responses_on_conflict {
  constraint: condition_responses_constraint!
  update_columns: [condition_responses_update_column!]! = []
  where: condition_responses_bool_exp
}

"Ordering options when selecting data from \"condition_responses\"."
input condition_responses_order_by {
  comment: order_by
  condition_question: condition_questions_order_by
  condition_question_id: order_by
  id: order_by
  images_aggregate: listing_images_aggregate_order_by
  listing: listings_order_by
  listing_id: order_by
  response: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"condition_responses\""
input condition_responses_stddev_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_pop() on columns of table \"condition_responses\""
input condition_responses_stddev_pop_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_samp() on columns of table \"condition_responses\""
input condition_responses_stddev_samp_order_by {
  score: order_by
  severity: order_by
}

"Streaming cursor of the table \"condition_responses\""
input condition_responses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_responses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_responses_stream_cursor_value_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by sum() on columns of table \"condition_responses\""
input condition_responses_sum_order_by {
  score: order_by
  severity: order_by
}

"order by var_pop() on columns of table \"condition_responses\""
input condition_responses_var_pop_order_by {
  score: order_by
  severity: order_by
}

"order by var_samp() on columns of table \"condition_responses\""
input condition_responses_var_samp_order_by {
  score: order_by
  severity: order_by
}

"order by variance() on columns of table \"condition_responses\""
input condition_responses_variance_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"credit\". All fields are combined with a logical 'AND'."
input credit_bool_exp {
  _and: [credit_bool_exp!]
  _not: credit_bool_exp
  _or: [credit_bool_exp!]
  credit_takeback: takebacks_bool_exp
  credit_takeback_aggregate: takebacks_aggregate_bool_exp
  credit_takeback_item: takeback_items_bool_exp
  credit_type: credit_types_enum_comparison_exp
  currency_code: String_comparison_exp
  currency_value: Int_comparison_exp
  estimated_credit_takeback: takebacks_bool_exp
  estimated_credit_takeback_aggregate: takebacks_aggregate_bool_exp
  estimated_credit_takeback_item: takeback_items_bool_exp
  id: uuid_comparison_exp
}

"Ordering options when selecting data from \"credit\"."
input credit_order_by {
  credit_takeback_aggregate: takebacks_aggregate_order_by
  credit_takeback_item_aggregate: takeback_items_aggregate_order_by
  credit_type: order_by
  currency_code: order_by
  currency_value: order_by
  estimated_credit_takeback_aggregate: takebacks_aggregate_order_by
  estimated_credit_takeback_item_aggregate: takeback_items_aggregate_order_by
  id: order_by
}

"Streaming cursor of the table \"credit\""
input credit_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: credit_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input credit_stream_cursor_value_input {
  credit_type: credit_types_enum
  currency_code: String
  currency_value: Int
  id: uuid
}

"Boolean expression to compare columns of type \"credit_types_enum\". All fields are combined with logical 'AND'."
input credit_types_enum_comparison_exp {
  _eq: credit_types_enum
  _in: [credit_types_enum!]
  _is_null: Boolean
  _neq: credit_types_enum
  _nin: [credit_types_enum!]
}

"Boolean expression to filter rows from the table \"dac7_verified_storefronts\". All fields are combined with a logical 'AND'."
input dac7_verified_storefronts_bool_exp {
  _and: [dac7_verified_storefronts_bool_exp!]
  _not: dac7_verified_storefronts_bool_exp
  _or: [dac7_verified_storefronts_bool_exp!]
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"dac7_verified_storefronts\"."
input dac7_verified_storefronts_order_by {
  storefront: storefronts_order_by
  storefront_id: order_by
}

"Streaming cursor of the table \"dac7_verified_storefronts\""
input dac7_verified_storefronts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: dac7_verified_storefronts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input dac7_verified_storefronts_stream_cursor_value_input {
  storefront_id: uuid
}

"append existing jsonb value of filtered columns with new jsonb value"
input email_signups_append_input {
  payload: jsonb
}

"Boolean expression to filter rows from the table \"email_signups\". All fields are combined with a logical 'AND'."
input email_signups_bool_exp {
  _and: [email_signups_bool_exp!]
  _not: email_signups_bool_exp
  _or: [email_signups_bool_exp!]
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input email_signups_delete_at_path_input {
  payload: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input email_signups_delete_elem_input {
  payload: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input email_signups_delete_key_input {
  payload: String
}

"input type for inserting data into table \"email_signups\""
input email_signups_insert_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  interest_in_selling: Boolean
  payload: jsonb
  type: String
}

"on_conflict condition type for table \"email_signups\""
input email_signups_on_conflict {
  constraint: email_signups_constraint!
  update_columns: [email_signups_update_column!]! = []
  where: email_signups_bool_exp
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input email_signups_prepend_input {
  payload: jsonb
}

"input type for updating data in table \"email_signups\""
input email_signups_set_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  interest_in_selling: Boolean
  payload: jsonb
  type: String
}

input email_signups_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: email_signups_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: email_signups_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: email_signups_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: email_signups_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: email_signups_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: email_signups_set_input
  "filter the rows which have to be updated"
  where: email_signups_bool_exp!
}

"order by aggregate values of table \"external_sku_ids\""
input external_sku_ids_aggregate_order_by {
  count: order_by
  max: external_sku_ids_max_order_by
  min: external_sku_ids_min_order_by
}

"Boolean expression to filter rows from the table \"external_sku_ids\". All fields are combined with a logical 'AND'."
input external_sku_ids_bool_exp {
  _and: [external_sku_ids_bool_exp!]
  _not: external_sku_ids_bool_exp
  _or: [external_sku_ids_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  external_id: String_comparison_exp
  external_id_type: String_comparison_exp
  id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
}

"order by max() on columns of table \"external_sku_ids\""
input external_sku_ids_max_order_by {
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku_id: order_by
}

"order by min() on columns of table \"external_sku_ids\""
input external_sku_ids_min_order_by {
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku_id: order_by
}

"Ordering options when selecting data from \"external_sku_ids\"."
input external_sku_ids_order_by {
  brand: brands_order_by
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku: skus_order_by
  sku_id: order_by
}

"Streaming cursor of the table \"external_sku_ids\""
input external_sku_ids_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: external_sku_ids_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input external_sku_ids_stream_cursor_value_input {
  brand_id: uuid
  external_id: String
  external_id_type: String
  id: uuid
  sku_id: uuid
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"Boolean expression to filter rows from the table \"form_submissions\". All fields are combined with a logical 'AND'."
input form_submissions_bool_exp {
  _and: [form_submissions_bool_exp!]
  _not: form_submissions_bool_exp
  _or: [form_submissions_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  form: forms_bool_exp
  form_id: uuid_comparison_exp
  id: uuid_comparison_exp
  submission_data: jsonb_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"form_submissions\""
input form_submissions_insert_input {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  submission_data: jsonb
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"form_submissions\""
input form_submissions_on_conflict {
  constraint: form_submissions_constraint!
  update_columns: [form_submissions_update_column!]! = []
  where: form_submissions_bool_exp
}

"Ordering options when selecting data from \"form_submissions\"."
input form_submissions_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  form: forms_order_by
  form_id: order_by
  id: order_by
  submission_data: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"form_submissions\""
input form_submissions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: form_submissions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input form_submissions_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  submission_data: jsonb
  user_id: String
}

"Boolean expression to filter rows from the table \"forms\". All fields are combined with a logical 'AND'."
input forms_bool_exp {
  _and: [forms_bool_exp!]
  _not: forms_bool_exp
  _or: [forms_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"forms\"."
input forms_order_by {
  brand: brands_order_by
  brand_id: order_by
  id: order_by
  schema: order_by
  type: order_by
}

"Streaming cursor of the table \"forms\""
input forms_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: forms_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input forms_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  schema: jsonb
  type: String
}

"Boolean expression to filter rows from the table \"fulfillment_intents\". All fields are combined with a logical 'AND'."
input fulfillment_intents_bool_exp {
  _and: [fulfillment_intents_bool_exp!]
  _not: fulfillment_intents_bool_exp
  _or: [fulfillment_intents_bool_exp!]
  fulfillment_service: fulfillment_services_bool_exp
  id: uuid_comparison_exp
}

"Ordering options when selecting data from \"fulfillment_intents\"."
input fulfillment_intents_order_by {
  fulfillment_service: fulfillment_services_order_by
  id: order_by
}

"Streaming cursor of the table \"fulfillment_intents\""
input fulfillment_intents_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillment_intents_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillment_intents_stream_cursor_value_input {
  id: uuid
}

"Boolean expression to filter rows from the table \"fulfillment_services\". All fields are combined with a logical 'AND'."
input fulfillment_services_bool_exp {
  _and: [fulfillment_services_bool_exp!]
  _not: fulfillment_services_bool_exp
  _or: [fulfillment_services_bool_exp!]
  id: uuid_comparison_exp
  type: fulfillment_types_v2_enum_comparison_exp
}

"Ordering options when selecting data from \"fulfillment_services\"."
input fulfillment_services_order_by {
  id: order_by
  type: order_by
}

"Streaming cursor of the table \"fulfillment_services\""
input fulfillment_services_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillment_services_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillment_services_stream_cursor_value_input {
  id: uuid
  type: fulfillment_types_v2_enum
}

"Boolean expression to compare columns of type \"fulfillment_types_enum\". All fields are combined with logical 'AND'."
input fulfillment_types_enum_comparison_exp {
  _eq: fulfillment_types_enum
  _in: [fulfillment_types_enum!]
  _is_null: Boolean
  _neq: fulfillment_types_enum
  _nin: [fulfillment_types_enum!]
}

"Boolean expression to compare columns of type \"fulfillment_types_v2_enum\". All fields are combined with logical 'AND'."
input fulfillment_types_v2_enum_comparison_exp {
  _eq: fulfillment_types_v2_enum
  _in: [fulfillment_types_v2_enum!]
  _is_null: Boolean
  _neq: fulfillment_types_v2_enum
  _nin: [fulfillment_types_v2_enum!]
}

"Boolean expression to filter rows from the table \"fulfillments\". All fields are combined with a logical 'AND'."
input fulfillments_bool_exp {
  _and: [fulfillments_bool_exp!]
  _not: fulfillments_bool_exp
  _or: [fulfillments_bool_exp!]
  brand: brands_bool_exp
  fulfillment_intent: fulfillment_intents_bool_exp
  fulfillment_service: fulfillment_services_bool_exp
  fulfillment_service_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  shipping_label: shipping_labels_bool_exp
  storefront: storefronts_bool_exp
}

"Ordering options when selecting data from \"fulfillments\"."
input fulfillments_order_by {
  brand: brands_order_by
  fulfillment_intent: fulfillment_intents_order_by
  fulfillment_service: fulfillment_services_order_by
  fulfillment_service_id: order_by
  id: order_by
  order_items_aggregate: order_items_aggregate_order_by
  shipping_label: shipping_labels_order_by
  storefront: storefronts_order_by
}

"Streaming cursor of the table \"fulfillments\""
input fulfillments_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillments_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillments_stream_cursor_value_input {
  fulfillment_service_id: uuid
  id: uuid
}

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"Boolean expression to compare columns of type \"geography\". All fields are combined with logical 'AND'."
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]
  "is the column within a given distance from the given geography value"
  _st_d_within: st_d_within_geography_input
  "does the column spatially intersect the given geography value"
  _st_intersects: geography
}

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"Boolean expression to compare columns of type \"geometry\". All fields are combined with logical 'AND'."
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]
  "is the column within a given 3D distance from the given geometry value"
  _st_3d_d_within: st_d_within_input
  "does the column spatially intersect the given geometry value in 3D"
  _st_3d_intersects: geometry
  "does the column contain the given geometry value"
  _st_contains: geometry
  "does the column cross the given geometry value"
  _st_crosses: geometry
  "is the column within a given distance from the given geometry value"
  _st_d_within: st_d_within_input
  "is the column equal to given geometry value (directionality is ignored)"
  _st_equals: geometry
  "does the column spatially intersect the given geometry value"
  _st_intersects: geometry
  "does the column 'spatially overlap' (intersect but not completely contain) the given geometry value"
  _st_overlaps: geometry
  "does the column have atleast one point in common with the given geometry value"
  _st_touches: geometry
  "is the column contained in the given geometry value"
  _st_within: geometry
}

"Boolean expression to compare columns of type \"gift_card_statuses_enum\". All fields are combined with logical 'AND'."
input gift_card_statuses_enum_comparison_exp {
  _eq: gift_card_statuses_enum
  _in: [gift_card_statuses_enum!]
  _is_null: Boolean
  _neq: gift_card_statuses_enum
  _nin: [gift_card_statuses_enum!]
}

input gift_cards_aggregate_bool_exp {
  count: gift_cards_aggregate_bool_exp_count
}

input gift_cards_aggregate_bool_exp_count {
  arguments: [gift_cards_select_column!]
  distinct: Boolean
  filter: gift_cards_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"gift_cards\""
input gift_cards_aggregate_order_by {
  count: order_by
  max: gift_cards_max_order_by
  min: gift_cards_min_order_by
}

"Boolean expression to filter rows from the table \"gift_cards\". All fields are combined with a logical 'AND'."
input gift_cards_bool_exp {
  _and: [gift_cards_bool_exp!]
  _not: gift_cards_bool_exp
  _or: [gift_cards_bool_exp!]
  external_id: String_comparison_exp
  id: uuid_comparison_exp
  status: gift_card_statuses_enum_comparison_exp
  transaction: transactions_bool_exp
  transaction_id: uuid_comparison_exp
}

"order by max() on columns of table \"gift_cards\""
input gift_cards_max_order_by {
  external_id: order_by
  id: order_by
  transaction_id: order_by
}

"order by min() on columns of table \"gift_cards\""
input gift_cards_min_order_by {
  external_id: order_by
  id: order_by
  transaction_id: order_by
}

"Ordering options when selecting data from \"gift_cards\"."
input gift_cards_order_by {
  external_id: order_by
  id: order_by
  status: order_by
  transaction: transactions_order_by
  transaction_id: order_by
}

"Streaming cursor of the table \"gift_cards\""
input gift_cards_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: gift_cards_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input gift_cards_stream_cursor_value_input {
  external_id: String
  id: uuid
  status: gift_card_statuses_enum
  transaction_id: uuid
}

"Boolean expression to filter rows from the table \"images\". All fields are combined with a logical 'AND'."
input images_bool_exp {
  _and: [images_bool_exp!]
  _not: images_bool_exp
  _or: [images_bool_exp!]
  alt: String_comparison_exp
  created_at: timestamptz_comparison_exp
  href: String_comparison_exp
  id: uuid_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"images\"."
input images_order_by {
  alt: order_by
  created_at: order_by
  href: order_by
  id: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"images\""
input images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  href: String
  id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"in_store_pickup_statuses_enum\". All fields are combined with logical 'AND'."
input in_store_pickup_statuses_enum_comparison_exp {
  _eq: in_store_pickup_statuses_enum
  _in: [in_store_pickup_statuses_enum!]
  _is_null: Boolean
  _neq: in_store_pickup_statuses_enum
  _nin: [in_store_pickup_statuses_enum!]
}

"order by aggregate values of table \"in_store_pickups\""
input in_store_pickups_aggregate_order_by {
  count: order_by
  max: in_store_pickups_max_order_by
  min: in_store_pickups_min_order_by
}

"Boolean expression to filter rows from the table \"in_store_pickups\". All fields are combined with a logical 'AND'."
input in_store_pickups_bool_exp {
  _and: [in_store_pickups_bool_exp!]
  _not: in_store_pickups_bool_exp
  _or: [in_store_pickups_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  identifier: String_comparison_exp
  shipping_information: shipping_information_bool_exp
  shipping_information_id: uuid_comparison_exp
  status: in_store_pickup_statuses_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"in_store_pickups\""
input in_store_pickups_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"in_store_pickups\""
input in_store_pickups_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"in_store_pickups\"."
input in_store_pickups_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information: shipping_information_order_by
  shipping_information_id: order_by
  status: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"in_store_pickups\""
input in_store_pickups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: in_store_pickups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input in_store_pickups_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  identifier: String
  shipping_information_id: uuid
  status: in_store_pickup_statuses_enum
  updated_at: timestamptz
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"listing_auto_price_reduce\". All fields are combined with a logical 'AND'."
input listing_auto_price_reduce_bool_exp {
  _and: [listing_auto_price_reduce_bool_exp!]
  _not: listing_auto_price_reduce_bool_exp
  _or: [listing_auto_price_reduce_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  interval_days: Int_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  min_price: Int_comparison_exp
  percent: Int_comparison_exp
  price_updated_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_inc_input {
  interval_days: Int
  min_price: Int
  percent: Int
}

"input type for inserting data into table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_insert_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

"on_conflict condition type for table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_on_conflict {
  constraint: listing_auto_price_reduce_constraint!
  update_columns: [listing_auto_price_reduce_update_column!]! = []
  where: listing_auto_price_reduce_bool_exp
}

"Ordering options when selecting data from \"listing_auto_price_reduce\"."
input listing_auto_price_reduce_order_by {
  created_at: order_by
  id: order_by
  interval_days: order_by
  listing: listings_order_by
  listing_id: order_by
  min_price: order_by
  percent: order_by
  price_updated_at: order_by
  updated_at: order_by
  user_id: order_by
}

"primary key columns input for table: listing_auto_price_reduce"
input listing_auto_price_reduce_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_set_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

"Streaming cursor of the table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_auto_price_reduce_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_auto_price_reduce_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

input listing_auto_price_reduce_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: listing_auto_price_reduce_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: listing_auto_price_reduce_set_input
  "filter the rows which have to be updated"
  where: listing_auto_price_reduce_bool_exp!
}

"Boolean expression to filter rows from the table \"listing_channels\". All fields are combined with a logical 'AND'."
input listing_channels_bool_exp {
  _and: [listing_channels_bool_exp!]
  _not: listing_channels_bool_exp
  _or: [listing_channels_bool_exp!]
  brand_id: uuid_comparison_exp
  display: String_comparison_exp
  id: uuid_comparison_exp
  platform: listing_platforms_bool_exp
  platform_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"listing_channels\"."
input listing_channels_order_by {
  brand_id: order_by
  display: order_by
  id: order_by
  platform: listing_platforms_order_by
  platform_id: order_by
}

"Streaming cursor of the table \"listing_channels\""
input listing_channels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_channels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_channels_stream_cursor_value_input {
  brand_id: uuid
  display: String
  id: uuid
  platform_id: uuid
}

"Boolean expression to filter rows from the table \"listing_event_types\". All fields are combined with a logical 'AND'."
input listing_event_types_bool_exp {
  _and: [listing_event_types_bool_exp!]
  _not: listing_event_types_bool_exp
  _or: [listing_event_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"listing_event_types_enum\". All fields are combined with logical 'AND'."
input listing_event_types_enum_comparison_exp {
  _eq: listing_event_types_enum
  _in: [listing_event_types_enum!]
  _is_null: Boolean
  _neq: listing_event_types_enum
  _nin: [listing_event_types_enum!]
}

"Ordering options when selecting data from \"listing_event_types\"."
input listing_event_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"listing_event_types\""
input listing_event_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_event_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_event_types_stream_cursor_value_input {
  type: String
}

"order by aggregate values of table \"listing_events\""
input listing_events_aggregate_order_by {
  count: order_by
  max: listing_events_max_order_by
  min: listing_events_min_order_by
}

"Boolean expression to filter rows from the table \"listing_events\". All fields are combined with a logical 'AND'."
input listing_events_bool_exp {
  _and: [listing_events_bool_exp!]
  _not: listing_events_bool_exp
  _or: [listing_events_bool_exp!]
  event_type: listing_event_types_enum_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  listing_status: listing_statuses_enum_comparison_exp
  payload: jsonb_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_by_user: users_bool_exp
  value: String_comparison_exp
}

"order by max() on columns of table \"listing_events\""
input listing_events_max_order_by {
  id: order_by
  listing_id: order_by
  timestamp: order_by
  value: order_by
}

"order by min() on columns of table \"listing_events\""
input listing_events_min_order_by {
  id: order_by
  listing_id: order_by
  timestamp: order_by
  value: order_by
}

"Ordering options when selecting data from \"listing_events\"."
input listing_events_order_by {
  event_type: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  listing_status: order_by
  payload: order_by
  timestamp: order_by
  updated_by_user: users_order_by
  value: order_by
}

"Streaming cursor of the table \"listing_events\""
input listing_events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_events_stream_cursor_value_input {
  event_type: listing_event_types_enum
  id: uuid
  listing_id: uuid
  listing_status: listing_statuses_enum
  payload: jsonb
  timestamp: timestamptz
  value: String
}

"order by aggregate values of table \"listing_images\""
input listing_images_aggregate_order_by {
  avg: listing_images_avg_order_by
  count: order_by
  max: listing_images_max_order_by
  min: listing_images_min_order_by
  stddev: listing_images_stddev_order_by
  stddev_pop: listing_images_stddev_pop_order_by
  stddev_samp: listing_images_stddev_samp_order_by
  sum: listing_images_sum_order_by
  var_pop: listing_images_var_pop_order_by
  var_samp: listing_images_var_samp_order_by
  variance: listing_images_variance_order_by
}

"input type for inserting array relation for remote table \"listing_images\""
input listing_images_arr_rel_insert_input {
  data: [listing_images_insert_input!]!
  "upsert condition"
  on_conflict: listing_images_on_conflict
}

"order by avg() on columns of table \"listing_images\""
input listing_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"listing_images\". All fields are combined with a logical 'AND'."
input listing_images_bool_exp {
  _and: [listing_images_bool_exp!]
  _not: listing_images_bool_exp
  _or: [listing_images_bool_exp!]
  alt: String_comparison_exp
  condition_response: condition_responses_bool_exp
  condition_response_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  path: String_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"listing_images\""
input listing_images_insert_input {
  alt: String
  condition_response: condition_responses_obj_rel_insert_input
  condition_response_id: uuid
  created_at: timestamptz
  hidden: Boolean
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"listing_images\""
input listing_images_max_order_by {
  alt: order_by
  condition_response_id: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"listing_images\""
input listing_images_min_order_by {
  alt: order_by
  condition_response_id: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"listing_images\""
input listing_images_on_conflict {
  constraint: listing_images_constraint!
  update_columns: [listing_images_update_column!]! = []
  where: listing_images_bool_exp
}

"Ordering options when selecting data from \"listing_images\"."
input listing_images_order_by {
  alt: order_by
  condition_response: condition_responses_order_by
  condition_response_id: order_by
  created_at: order_by
  hidden: order_by
  id: order_by
  index: order_by
  listing: listings_order_by
  listing_id: order_by
  path: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"listing_images\""
input listing_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"listing_images\""
input listing_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"listing_images\""
input listing_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"listing_images\""
input listing_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_images_stream_cursor_value_input {
  alt: String
  condition_response_id: uuid
  created_at: timestamptz
  hidden: Boolean
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"listing_images\""
input listing_images_sum_order_by {
  index: order_by
}

"order by var_pop() on columns of table \"listing_images\""
input listing_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"listing_images\""
input listing_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"listing_images\""
input listing_images_variance_order_by {
  index: order_by
}

"order by aggregate values of table \"listing_metadata\""
input listing_metadata_aggregate_order_by {
  count: order_by
  max: listing_metadata_max_order_by
  min: listing_metadata_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input listing_metadata_append_input {
  value: jsonb
}

"Boolean expression to filter rows from the table \"listing_metadata\". All fields are combined with a logical 'AND'."
input listing_metadata_bool_exp {
  _and: [listing_metadata_bool_exp!]
  _not: listing_metadata_bool_exp
  _or: [listing_metadata_bool_exp!]
  id: uuid_comparison_exp
  key: String_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input listing_metadata_delete_at_path_input {
  value: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input listing_metadata_delete_elem_input {
  value: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input listing_metadata_delete_key_input {
  value: String
}

"input type for inserting data into table \"listing_metadata\""
input listing_metadata_insert_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

"order by max() on columns of table \"listing_metadata\""
input listing_metadata_max_order_by {
  id: order_by
  key: order_by
  listing_id: order_by
}

"order by min() on columns of table \"listing_metadata\""
input listing_metadata_min_order_by {
  id: order_by
  key: order_by
  listing_id: order_by
}

"on_conflict condition type for table \"listing_metadata\""
input listing_metadata_on_conflict {
  constraint: listing_metadata_constraint!
  update_columns: [listing_metadata_update_column!]! = []
  where: listing_metadata_bool_exp
}

"Ordering options when selecting data from \"listing_metadata\"."
input listing_metadata_order_by {
  id: order_by
  key: order_by
  listing: listings_order_by
  listing_id: order_by
  value: order_by
}

"primary key columns input for table: listing_metadata"
input listing_metadata_pk_columns_input {
  id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input listing_metadata_prepend_input {
  value: jsonb
}

"input type for updating data in table \"listing_metadata\""
input listing_metadata_set_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

"Streaming cursor of the table \"listing_metadata\""
input listing_metadata_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_metadata_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_metadata_stream_cursor_value_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

input listing_metadata_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: listing_metadata_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: listing_metadata_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: listing_metadata_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: listing_metadata_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: listing_metadata_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: listing_metadata_set_input
  "filter the rows which have to be updated"
  where: listing_metadata_bool_exp!
}

"Boolean expression to compare columns of type \"listing_platform_types_enum\". All fields are combined with logical 'AND'."
input listing_platform_types_enum_comparison_exp {
  _eq: listing_platform_types_enum
  _in: [listing_platform_types_enum!]
  _is_null: Boolean
  _neq: listing_platform_types_enum
  _nin: [listing_platform_types_enum!]
}

"Boolean expression to filter rows from the table \"listing_platforms\". All fields are combined with a logical 'AND'."
input listing_platforms_bool_exp {
  _and: [listing_platforms_bool_exp!]
  _not: listing_platforms_bool_exp
  _or: [listing_platforms_bool_exp!]
  id: uuid_comparison_exp
  type: listing_platform_types_enum_comparison_exp
}

"Ordering options when selecting data from \"listing_platforms\"."
input listing_platforms_order_by {
  id: order_by
  type: order_by
}

"Streaming cursor of the table \"listing_platforms\""
input listing_platforms_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_platforms_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_platforms_stream_cursor_value_input {
  id: uuid
  type: listing_platform_types_enum
}

"Boolean expression to filter rows from the table \"listing_relistings\". All fields are combined with a logical 'AND'."
input listing_relistings_bool_exp {
  _and: [listing_relistings_bool_exp!]
  _not: listing_relistings_bool_exp
  _or: [listing_relistings_bool_exp!]
  new_listing_id: uuid_comparison_exp
  previous_listing_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"listing_relistings\"."
input listing_relistings_order_by {
  new_listing_id: order_by
  previous_listing_id: order_by
}

"Streaming cursor of the table \"listing_relistings\""
input listing_relistings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_relistings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_relistings_stream_cursor_value_input {
  new_listing_id: uuid
  previous_listing_id: uuid
}

"Boolean expression to filter rows from the table \"listing_reviews\". All fields are combined with a logical 'AND'."
input listing_reviews_bool_exp {
  _and: [listing_reviews_bool_exp!]
  _not: listing_reviews_bool_exp
  _or: [listing_reviews_bool_exp!]
}

"input type for inserting data into table \"listing_reviews\""
input listing_reviews_insert_input {
  comments: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  outcome: listing_review_outcomes_enum
  updated_at: timestamptz
  user_id: String
}

"on_conflict condition type for table \"listing_reviews\""
input listing_reviews_on_conflict {
  constraint: listing_reviews_constraint!
  update_columns: [listing_reviews_update_column!]! = []
  where: listing_reviews_bool_exp
}

"Boolean expression to filter rows from the table \"listing_statuses\". All fields are combined with a logical 'AND'."
input listing_statuses_bool_exp {
  _and: [listing_statuses_bool_exp!]
  _not: listing_statuses_bool_exp
  _or: [listing_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"listing_statuses_enum\". All fields are combined with logical 'AND'."
input listing_statuses_enum_comparison_exp {
  _eq: listing_statuses_enum
  _in: [listing_statuses_enum!]
  _is_null: Boolean
  _neq: listing_statuses_enum
  _nin: [listing_statuses_enum!]
}

"Ordering options when selecting data from \"listing_statuses\"."
input listing_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"listing_statuses\""
input listing_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_statuses_stream_cursor_value_input {
  status: String
}

"Boolean expression to filter rows from the table \"listing_user_action_timestamp\". All fields are combined with a logical 'AND'."
input listing_user_action_timestamp_bool_exp {
  _and: [listing_user_action_timestamp_bool_exp!]
  _not: listing_user_action_timestamp_bool_exp
  _or: [listing_user_action_timestamp_bool_exp!]
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  user_action_timestamp: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"listing_user_action_timestamp\"."
input listing_user_action_timestamp_order_by {
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  user_action_timestamp: order_by
}

"Streaming cursor of the table \"listing_user_action_timestamp\""
input listing_user_action_timestamp_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_user_action_timestamp_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_user_action_timestamp_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  user_action_timestamp: timestamptz
}

"Boolean expression to compare columns of type \"listing_visibilities_enum\". All fields are combined with logical 'AND'."
input listing_visibilities_enum_comparison_exp {
  _eq: listing_visibilities_enum
  _in: [listing_visibilities_enum!]
  _is_null: Boolean
  _neq: listing_visibilities_enum
  _nin: [listing_visibilities_enum!]
}

input listings_aggregate_bool_exp {
  count: listings_aggregate_bool_exp_count
}

input listings_aggregate_bool_exp_count {
  arguments: [listings_select_column!]
  distinct: Boolean
  filter: listings_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"listings\""
input listings_aggregate_order_by {
  avg: listings_avg_order_by
  count: order_by
  max: listings_max_order_by
  min: listings_min_order_by
  stddev: listings_stddev_order_by
  stddev_pop: listings_stddev_pop_order_by
  stddev_samp: listings_stddev_samp_order_by
  sum: listings_sum_order_by
  var_pop: listings_var_pop_order_by
  var_samp: listings_var_samp_order_by
  variance: listings_variance_order_by
}

"order by avg() on columns of table \"listings\""
input listings_avg_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"Boolean expression to filter rows from the table \"listings\". All fields are combined with a logical 'AND'."
input listings_bool_exp {
  _and: [listings_bool_exp!]
  _not: listings_bool_exp
  _or: [listings_bool_exp!]
  auctions: auctions_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  bumped_at: timestamptz_comparison_exp
  channel: listing_channels_bool_exp
  channel_id: uuid_comparison_exp
  condition_responses: condition_responses_bool_exp
  condition_score: Int_comparison_exp
  confidence_score: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  events: listing_events_bool_exp
  id: uuid_comparison_exp
  images: listing_images_bool_exp
  listing_auto_price_reduce: listing_auto_price_reduce_bool_exp
  listing_metadata: listing_metadata_bool_exp
  listing_user_action_timestamp: listing_user_action_timestamp_bool_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  original_price: Int_comparison_exp
  price: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  relisted_listing: listing_relistings_bool_exp
  return_shipping_label: shipping_labels_bool_exp
  return_shipping_label_id: uuid_comparison_exp
  seller_comment: String_comparison_exp
  shipping_label: shipping_labels_bool_exp
  shipping_label_id: uuid_comparison_exp
  shipping_labels: shipping_labels_bool_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  status: listing_statuses_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  unassociated_listing_data: unassociated_listing_data_bool_exp
  unassociated_listing_data_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
  visibility: listing_visibilities_enum_comparison_exp
  wms_items: wms_items_bool_exp
}

"order by max() on columns of table \"listings\""
input listings_max_order_by {
  brand_id: order_by
  bumped_at: order_by
  channel_id: order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  id: order_by
  original_price: order_by
  price: order_by
  product_id: order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label_id: order_by
  sku_id: order_by
  storefront_id: order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"listings\""
input listings_min_order_by {
  brand_id: order_by
  bumped_at: order_by
  channel_id: order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  id: order_by
  original_price: order_by
  price: order_by
  product_id: order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label_id: order_by
  sku_id: order_by
  storefront_id: order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"listings\"."
input listings_order_by {
  auctions_aggregate: auctions_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  bumped_at: order_by
  channel: listing_channels_order_by
  channel_id: order_by
  condition_responses_aggregate: condition_responses_aggregate_order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  events_aggregate: listing_events_aggregate_order_by
  id: order_by
  images_aggregate: listing_images_aggregate_order_by
  listing_auto_price_reduce: listing_auto_price_reduce_order_by
  listing_metadata_aggregate: listing_metadata_aggregate_order_by
  listing_user_action_timestamp: listing_user_action_timestamp_order_by
  order_items_aggregate: order_items_aggregate_order_by
  original_price: order_by
  price: order_by
  product: products_order_by
  product_id: order_by
  relisted_listing: listing_relistings_order_by
  return_shipping_label: shipping_labels_order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label: shipping_labels_order_by
  shipping_label_id: order_by
  shipping_labels_aggregate: shipping_labels_aggregate_order_by
  sku: skus_order_by
  sku_id: order_by
  status: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  unassociated_listing_data: unassociated_listing_data_order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  visibility: order_by
  wms_items_aggregate: wms_items_aggregate_order_by
}

"order by stddev() on columns of table \"listings\""
input listings_stddev_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by stddev_pop() on columns of table \"listings\""
input listings_stddev_pop_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by stddev_samp() on columns of table \"listings\""
input listings_stddev_samp_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"Streaming cursor of the table \"listings\""
input listings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listings_stream_cursor_value_input {
  brand_id: uuid
  bumped_at: timestamptz
  channel_id: uuid
  condition_score: Int
  confidence_score: Int
  created_at: timestamptz
  id: uuid
  original_price: Int
  price: Int
  product_id: uuid
  return_shipping_label_id: uuid
  seller_comment: String
  shipping_label_id: uuid
  sku_id: uuid
  status: listing_statuses_enum
  storefront_id: uuid
  unassociated_listing_data_id: uuid
  updated_at: timestamptz
  user_id: String
  visibility: listing_visibilities_enum
}

"order by sum() on columns of table \"listings\""
input listings_sum_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by var_pop() on columns of table \"listings\""
input listings_var_pop_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by var_samp() on columns of table \"listings\""
input listings_var_samp_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by variance() on columns of table \"listings\""
input listings_variance_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by aggregate values of table \"mail_takebacks\""
input mail_takebacks_aggregate_order_by {
  count: order_by
  max: mail_takebacks_max_order_by
  min: mail_takebacks_min_order_by
}

"Boolean expression to filter rows from the table \"mail_takebacks\". All fields are combined with a logical 'AND'."
input mail_takebacks_bool_exp {
  _and: [mail_takebacks_bool_exp!]
  _not: mail_takebacks_bool_exp
  _or: [mail_takebacks_bool_exp!]
  id: uuid_comparison_exp
  return_address: addresses_bool_exp
  return_shipping_address_id: uuid_comparison_exp
  shipping_label: shipping_labels_bool_exp
  shipping_label_id: uuid_comparison_exp
  takeback: takebacks_bool_exp
  takeback_id: uuid_comparison_exp
}

"order by max() on columns of table \"mail_takebacks\""
input mail_takebacks_max_order_by {
  id: order_by
  return_shipping_address_id: order_by
  shipping_label_id: order_by
  takeback_id: order_by
}

"order by min() on columns of table \"mail_takebacks\""
input mail_takebacks_min_order_by {
  id: order_by
  return_shipping_address_id: order_by
  shipping_label_id: order_by
  takeback_id: order_by
}

"Ordering options when selecting data from \"mail_takebacks\"."
input mail_takebacks_order_by {
  id: order_by
  return_address: addresses_order_by
  return_shipping_address_id: order_by
  shipping_label: shipping_labels_order_by
  shipping_label_id: order_by
  takeback: takebacks_order_by
  takeback_id: order_by
}

"Streaming cursor of the table \"mail_takebacks\""
input mail_takebacks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: mail_takebacks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input mail_takebacks_stream_cursor_value_input {
  id: uuid
  return_shipping_address_id: uuid
  shipping_label_id: uuid
  takeback_id: uuid
}

"order by aggregate values of table \"media_group_items\""
input media_group_items_aggregate_order_by {
  avg: media_group_items_avg_order_by
  count: order_by
  max: media_group_items_max_order_by
  min: media_group_items_min_order_by
  stddev: media_group_items_stddev_order_by
  stddev_pop: media_group_items_stddev_pop_order_by
  stddev_samp: media_group_items_stddev_samp_order_by
  sum: media_group_items_sum_order_by
  var_pop: media_group_items_var_pop_order_by
  var_samp: media_group_items_var_samp_order_by
  variance: media_group_items_variance_order_by
}

"order by avg() on columns of table \"media_group_items\""
input media_group_items_avg_order_by {
  position: order_by
}

"Boolean expression to filter rows from the table \"media_group_items\". All fields are combined with a logical 'AND'."
input media_group_items_bool_exp {
  _and: [media_group_items_bool_exp!]
  _not: media_group_items_bool_exp
  _or: [media_group_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image: images_bool_exp
  image_id: uuid_comparison_exp
  media_group_id: uuid_comparison_exp
  position: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"media_group_items\""
input media_group_items_max_order_by {
  created_at: order_by
  id: order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"order by min() on columns of table \"media_group_items\""
input media_group_items_min_order_by {
  created_at: order_by
  id: order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"media_group_items\"."
input media_group_items_order_by {
  created_at: order_by
  id: order_by
  image: images_order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"media_group_items\""
input media_group_items_stddev_order_by {
  position: order_by
}

"order by stddev_pop() on columns of table \"media_group_items\""
input media_group_items_stddev_pop_order_by {
  position: order_by
}

"order by stddev_samp() on columns of table \"media_group_items\""
input media_group_items_stddev_samp_order_by {
  position: order_by
}

"Streaming cursor of the table \"media_group_items\""
input media_group_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: media_group_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input media_group_items_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  image_id: uuid
  media_group_id: uuid
  position: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"media_group_items\""
input media_group_items_sum_order_by {
  position: order_by
}

"order by var_pop() on columns of table \"media_group_items\""
input media_group_items_var_pop_order_by {
  position: order_by
}

"order by var_samp() on columns of table \"media_group_items\""
input media_group_items_var_samp_order_by {
  position: order_by
}

"order by variance() on columns of table \"media_group_items\""
input media_group_items_variance_order_by {
  position: order_by
}

"Boolean expression to filter rows from the table \"media_groups\". All fields are combined with a logical 'AND'."
input media_groups_bool_exp {
  _and: [media_groups_bool_exp!]
  _not: media_groups_bool_exp
  _or: [media_groups_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: media_group_items_bool_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"media_groups\"."
input media_groups_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: media_group_items_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"media_groups\""
input media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input media_groups_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"mobile_uploads\". All fields are combined with a logical 'AND'."
input mobile_uploads_bool_exp {
  _and: [mobile_uploads_bool_exp!]
  _not: mobile_uploads_bool_exp
  _or: [mobile_uploads_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  session_id: String_comparison_exp
}

"input type for inserting data into table \"mobile_uploads\""
input mobile_uploads_insert_input {
  created_at: timestamptz
  id: uuid
  path: String
  session_id: String
}

"on_conflict condition type for table \"mobile_uploads\""
input mobile_uploads_on_conflict {
  constraint: mobile_uploads_constraint!
  update_columns: [mobile_uploads_update_column!]! = []
  where: mobile_uploads_bool_exp
}

"Ordering options when selecting data from \"mobile_uploads\"."
input mobile_uploads_order_by {
  created_at: order_by
  id: order_by
  path: order_by
  session_id: order_by
}

"Streaming cursor of the table \"mobile_uploads\""
input mobile_uploads_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: mobile_uploads_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input mobile_uploads_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  path: String
  session_id: String
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"order_addresses\". All fields are combined with a logical 'AND'."
input order_addresses_bool_exp {
  _and: [order_addresses_bool_exp!]
  _not: order_addresses_bool_exp
  _or: [order_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  country: String_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  organization: String_comparison_exp
  phone_number: String_comparison_exp
  postal_code: String_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_addresses\""
input order_addresses_insert_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
}

"input type for inserting object relation for remote table \"order_addresses\""
input order_addresses_obj_rel_insert_input {
  data: order_addresses_insert_input!
  "upsert condition"
  on_conflict: order_addresses_on_conflict
}

"on_conflict condition type for table \"order_addresses\""
input order_addresses_on_conflict {
  constraint: order_addresses_constraint!
  update_columns: [order_addresses_update_column!]! = []
  where: order_addresses_bool_exp
}

"Ordering options when selecting data from \"order_addresses\"."
input order_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  user_id: order_by
}

"Streaming cursor of the table \"order_addresses\""
input order_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  user_id: String
}

"order by aggregate values of table \"order_intent_items\""
input order_intent_items_aggregate_order_by {
  avg: order_intent_items_avg_order_by
  count: order_by
  max: order_intent_items_max_order_by
  min: order_intent_items_min_order_by
  stddev: order_intent_items_stddev_order_by
  stddev_pop: order_intent_items_stddev_pop_order_by
  stddev_samp: order_intent_items_stddev_samp_order_by
  sum: order_intent_items_sum_order_by
  var_pop: order_intent_items_var_pop_order_by
  var_samp: order_intent_items_var_samp_order_by
  variance: order_intent_items_variance_order_by
}

"input type for inserting array relation for remote table \"order_intent_items\""
input order_intent_items_arr_rel_insert_input {
  data: [order_intent_items_insert_input!]!
  "upsert condition"
  on_conflict: order_intent_items_on_conflict
}

"order by avg() on columns of table \"order_intent_items\""
input order_intent_items_avg_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_intent_items\". All fields are combined with a logical 'AND'."
input order_intent_items_bool_exp {
  _and: [order_intent_items_bool_exp!]
  _not: order_intent_items_bool_exp
  _or: [order_intent_items_bool_exp!]
  fulfillment_intent: fulfillment_intents_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  order_intent: order_intents_bool_exp
  order_intent_id: uuid_comparison_exp
  price: Int_comparison_exp
  shipping_information: shipping_information_bool_exp
  shipping_information_id: uuid_comparison_exp
  tax: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_intent_items\""
input order_intent_items_insert_input {
  id: uuid
  listing_id: uuid
  order_intent: order_intents_obj_rel_insert_input
  order_intent_id: uuid
  price: Int
  shipping_information: shipping_information_obj_rel_insert_input
  shipping_information_id: uuid
  tax: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"order_intent_items\""
input order_intent_items_max_order_by {
  id: order_by
  listing_id: order_by
  order_intent_id: order_by
  price: order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"order_intent_items\""
input order_intent_items_min_order_by {
  id: order_by
  listing_id: order_by
  order_intent_id: order_by
  price: order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"order_intent_items\""
input order_intent_items_on_conflict {
  constraint: order_intent_items_constraint!
  update_columns: [order_intent_items_update_column!]! = []
  where: order_intent_items_bool_exp
}

"Ordering options when selecting data from \"order_intent_items\"."
input order_intent_items_order_by {
  fulfillment_intent: fulfillment_intents_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  order_intent: order_intents_order_by
  order_intent_id: order_by
  price: order_by
  shipping_information: shipping_information_order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"order_intent_items\""
input order_intent_items_stddev_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_pop() on columns of table \"order_intent_items\""
input order_intent_items_stddev_pop_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_samp() on columns of table \"order_intent_items\""
input order_intent_items_stddev_samp_order_by {
  price: order_by
  tax: order_by
}

"Streaming cursor of the table \"order_intent_items\""
input order_intent_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_intent_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_intent_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  order_intent_id: uuid
  price: Int
  shipping_information_id: uuid
  tax: Int
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"order_intent_items\""
input order_intent_items_sum_order_by {
  price: order_by
  tax: order_by
}

"order by var_pop() on columns of table \"order_intent_items\""
input order_intent_items_var_pop_order_by {
  price: order_by
  tax: order_by
}

"order by var_samp() on columns of table \"order_intent_items\""
input order_intent_items_var_samp_order_by {
  price: order_by
  tax: order_by
}

"order by variance() on columns of table \"order_intent_items\""
input order_intent_items_variance_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to compare columns of type \"order_intent_statuses_enum\". All fields are combined with logical 'AND'."
input order_intent_statuses_enum_comparison_exp {
  _eq: order_intent_statuses_enum
  _in: [order_intent_statuses_enum!]
  _is_null: Boolean
  _neq: order_intent_statuses_enum
  _nin: [order_intent_statuses_enum!]
}

"Boolean expression to filter rows from the table \"order_intents\". All fields are combined with a logical 'AND'."
input order_intents_bool_exp {
  _and: [order_intents_bool_exp!]
  _not: order_intents_bool_exp
  _or: [order_intents_bool_exp!]
  attempted_discount_codes: attempted_discount_codes_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: order_intent_items_bool_exp
  order_number: String_comparison_exp
  preferred_language: String_comparison_exp
  shipping: Int_comparison_exp
  shipping_address: order_addresses_bool_exp
  shipping_address_id: uuid_comparison_exp
  shipping_tax: Int_comparison_exp
  status: order_intent_statuses_enum_comparison_exp
  stripe_payment_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_intents\""
input order_intents_insert_input {
  attempted_discount_codes: attempted_discount_codes_arr_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: order_intent_items_arr_rel_insert_input
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address: order_addresses_obj_rel_insert_input
  shipping_address_id: uuid
  status: order_intent_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"input type for inserting object relation for remote table \"order_intents\""
input order_intents_obj_rel_insert_input {
  data: order_intents_insert_input!
  "upsert condition"
  on_conflict: order_intents_on_conflict
}

"on_conflict condition type for table \"order_intents\""
input order_intents_on_conflict {
  constraint: order_intents_constraint!
  update_columns: [order_intents_update_column!]! = []
  where: order_intents_bool_exp
}

"Ordering options when selecting data from \"order_intents\"."
input order_intents_order_by {
  attempted_discount_codes_aggregate: attempted_discount_codes_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: order_intent_items_aggregate_order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address: order_addresses_order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  status: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"order_intents\""
input order_intents_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_intents_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_intents_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_intent_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

input order_items_aggregate_bool_exp {
  count: order_items_aggregate_bool_exp_count
}

input order_items_aggregate_bool_exp_count {
  arguments: [order_items_select_column!]
  distinct: Boolean
  filter: order_items_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"order_items\""
input order_items_aggregate_order_by {
  avg: order_items_avg_order_by
  count: order_by
  max: order_items_max_order_by
  min: order_items_min_order_by
  stddev: order_items_stddev_order_by
  stddev_pop: order_items_stddev_pop_order_by
  stddev_samp: order_items_stddev_samp_order_by
  sum: order_items_sum_order_by
  var_pop: order_items_var_pop_order_by
  var_samp: order_items_var_samp_order_by
  variance: order_items_variance_order_by
}

"input type for inserting array relation for remote table \"order_items\""
input order_items_arr_rel_insert_input {
  data: [order_items_insert_input!]!
  "upsert condition"
  on_conflict: order_items_on_conflict
}

"order by avg() on columns of table \"order_items\""
input order_items_avg_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_items\". All fields are combined with a logical 'AND'."
input order_items_bool_exp {
  _and: [order_items_bool_exp!]
  _not: order_items_bool_exp
  _or: [order_items_bool_exp!]
  fulfillment: fulfillments_bool_exp
  fulfillment_intent: fulfillment_intents_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
  price: Int_comparison_exp
  return_items: return_items_bool_exp
  shipping_information: shipping_information_bool_exp
  tax: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_items\""
input order_items_insert_input {
  id: uuid
  listing_id: uuid
  order: orders_obj_rel_insert_input
  order_id: uuid
  price: Int
  return_items: return_items_arr_rel_insert_input
  shipping_information: shipping_information_obj_rel_insert_input
  tax: Int
  user: users_obj_rel_insert_input
}

"order by max() on columns of table \"order_items\""
input order_items_max_order_by {
  id: order_by
  listing_id: order_by
  order_id: order_by
  price: order_by
  tax: order_by
  user_id: order_by
}

"order by min() on columns of table \"order_items\""
input order_items_min_order_by {
  id: order_by
  listing_id: order_by
  order_id: order_by
  price: order_by
  tax: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"order_items\""
input order_items_obj_rel_insert_input {
  data: order_items_insert_input!
  "upsert condition"
  on_conflict: order_items_on_conflict
}

"on_conflict condition type for table \"order_items\""
input order_items_on_conflict {
  constraint: order_items_constraint!
  update_columns: [order_items_update_column!]! = []
  where: order_items_bool_exp
}

"Ordering options when selecting data from \"order_items\"."
input order_items_order_by {
  fulfillment: fulfillments_order_by
  fulfillment_intent: fulfillment_intents_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  order: orders_order_by
  order_id: order_by
  price: order_by
  return_items_aggregate: return_items_aggregate_order_by
  shipping_information: shipping_information_order_by
  tax: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"order_items\""
input order_items_stddev_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_pop() on columns of table \"order_items\""
input order_items_stddev_pop_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_samp() on columns of table \"order_items\""
input order_items_stddev_samp_order_by {
  price: order_by
  tax: order_by
}

"Streaming cursor of the table \"order_items\""
input order_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  order_id: uuid
  price: Int
  tax: Int
  user_id: String
}

"order by sum() on columns of table \"order_items\""
input order_items_sum_order_by {
  price: order_by
  tax: order_by
}

"order by var_pop() on columns of table \"order_items\""
input order_items_var_pop_order_by {
  price: order_by
  tax: order_by
}

"order by var_samp() on columns of table \"order_items\""
input order_items_var_samp_order_by {
  price: order_by
  tax: order_by
}

"order by variance() on columns of table \"order_items\""
input order_items_variance_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_statuses\". All fields are combined with a logical 'AND'."
input order_statuses_bool_exp {
  _and: [order_statuses_bool_exp!]
  _not: order_statuses_bool_exp
  _or: [order_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"order_statuses_enum\". All fields are combined with logical 'AND'."
input order_statuses_enum_comparison_exp {
  _eq: order_statuses_enum
  _in: [order_statuses_enum!]
  _is_null: Boolean
  _neq: order_statuses_enum
  _nin: [order_statuses_enum!]
}

"Ordering options when selecting data from \"order_statuses\"."
input order_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"order_statuses\""
input order_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_statuses_stream_cursor_value_input {
  status: String
}

input orders_aggregate_bool_exp {
  count: orders_aggregate_bool_exp_count
}

input orders_aggregate_bool_exp_count {
  arguments: [orders_select_column!]
  distinct: Boolean
  filter: orders_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"orders\""
input orders_aggregate_order_by {
  avg: orders_avg_order_by
  count: order_by
  max: orders_max_order_by
  min: orders_min_order_by
  stddev: orders_stddev_order_by
  stddev_pop: orders_stddev_pop_order_by
  stddev_samp: orders_stddev_samp_order_by
  sum: orders_sum_order_by
  var_pop: orders_var_pop_order_by
  var_samp: orders_var_samp_order_by
  variance: orders_variance_order_by
}

"input type for inserting array relation for remote table \"orders\""
input orders_arr_rel_insert_input {
  data: [orders_insert_input!]!
  "upsert condition"
  on_conflict: orders_on_conflict
}

"order by avg() on columns of table \"orders\""
input orders_avg_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"Boolean expression to filter rows from the table \"orders\". All fields are combined with a logical 'AND'."
input orders_bool_exp {
  _and: [orders_bool_exp!]
  _not: orders_bool_exp
  _or: [orders_bool_exp!]
  applied_discount_codes: applied_discount_codes_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: order_items_bool_exp
  items_aggregate: order_items_aggregate_bool_exp
  order_number: String_comparison_exp
  preferred_language: String_comparison_exp
  shipping: Int_comparison_exp
  shipping_address: order_addresses_bool_exp
  shipping_address_id: uuid_comparison_exp
  shipping_tax: Int_comparison_exp
  status: order_statuses_enum_comparison_exp
  stripe_payment_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orders\""
input orders_insert_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: order_items_arr_rel_insert_input
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address: order_addresses_obj_rel_insert_input
  shipping_address_id: uuid
  status: order_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"orders\""
input orders_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"orders\""
input orders_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"orders\""
input orders_obj_rel_insert_input {
  data: orders_insert_input!
  "upsert condition"
  on_conflict: orders_on_conflict
}

"on_conflict condition type for table \"orders\""
input orders_on_conflict {
  constraint: orders_constraint!
  update_columns: [orders_update_column!]! = []
  where: orders_bool_exp
}

"Ordering options when selecting data from \"orders\"."
input orders_order_by {
  applied_discount_codes_aggregate: applied_discount_codes_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: order_items_aggregate_order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address: order_addresses_order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  status: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orders\""
input orders_stddev_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by stddev_pop() on columns of table \"orders\""
input orders_stddev_pop_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by stddev_samp() on columns of table \"orders\""
input orders_stddev_samp_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"Streaming cursor of the table \"orders\""
input orders_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orders_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orders_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"orders\""
input orders_sum_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by var_pop() on columns of table \"orders\""
input orders_var_pop_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by var_samp() on columns of table \"orders\""
input orders_var_samp_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by variance() on columns of table \"orders\""
input orders_variance_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by aggregate values of table \"orphan_condition_responses\""
input orphan_condition_responses_aggregate_order_by {
  avg: orphan_condition_responses_avg_order_by
  count: order_by
  max: orphan_condition_responses_max_order_by
  min: orphan_condition_responses_min_order_by
  stddev: orphan_condition_responses_stddev_order_by
  stddev_pop: orphan_condition_responses_stddev_pop_order_by
  stddev_samp: orphan_condition_responses_stddev_samp_order_by
  sum: orphan_condition_responses_sum_order_by
  var_pop: orphan_condition_responses_var_pop_order_by
  var_samp: orphan_condition_responses_var_samp_order_by
  variance: orphan_condition_responses_variance_order_by
}

"input type for inserting array relation for remote table \"orphan_condition_responses\""
input orphan_condition_responses_arr_rel_insert_input {
  data: [orphan_condition_responses_insert_input!]!
  "upsert condition"
  on_conflict: orphan_condition_responses_on_conflict
}

"order by avg() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_avg_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"orphan_condition_responses\". All fields are combined with a logical 'AND'."
input orphan_condition_responses_bool_exp {
  _and: [orphan_condition_responses_bool_exp!]
  _not: orphan_condition_responses_bool_exp
  _or: [orphan_condition_responses_bool_exp!]
  comment: String_comparison_exp
  condition_question: condition_questions_bool_exp
  condition_question_id: uuid_comparison_exp
  id: uuid_comparison_exp
  images: orphan_listings_images_bool_exp
  listing_id: uuid_comparison_exp
  orphan_listing: orphan_listings_bool_exp
  response: Boolean_comparison_exp
  score: Int_comparison_exp
  severity: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orphan_condition_responses\""
input orphan_condition_responses_insert_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  images: orphan_listings_images_arr_rel_insert_input
  listing_id: uuid
  orphan_listing: orphan_listings_obj_rel_insert_input
  response: Boolean
  score: Int
  severity: Int
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_max_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by min() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_min_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"orphan_condition_responses\""
input orphan_condition_responses_obj_rel_insert_input {
  data: orphan_condition_responses_insert_input!
  "upsert condition"
  on_conflict: orphan_condition_responses_on_conflict
}

"on_conflict condition type for table \"orphan_condition_responses\""
input orphan_condition_responses_on_conflict {
  constraint: orphan_condition_responses_constraint!
  update_columns: [orphan_condition_responses_update_column!]! = []
  where: orphan_condition_responses_bool_exp
}

"Ordering options when selecting data from \"orphan_condition_responses\"."
input orphan_condition_responses_order_by {
  comment: order_by
  condition_question: condition_questions_order_by
  condition_question_id: order_by
  id: order_by
  images_aggregate: orphan_listings_images_aggregate_order_by
  listing_id: order_by
  orphan_listing: orphan_listings_order_by
  response: order_by
  score: order_by
  severity: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_pop() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_pop_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_samp() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_samp_order_by {
  score: order_by
  severity: order_by
}

"Streaming cursor of the table \"orphan_condition_responses\""
input orphan_condition_responses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_condition_responses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_condition_responses_stream_cursor_value_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by sum() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_sum_order_by {
  score: order_by
  severity: order_by
}

"order by var_pop() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_var_pop_order_by {
  score: order_by
  severity: order_by
}

"order by var_samp() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_var_samp_order_by {
  score: order_by
  severity: order_by
}

"order by variance() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_variance_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"orphan_listings\". All fields are combined with a logical 'AND'."
input orphan_listings_bool_exp {
  _and: [orphan_listings_bool_exp!]
  _not: orphan_listings_bool_exp
  _or: [orphan_listings_bool_exp!]
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  condition_responses: orphan_condition_responses_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  images: orphan_listings_images_bool_exp
  product_link: String_comparison_exp
  size: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by aggregate values of table \"orphan_listings_images\""
input orphan_listings_images_aggregate_order_by {
  avg: orphan_listings_images_avg_order_by
  count: order_by
  max: orphan_listings_images_max_order_by
  min: orphan_listings_images_min_order_by
  stddev: orphan_listings_images_stddev_order_by
  stddev_pop: orphan_listings_images_stddev_pop_order_by
  stddev_samp: orphan_listings_images_stddev_samp_order_by
  sum: orphan_listings_images_sum_order_by
  var_pop: orphan_listings_images_var_pop_order_by
  var_samp: orphan_listings_images_var_samp_order_by
  variance: orphan_listings_images_variance_order_by
}

"input type for inserting array relation for remote table \"orphan_listings_images\""
input orphan_listings_images_arr_rel_insert_input {
  data: [orphan_listings_images_insert_input!]!
  "upsert condition"
  on_conflict: orphan_listings_images_on_conflict
}

"order by avg() on columns of table \"orphan_listings_images\""
input orphan_listings_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"orphan_listings_images\". All fields are combined with a logical 'AND'."
input orphan_listings_images_bool_exp {
  _and: [orphan_listings_images_bool_exp!]
  _not: orphan_listings_images_bool_exp
  _or: [orphan_listings_images_bool_exp!]
  alt: String_comparison_exp
  condition_response: orphan_condition_responses_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing_id: uuid_comparison_exp
  path: String_comparison_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orphan_listings_images\""
input orphan_listings_images_insert_input {
  alt: String
  condition_response: orphan_condition_responses_obj_rel_insert_input
  created_at: timestamptz
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"orphan_listings_images\""
input orphan_listings_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"orphan_listings_images\""
input orphan_listings_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"orphan_listings_images\""
input orphan_listings_images_on_conflict {
  constraint: orphan_listings_images_constraint!
  update_columns: [orphan_listings_images_update_column!]! = []
  where: orphan_listings_images_bool_exp
}

"Ordering options when selecting data from \"orphan_listings_images\"."
input orphan_listings_images_order_by {
  alt: order_by
  condition_response: orphan_condition_responses_order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"orphan_listings_images\""
input orphan_listings_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_listings_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_listings_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"orphan_listings_images\""
input orphan_listings_images_sum_order_by {
  index: order_by
}

"order by var_pop() on columns of table \"orphan_listings_images\""
input orphan_listings_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"orphan_listings_images\""
input orphan_listings_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"orphan_listings_images\""
input orphan_listings_images_variance_order_by {
  index: order_by
}

"input type for inserting data into table \"orphan_listings\""
input orphan_listings_insert_input {
  brand_id: uuid
  color: String
  condition_responses: orphan_condition_responses_arr_rel_insert_input
  created_at: timestamptz
  description: String
  id: uuid
  images: orphan_listings_images_arr_rel_insert_input
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"input type for inserting object relation for remote table \"orphan_listings\""
input orphan_listings_obj_rel_insert_input {
  data: orphan_listings_insert_input!
  "upsert condition"
  on_conflict: orphan_listings_on_conflict
}

"on_conflict condition type for table \"orphan_listings\""
input orphan_listings_on_conflict {
  constraint: orphan_listings_constraint!
  update_columns: [orphan_listings_update_column!]! = []
  where: orphan_listings_bool_exp
}

"Ordering options when selecting data from \"orphan_listings\"."
input orphan_listings_order_by {
  brand_id: order_by
  color: order_by
  condition_responses_aggregate: orphan_condition_responses_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  images_aggregate: orphan_listings_images_aggregate_order_by
  product_link: order_by
  size: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"orphan_listings\""
input orphan_listings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_listings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_listings_stream_cursor_value_input {
  brand_id: uuid
  color: String
  created_at: timestamptz
  description: String
  id: uuid
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"photo_enhancement_request_statuses_enum\". All fields are combined with logical 'AND'."
input photo_enhancement_request_statuses_enum_comparison_exp {
  _eq: photo_enhancement_request_statuses_enum
  _in: [photo_enhancement_request_statuses_enum!]
  _is_null: Boolean
  _neq: photo_enhancement_request_statuses_enum
  _nin: [photo_enhancement_request_statuses_enum!]
}

"order by aggregate values of table \"photo_enhancement_requests\""
input photo_enhancement_requests_aggregate_order_by {
  count: order_by
  max: photo_enhancement_requests_max_order_by
  min: photo_enhancement_requests_min_order_by
}

"Boolean expression to filter rows from the table \"photo_enhancement_requests\". All fields are combined with a logical 'AND'."
input photo_enhancement_requests_bool_exp {
  _and: [photo_enhancement_requests_bool_exp!]
  _not: photo_enhancement_requests_bool_exp
  _or: [photo_enhancement_requests_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  external_id: String_comparison_exp
  id: uuid_comparison_exp
  image_id: uuid_comparison_exp
  listing_image_id: uuid_comparison_exp
  original_src: String_comparison_exp
  product_image_id: uuid_comparison_exp
  sku_image_id: uuid_comparison_exp
  src: String_comparison_exp
  status: photo_enhancement_request_statuses_enum_comparison_exp
  type: photo_enhancement_types_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"photo_enhancement_requests\""
input photo_enhancement_requests_max_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"photo_enhancement_requests\""
input photo_enhancement_requests_min_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"photo_enhancement_requests\"."
input photo_enhancement_requests_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  status: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"photo_enhancement_requests\""
input photo_enhancement_requests_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: photo_enhancement_requests_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input photo_enhancement_requests_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  external_id: String
  id: uuid
  image_id: uuid
  listing_image_id: uuid
  original_src: String
  product_image_id: uuid
  sku_image_id: uuid
  src: String
  status: photo_enhancement_request_statuses_enum
  type: photo_enhancement_types_enum
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"photo_enhancement_types_enum\". All fields are combined with logical 'AND'."
input photo_enhancement_types_enum_comparison_exp {
  _eq: photo_enhancement_types_enum
  _in: [photo_enhancement_types_enum!]
  _is_null: Boolean
  _neq: photo_enhancement_types_enum
  _nin: [photo_enhancement_types_enum!]
}

"Boolean expression to filter rows from the table \"pos_events\". All fields are combined with a logical 'AND'."
input pos_events_bool_exp {
  _and: [pos_events_bool_exp!]
  _not: pos_events_bool_exp
  _or: [pos_events_bool_exp!]
}

"input type for inserting data into table \"pos_events\""
input pos_events_insert_input {
  event_type: String
  id: uuid
  metadata: jsonb
  order_id: uuid
  pos_station_id: uuid
  timestamp: timestamptz
  user_id: String
}

"on_conflict condition type for table \"pos_events\""
input pos_events_on_conflict {
  constraint: pos_events_constraint!
  update_columns: [pos_events_update_column!]! = []
  where: pos_events_bool_exp
}

"order by aggregate values of table \"pos_stations\""
input pos_stations_aggregate_order_by {
  count: order_by
  max: pos_stations_max_order_by
  min: pos_stations_min_order_by
}

"Boolean expression to filter rows from the table \"pos_stations\". All fields are combined with a logical 'AND'."
input pos_stations_bool_exp {
  _and: [pos_stations_bool_exp!]
  _not: pos_stations_bool_exp
  _or: [pos_stations_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"pos_stations\""
input pos_stations_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"pos_stations\""
input pos_stations_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"pos_stations\"."
input pos_stations_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"pos_stations\""
input pos_stations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: pos_stations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input pos_stations_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  retail_store_id: uuid
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"postal_options\". All fields are combined with a logical 'AND'."
input postal_options_bool_exp {
  _and: [postal_options_bool_exp!]
  _not: postal_options_bool_exp
  _or: [postal_options_bool_exp!]
  carrier: shipping_carriers_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  method: shipping_methods_enum_comparison_exp
  service: shipping_services_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"postal_options\"."
input postal_options_order_by {
  carrier: order_by
  created_at: order_by
  id: order_by
  method: order_by
  service: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"postal_options\""
input postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input postal_options_stream_cursor_value_input {
  carrier: shipping_carriers_enum
  created_at: timestamptz
  id: uuid
  method: shipping_methods_enum
  service: shipping_services_enum
  updated_at: timestamptz
}

"order by aggregate values of table \"product_attribute_type_options\""
input product_attribute_type_options_aggregate_order_by {
  count: order_by
  max: product_attribute_type_options_max_order_by
  min: product_attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_attribute_type_options\". All fields are combined with a logical 'AND'."
input product_attribute_type_options_bool_exp {
  _and: [product_attribute_type_options_bool_exp!]
  _not: product_attribute_type_options_bool_exp
  _or: [product_attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  attribute_type_option: attribute_type_options_bool_exp
  attribute_type_option_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_attribute_type_options\""
input product_attribute_type_options_max_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_attribute_type_options\""
input product_attribute_type_options_min_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_attribute_type_options\"."
input product_attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  attribute_type_option: attribute_type_options_order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product: products_order_by
  product_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"product_attribute_type_options\""
input product_attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  attribute_type_option_id: uuid
  created_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"product_colors\""
input product_colors_aggregate_order_by {
  count: order_by
  max: product_colors_max_order_by
  min: product_colors_min_order_by
}

"Boolean expression to filter rows from the table \"product_colors\". All fields are combined with a logical 'AND'."
input product_colors_bool_exp {
  _and: [product_colors_bool_exp!]
  _not: product_colors_bool_exp
  _or: [product_colors_bool_exp!]
  color: String_comparison_exp
  content: product_colors_translations_bool_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_colors_translations: product_colors_translations_bool_exp
  product_colors_translations_aggregate: product_colors_translations_aggregate_bool_exp
  product_id: uuid_comparison_exp
  uid: String_comparison_exp
}

"order by max() on columns of table \"product_colors\""
input product_colors_max_order_by {
  color: order_by
  id: order_by
  product_id: order_by
  uid: order_by
}

"order by min() on columns of table \"product_colors\""
input product_colors_min_order_by {
  color: order_by
  id: order_by
  product_id: order_by
  uid: order_by
}

"Ordering options when selecting data from \"product_colors\"."
input product_colors_order_by {
  color: order_by
  content_aggregate: product_colors_translations_aggregate_order_by
  id: order_by
  product: products_order_by
  product_colors_translations_aggregate: product_colors_translations_aggregate_order_by
  product_id: order_by
  uid: order_by
}

"Streaming cursor of the table \"product_colors\""
input product_colors_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_colors_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_colors_stream_cursor_value_input {
  color: String
  id: uuid
  product_id: uuid
  uid: String
}

input product_colors_translations_aggregate_bool_exp {
  count: product_colors_translations_aggregate_bool_exp_count
}

input product_colors_translations_aggregate_bool_exp_count {
  arguments: [product_colors_translations_select_column!]
  distinct: Boolean
  filter: product_colors_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_colors_translations\""
input product_colors_translations_aggregate_order_by {
  avg: product_colors_translations_avg_order_by
  count: order_by
  max: product_colors_translations_max_order_by
  min: product_colors_translations_min_order_by
  stddev: product_colors_translations_stddev_order_by
  stddev_pop: product_colors_translations_stddev_pop_order_by
  stddev_samp: product_colors_translations_stddev_samp_order_by
  sum: product_colors_translations_sum_order_by
  var_pop: product_colors_translations_var_pop_order_by
  var_samp: product_colors_translations_var_samp_order_by
  variance: product_colors_translations_variance_order_by
}

"order by avg() on columns of table \"product_colors_translations\""
input product_colors_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_colors_translations\". All fields are combined with a logical 'AND'."
input product_colors_translations_bool_exp {
  _and: [product_colors_translations_bool_exp!]
  _not: product_colors_translations_bool_exp
  _or: [product_colors_translations_bool_exp!]
  color: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  product_color_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_colors_translations\""
input product_colors_translations_max_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"order by min() on columns of table \"product_colors_translations\""
input product_colors_translations_min_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"Ordering options when selecting data from \"product_colors_translations\"."
input product_colors_translations_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"order by stddev() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_colors_translations\""
input product_colors_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_colors_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_colors_translations_stream_cursor_value_input {
  color: String
  id: Int
  lang: String
  product_color_id: uuid
}

"order by sum() on columns of table \"product_colors_translations\""
input product_colors_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_colors_translations\""
input product_colors_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_colors_translations\""
input product_colors_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_colors_translations\""
input product_colors_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"product_images\""
input product_images_aggregate_order_by {
  avg: product_images_avg_order_by
  count: order_by
  max: product_images_max_order_by
  min: product_images_min_order_by
  stddev: product_images_stddev_order_by
  stddev_pop: product_images_stddev_pop_order_by
  stddev_samp: product_images_stddev_samp_order_by
  sum: product_images_sum_order_by
  var_pop: product_images_var_pop_order_by
  var_samp: product_images_var_samp_order_by
  variance: product_images_variance_order_by
}

"order by avg() on columns of table \"product_images\""
input product_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"product_images\". All fields are combined with a logical 'AND'."
input product_images_bool_exp {
  _and: [product_images_bool_exp!]
  _not: product_images_bool_exp
  _or: [product_images_bool_exp!]
  alt: String_comparison_exp
  content: product_images_translations_bool_exp
  created_at: timestamptz_comparison_exp
  detail: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  primary: Boolean_comparison_exp
  primary_hover: Boolean_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_images_translations: product_images_translations_bool_exp
  product_images_translations_aggregate: product_images_translations_aggregate_bool_exp
  src: String_comparison_exp
  swatch: Boolean_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_images\""
input product_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  product_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_images\""
input product_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  product_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_images\"."
input product_images_order_by {
  alt: order_by
  content_aggregate: product_images_translations_aggregate_order_by
  created_at: order_by
  detail: order_by
  id: order_by
  index: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  primary: order_by
  primary_hover: order_by
  product: products_order_by
  product_id: order_by
  product_images_translations_aggregate: product_images_translations_aggregate_order_by
  src: order_by
  swatch: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"product_images\""
input product_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"product_images\""
input product_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"product_images\""
input product_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"product_images\""
input product_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  detail: Boolean
  id: uuid
  index: Int
  primary: Boolean
  primary_hover: Boolean
  product_id: uuid
  src: String
  swatch: Boolean
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"product_images\""
input product_images_sum_order_by {
  index: order_by
}

input product_images_translations_aggregate_bool_exp {
  count: product_images_translations_aggregate_bool_exp_count
}

input product_images_translations_aggregate_bool_exp_count {
  arguments: [product_images_translations_select_column!]
  distinct: Boolean
  filter: product_images_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_images_translations\""
input product_images_translations_aggregate_order_by {
  avg: product_images_translations_avg_order_by
  count: order_by
  max: product_images_translations_max_order_by
  min: product_images_translations_min_order_by
  stddev: product_images_translations_stddev_order_by
  stddev_pop: product_images_translations_stddev_pop_order_by
  stddev_samp: product_images_translations_stddev_samp_order_by
  sum: product_images_translations_sum_order_by
  var_pop: product_images_translations_var_pop_order_by
  var_samp: product_images_translations_var_samp_order_by
  variance: product_images_translations_variance_order_by
}

"order by avg() on columns of table \"product_images_translations\""
input product_images_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_images_translations\". All fields are combined with a logical 'AND'."
input product_images_translations_bool_exp {
  _and: [product_images_translations_bool_exp!]
  _not: product_images_translations_bool_exp
  _or: [product_images_translations_bool_exp!]
  alt: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  product_image_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_images_translations\""
input product_images_translations_max_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"order by min() on columns of table \"product_images_translations\""
input product_images_translations_min_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"Ordering options when selecting data from \"product_images_translations\"."
input product_images_translations_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"order by stddev() on columns of table \"product_images_translations\""
input product_images_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_images_translations\""
input product_images_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_images_translations\""
input product_images_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_images_translations\""
input product_images_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_images_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_images_translations_stream_cursor_value_input {
  alt: String
  id: Int
  lang: String
  product_image_id: uuid
}

"order by sum() on columns of table \"product_images_translations\""
input product_images_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_images_translations\""
input product_images_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_images_translations\""
input product_images_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_images_translations\""
input product_images_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_images\""
input product_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"product_images\""
input product_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"product_images\""
input product_images_variance_order_by {
  index: order_by
}

"order by aggregate values of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_aggregate_order_by {
  count: order_by
  max: product_style_attribute_type_options_max_order_by
  min: product_style_attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_attribute_type_options\". All fields are combined with a logical 'AND'."
input product_style_attribute_type_options_bool_exp {
  _and: [product_style_attribute_type_options_bool_exp!]
  _not: product_style_attribute_type_options_bool_exp
  _or: [product_style_attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  attribute_type_option: attribute_type_options_bool_exp
  attribute_type_option_id: uuid_comparison_exp
  id: uuid_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_max_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style_id: order_by
}

"order by min() on columns of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_min_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style_id: order_by
}

"Ordering options when selecting data from \"product_style_attribute_type_options\"."
input product_style_attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  attribute_type_option: attribute_type_options_order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
}

"Streaming cursor of the table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  attribute_type_option_id: uuid
  id: uuid
  product_style_id: uuid
}

"Boolean expression to compare columns of type \"product_style_sources_enum\". All fields are combined with logical 'AND'."
input product_style_sources_enum_comparison_exp {
  _eq: product_style_sources_enum
  _in: [product_style_sources_enum!]
  _is_null: Boolean
  _neq: product_style_sources_enum
  _nin: [product_style_sources_enum!]
}

"order by aggregate values of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_aggregate_order_by {
  count: order_by
  max: product_style_variant_media_groups_max_order_by
  min: product_style_variant_media_groups_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_variant_media_groups\". All fields are combined with a logical 'AND'."
input product_style_variant_media_groups_bool_exp {
  _and: [product_style_variant_media_groups_bool_exp!]
  _not: product_style_variant_media_groups_bool_exp
  _or: [product_style_variant_media_groups_bool_exp!]
  created_at: timestamptz_comparison_exp
  media_group: media_groups_bool_exp
  media_group_id: uuid_comparison_exp
  product_style_variant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_max_order_by {
  created_at: order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_min_order_by {
  created_at: order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_style_variant_media_groups\"."
input product_style_variant_media_groups_order_by {
  created_at: order_by
  media_group: media_groups_order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variant_media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variant_media_groups_stream_cursor_value_input {
  created_at: timestamptz
  media_group_id: uuid
  product_style_variant_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"product_style_variant_options\""
input product_style_variant_options_aggregate_order_by {
  count: order_by
  max: product_style_variant_options_max_order_by
  min: product_style_variant_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_variant_options\". All fields are combined with a logical 'AND'."
input product_style_variant_options_bool_exp {
  _and: [product_style_variant_options_bool_exp!]
  _not: product_style_variant_options_bool_exp
  _or: [product_style_variant_options_bool_exp!]
  product_style_variant_id: uuid_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_option: variant_type_options_bool_exp
  variant_type_option_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_style_variant_options\""
input product_style_variant_options_max_order_by {
  product_style_variant_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"product_style_variant_options\""
input product_style_variant_options_min_order_by {
  product_style_variant_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"product_style_variant_options\"."
input product_style_variant_options_order_by {
  product_style_variant_id: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_option: variant_type_options_order_by
  variant_type_option_id: order_by
}

"Streaming cursor of the table \"product_style_variant_options\""
input product_style_variant_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variant_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variant_options_stream_cursor_value_input {
  product_style_variant_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"order by aggregate values of table \"product_style_variants\""
input product_style_variants_aggregate_order_by {
  avg: product_style_variants_avg_order_by
  count: order_by
  max: product_style_variants_max_order_by
  min: product_style_variants_min_order_by
  stddev: product_style_variants_stddev_order_by
  stddev_pop: product_style_variants_stddev_pop_order_by
  stddev_samp: product_style_variants_stddev_samp_order_by
  sum: product_style_variants_sum_order_by
  var_pop: product_style_variants_var_pop_order_by
  var_samp: product_style_variants_var_samp_order_by
  variance: product_style_variants_variance_order_by
}

"order by avg() on columns of table \"product_style_variants\""
input product_style_variants_avg_order_by {
  price: order_by
}

"Boolean expression to filter rows from the table \"product_style_variants\". All fields are combined with a logical 'AND'."
input product_style_variants_bool_exp {
  _and: [product_style_variants_bool_exp!]
  _not: product_style_variants_bool_exp
  _or: [product_style_variants_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  media_groups: product_style_variant_media_groups_bool_exp
  price: Int_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  product_style_variant: String_comparison_exp
  product_style_variant_options: product_style_variant_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_style_variants\""
input product_style_variants_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
  product_style_id: order_by
  product_style_variant: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_style_variants\""
input product_style_variants_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
  product_style_id: order_by
  product_style_variant: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_style_variants\"."
input product_style_variants_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  media_groups_aggregate: product_style_variant_media_groups_aggregate_order_by
  price: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  product_style_variant: order_by
  product_style_variant_options_aggregate: product_style_variant_options_aggregate_order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"product_style_variants\""
input product_style_variants_stddev_order_by {
  price: order_by
}

"order by stddev_pop() on columns of table \"product_style_variants\""
input product_style_variants_stddev_pop_order_by {
  price: order_by
}

"order by stddev_samp() on columns of table \"product_style_variants\""
input product_style_variants_stddev_samp_order_by {
  price: order_by
}

"Streaming cursor of the table \"product_style_variants\""
input product_style_variants_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variants_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variants_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  price: Int
  product_style_id: uuid
  product_style_variant: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"product_style_variants\""
input product_style_variants_sum_order_by {
  price: order_by
}

"order by var_pop() on columns of table \"product_style_variants\""
input product_style_variants_var_pop_order_by {
  price: order_by
}

"order by var_samp() on columns of table \"product_style_variants\""
input product_style_variants_var_samp_order_by {
  price: order_by
}

"order by variance() on columns of table \"product_style_variants\""
input product_style_variants_variance_order_by {
  price: order_by
}

"Boolean expression to filter rows from the table \"product_styles\". All fields are combined with a logical 'AND'."
input product_styles_bool_exp {
  _and: [product_styles_bool_exp!]
  _not: product_styles_bool_exp
  _or: [product_styles_bool_exp!]
  attribute_type_options: product_style_attribute_type_options_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  content: product_styles_translations_bool_exp
  disallow_listing: Boolean_comparison_exp
  id: uuid_comparison_exp
  price: Int_comparison_exp
  product_style: String_comparison_exp
  product_style_variants: product_style_variants_bool_exp
  product_styles_translations: product_styles_translations_bool_exp
  product_styles_translations_aggregate: product_styles_translations_aggregate_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  skus: skus_bool_exp
  source: product_style_sources_enum_comparison_exp
}

"Boolean expression to filter rows from the table \"product_styles_listed\". All fields are combined with a logical 'AND'."
input product_styles_listed_bool_exp {
  _and: [product_styles_listed_bool_exp!]
  _not: product_styles_listed_bool_exp
  _or: [product_styles_listed_bool_exp!]
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  sizes: String_comparison_exp
}

"Ordering options when selecting data from \"product_styles_listed\"."
input product_styles_listed_order_by {
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  sizes: order_by
}

"Streaming cursor of the table \"product_styles_listed\""
input product_styles_listed_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_listed_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_listed_stream_cursor_value_input {
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  product_style_id: uuid
  sizes: String
}

"Ordering options when selecting data from \"product_styles\"."
input product_styles_order_by {
  attribute_type_options_aggregate: product_style_attribute_type_options_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  category: brand_categories_order_by
  category_id: order_by
  content_aggregate: product_styles_translations_aggregate_order_by
  disallow_listing: order_by
  id: order_by
  price: order_by
  product_style: order_by
  product_style_variants_aggregate: product_style_variants_aggregate_order_by
  product_styles_translations_aggregate: product_styles_translations_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  skus_aggregate: skus_aggregate_order_by
  source: order_by
}

"Streaming cursor of the table \"product_styles\""
input product_styles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  disallow_listing: Boolean
  id: uuid
  price: Int
  product_style: String
  source: product_style_sources_enum
}

input product_styles_translations_aggregate_bool_exp {
  count: product_styles_translations_aggregate_bool_exp_count
}

input product_styles_translations_aggregate_bool_exp_count {
  arguments: [product_styles_translations_select_column!]
  distinct: Boolean
  filter: product_styles_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_styles_translations\""
input product_styles_translations_aggregate_order_by {
  avg: product_styles_translations_avg_order_by
  count: order_by
  max: product_styles_translations_max_order_by
  min: product_styles_translations_min_order_by
  stddev: product_styles_translations_stddev_order_by
  stddev_pop: product_styles_translations_stddev_pop_order_by
  stddev_samp: product_styles_translations_stddev_samp_order_by
  sum: product_styles_translations_sum_order_by
  var_pop: product_styles_translations_var_pop_order_by
  var_samp: product_styles_translations_var_samp_order_by
  variance: product_styles_translations_variance_order_by
}

"order by avg() on columns of table \"product_styles_translations\""
input product_styles_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_styles_translations\". All fields are combined with a logical 'AND'."
input product_styles_translations_bool_exp {
  _and: [product_styles_translations_bool_exp!]
  _not: product_styles_translations_bool_exp
  _or: [product_styles_translations_bool_exp!]
  description: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  product_style_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_styles_translations\""
input product_styles_translations_max_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"order by min() on columns of table \"product_styles_translations\""
input product_styles_translations_min_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"Ordering options when selecting data from \"product_styles_translations\"."
input product_styles_translations_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"order by stddev() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_styles_translations\""
input product_styles_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_translations_stream_cursor_value_input {
  description: String
  id: Int
  lang: String
  name: String
  product_style_id: uuid
}

"order by sum() on columns of table \"product_styles_translations\""
input product_styles_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_styles_translations\""
input product_styles_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_styles_translations\""
input product_styles_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_styles_translations\""
input product_styles_translations_variance_order_by {
  id: order_by
}

input product_tags_aggregate_bool_exp {
  count: product_tags_aggregate_bool_exp_count
}

input product_tags_aggregate_bool_exp_count {
  arguments: [product_tags_select_column!]
  distinct: Boolean
  filter: product_tags_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_tags\""
input product_tags_aggregate_order_by {
  count: order_by
  max: product_tags_max_order_by
  min: product_tags_min_order_by
}

"Boolean expression to filter rows from the table \"product_tags\". All fields are combined with a logical 'AND'."
input product_tags_bool_exp {
  _and: [product_tags_bool_exp!]
  _not: product_tags_bool_exp
  _or: [product_tags_bool_exp!]
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  value: String_comparison_exp
}

"order by max() on columns of table \"product_tags\""
input product_tags_max_order_by {
  id: order_by
  product_id: order_by
  value: order_by
}

"order by min() on columns of table \"product_tags\""
input product_tags_min_order_by {
  id: order_by
  product_id: order_by
  value: order_by
}

"Ordering options when selecting data from \"product_tags\"."
input product_tags_order_by {
  id: order_by
  product: products_order_by
  product_id: order_by
  value: order_by
}

"Streaming cursor of the table \"product_tags\""
input product_tags_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_tags_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_tags_stream_cursor_value_input {
  id: uuid
  product_id: uuid
  value: String
}

input products_aggregate_bool_exp {
  bool_and: products_aggregate_bool_exp_bool_and
  bool_or: products_aggregate_bool_exp_bool_or
  count: products_aggregate_bool_exp_count
}

input products_aggregate_bool_exp_bool_and {
  arguments: products_select_column_products_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_bool_or {
  arguments: products_select_column_products_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_count {
  arguments: [products_select_column!]
  distinct: Boolean
  filter: products_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"products\""
input products_aggregate_order_by {
  avg: products_avg_order_by
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
  stddev: products_stddev_order_by
  stddev_pop: products_stddev_pop_order_by
  stddev_samp: products_stddev_samp_order_by
  sum: products_sum_order_by
  var_pop: products_var_pop_order_by
  var_samp: products_var_samp_order_by
  variance: products_variance_order_by
}

"order by avg() on columns of table \"products\""
input products_avg_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Boolean expression to filter rows from the table \"products\". All fields are combined with a logical 'AND'."
input products_bool_exp {
  _and: [products_bool_exp!]
  _not: products_bool_exp
  _or: [products_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  care: String_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  color: String_comparison_exp
  content: products_translations_bool_exp
  created_at: timestamptz_comparison_exp
  current_price: Int_comparison_exp
  default_price_multiplier: numeric_comparison_exp
  description: String_comparison_exp
  disallow_listing: Boolean_comparison_exp
  fit: String_comparison_exp
  id: uuid_comparison_exp
  images: product_images_bool_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  lowest_price: Int_comparison_exp
  material: String_comparison_exp
  name: String_comparison_exp
  normalized_name: String_comparison_exp
  original_price: Int_comparison_exp
  parent_product: products_bool_exp
  parent_product_id: uuid_comparison_exp
  product_attribute_type_options: product_attribute_type_options_bool_exp
  product_colors: product_colors_bool_exp
  product_style_id: uuid_comparison_exp
  product_tags: product_tags_bool_exp
  product_tags_aggregate: product_tags_aggregate_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  products_translations: products_translations_bool_exp
  products_translations_aggregate: products_translations_aggregate_bool_exp
  question_set: question_sets_bool_exp
  question_set_id: uuid_comparison_exp
  sale_price: Int_comparison_exp
  searchable_products_results: searchable_products_results_bool_exp
  searchable_products_results_aggregate: searchable_products_results_aggregate_bool_exp
  skus: skus_bool_exp
  style: product_styles_bool_exp
  super_category: brand_categories_bool_exp
  super_category_id: uuid_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"order by max() on columns of table \"products\""
input products_max_order_by {
  brand_id: order_by
  care: order_by
  category_id: order_by
  color: order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  fit: order_by
  id: order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product_id: order_by
  product_style_id: order_by
  question_set_id: order_by
  sale_price: order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"order by min() on columns of table \"products\""
input products_min_order_by {
  brand_id: order_by
  care: order_by
  category_id: order_by
  color: order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  fit: order_by
  id: order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product_id: order_by
  product_style_id: order_by
  question_set_id: order_by
  sale_price: order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"Ordering options when selecting data from \"products\"."
input products_order_by {
  brand: brands_order_by
  brand_id: order_by
  care: order_by
  category: brand_categories_order_by
  category_id: order_by
  color: order_by
  content_aggregate: products_translations_aggregate_order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  disallow_listing: order_by
  fit: order_by
  id: order_by
  images_aggregate: product_images_aggregate_order_by
  listings_aggregate: listings_aggregate_order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product: products_order_by
  parent_product_id: order_by
  product_attribute_type_options_aggregate: product_attribute_type_options_aggregate_order_by
  product_colors_aggregate: product_colors_aggregate_order_by
  product_style_id: order_by
  product_tags_aggregate: product_tags_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  products_translations_aggregate: products_translations_aggregate_order_by
  question_set: question_sets_order_by
  question_set_id: order_by
  sale_price: order_by
  searchable_products_results_aggregate: searchable_products_results_aggregate_order_by
  skus_aggregate: skus_aggregate_order_by
  style: product_styles_order_by
  super_category: brand_categories_order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"order by stddev() on columns of table \"products\""
input products_stddev_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by stddev_pop() on columns of table \"products\""
input products_stddev_pop_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by stddev_samp() on columns of table \"products\""
input products_stddev_samp_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Streaming cursor of the table \"products\""
input products_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: products_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input products_stream_cursor_value_input {
  brand_id: uuid
  care: String
  category_id: uuid
  color: String
  created_at: timestamptz
  current_price: Int
  default_price_multiplier: numeric
  description: String
  disallow_listing: Boolean
  fit: String
  id: uuid
  lowest_price: Int
  material: String
  name: String
  normalized_name: String
  original_price: Int
  parent_product_id: uuid
  product_style_id: uuid
  question_set_id: uuid
  sale_price: Int
  super_category_id: uuid
  uid: String
  updated_at: timestamptz
  url: String
}

"order by sum() on columns of table \"products\""
input products_sum_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

input products_translations_aggregate_bool_exp {
  count: products_translations_aggregate_bool_exp_count
}

input products_translations_aggregate_bool_exp_count {
  arguments: [products_translations_select_column!]
  distinct: Boolean
  filter: products_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"products_translations\""
input products_translations_aggregate_order_by {
  avg: products_translations_avg_order_by
  count: order_by
  max: products_translations_max_order_by
  min: products_translations_min_order_by
  stddev: products_translations_stddev_order_by
  stddev_pop: products_translations_stddev_pop_order_by
  stddev_samp: products_translations_stddev_samp_order_by
  sum: products_translations_sum_order_by
  var_pop: products_translations_var_pop_order_by
  var_samp: products_translations_var_samp_order_by
  variance: products_translations_variance_order_by
}

"order by avg() on columns of table \"products_translations\""
input products_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"products_translations\". All fields are combined with a logical 'AND'."
input products_translations_bool_exp {
  _and: [products_translations_bool_exp!]
  _not: products_translations_bool_exp
  _or: [products_translations_bool_exp!]
  care: String_comparison_exp
  color: String_comparison_exp
  description: String_comparison_exp
  fit: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  material: String_comparison_exp
  name: String_comparison_exp
  normalized_name: String_comparison_exp
  product_id: uuid_comparison_exp
}

"order by max() on columns of table \"products_translations\""
input products_translations_max_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"order by min() on columns of table \"products_translations\""
input products_translations_min_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"Ordering options when selecting data from \"products_translations\"."
input products_translations_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"order by stddev() on columns of table \"products_translations\""
input products_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"products_translations\""
input products_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"products_translations\""
input products_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"products_translations\""
input products_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: products_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input products_translations_stream_cursor_value_input {
  care: String
  color: String
  description: String
  fit: String
  id: Int
  lang: String
  material: String
  name: String
  normalized_name: String
  product_id: uuid
}

"order by sum() on columns of table \"products_translations\""
input products_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"products_translations\""
input products_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"products_translations\""
input products_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"products_translations\""
input products_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"products\""
input products_var_pop_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by var_samp() on columns of table \"products\""
input products_var_samp_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by variance() on columns of table \"products\""
input products_variance_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Boolean expression to filter rows from the table \"question_sets\". All fields are combined with a logical 'AND'."
input question_sets_bool_exp {
  _and: [question_sets_bool_exp!]
  _not: question_sets_bool_exp
  _or: [question_sets_bool_exp!]
  brand_id: uuid_comparison_exp
  condition_questions: condition_questions_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"question_sets\"."
input question_sets_order_by {
  brand_id: order_by
  condition_questions_aggregate: condition_questions_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  notes: order_by
  uid: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"question_sets\""
input question_sets_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: question_sets_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input question_sets_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  notes: String
  uid: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"retail_associates\". All fields are combined with a logical 'AND'."
input retail_associates_bool_exp {
  _and: [retail_associates_bool_exp!]
  _not: retail_associates_bool_exp
  _or: [retail_associates_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  retail_store_id: uuid_comparison_exp
  store_number: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"Ordering options when selecting data from \"retail_associates\"."
input retail_associates_order_by {
  brand: brands_order_by
  brand_id: order_by
  id: order_by
  retail_store_id: order_by
  store_number: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"retail_associates\""
input retail_associates_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_associates_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_associates_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  retail_store_id: uuid
  store_number: String
  user_id: String
}

"Boolean expression to filter rows from the table \"retail_store_addresses\". All fields are combined with a logical 'AND'."
input retail_store_addresses_bool_exp {
  _and: [retail_store_addresses_bool_exp!]
  _not: retail_store_addresses_bool_exp
  _or: [retail_store_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  country: String_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  postal_code: String_comparison_exp
}

"Ordering options when selecting data from \"retail_store_addresses\"."
input retail_store_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  id: order_by
  locality: order_by
  name: order_by
  postal_code: order_by
}

"Streaming cursor of the table \"retail_store_addresses\""
input retail_store_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_store_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_store_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  postal_code: String
}

"Boolean expression to filter rows from the table \"retail_store_brand_uses\". All fields are combined with a logical 'AND'."
input retail_store_brand_uses_bool_exp {
  _and: [retail_store_brand_uses_bool_exp!]
  _not: retail_store_brand_uses_bool_exp
  _or: [retail_store_brand_uses_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  use_case: retail_store_use_cases_enum_comparison_exp
}

"Ordering options when selecting data from \"retail_store_brand_uses\"."
input retail_store_brand_uses_order_by {
  brand: brands_order_by
  brand_id: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  use_case: order_by
}

"Streaming cursor of the table \"retail_store_brand_uses\""
input retail_store_brand_uses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_store_brand_uses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_store_brand_uses_stream_cursor_value_input {
  brand_id: uuid
  retail_store_id: uuid
  use_case: retail_store_use_cases_enum
}

"Boolean expression to compare columns of type \"retail_store_use_cases_enum\". All fields are combined with logical 'AND'."
input retail_store_use_cases_enum_comparison_exp {
  _eq: retail_store_use_cases_enum
  _in: [retail_store_use_cases_enum!]
  _is_null: Boolean
  _neq: retail_store_use_cases_enum
  _nin: [retail_store_use_cases_enum!]
}

"Boolean expression to filter rows from the table \"retail_stores\". All fields are combined with a logical 'AND'."
input retail_stores_bool_exp {
  _and: [retail_stores_bool_exp!]
  _not: retail_stores_bool_exp
  _or: [retail_stores_bool_exp!]
  address: addresses_bool_exp
  address_id: uuid_comparison_exp
  content: retail_stores_translations_bool_exp
  created_at: timestamptz_comparison_exp
  external_identifier: String_comparison_exp
  id: uuid_comparison_exp
  pos_stations: pos_stations_bool_exp
  public_address: retail_store_addresses_bool_exp
  translations: retail_stores_translations_bool_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"retail_stores\"."
input retail_stores_order_by {
  address: addresses_order_by
  address_id: order_by
  content_aggregate: retail_stores_translations_aggregate_order_by
  created_at: order_by
  external_identifier: order_by
  id: order_by
  pos_stations_aggregate: pos_stations_aggregate_order_by
  public_address: retail_store_addresses_order_by
  translations_aggregate: retail_stores_translations_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"retail_stores\""
input retail_stores_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_stores_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_stores_stream_cursor_value_input {
  address_id: uuid
  created_at: timestamptz
  external_identifier: String
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"retail_stores_translations\""
input retail_stores_translations_aggregate_order_by {
  avg: retail_stores_translations_avg_order_by
  count: order_by
  max: retail_stores_translations_max_order_by
  min: retail_stores_translations_min_order_by
  stddev: retail_stores_translations_stddev_order_by
  stddev_pop: retail_stores_translations_stddev_pop_order_by
  stddev_samp: retail_stores_translations_stddev_samp_order_by
  sum: retail_stores_translations_sum_order_by
  var_pop: retail_stores_translations_var_pop_order_by
  var_samp: retail_stores_translations_var_samp_order_by
  variance: retail_stores_translations_variance_order_by
}

"order by avg() on columns of table \"retail_stores_translations\""
input retail_stores_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"retail_stores_translations\". All fields are combined with a logical 'AND'."
input retail_stores_translations_bool_exp {
  _and: [retail_stores_translations_bool_exp!]
  _not: retail_stores_translations_bool_exp
  _or: [retail_stores_translations_bool_exp!]
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  retail_store_id: uuid_comparison_exp
}

"order by max() on columns of table \"retail_stores_translations\""
input retail_stores_translations_max_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"order by min() on columns of table \"retail_stores_translations\""
input retail_stores_translations_min_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"Ordering options when selecting data from \"retail_stores_translations\"."
input retail_stores_translations_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"order by stddev() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"retail_stores_translations\""
input retail_stores_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_stores_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_stores_translations_stream_cursor_value_input {
  id: Int
  lang: String
  name: String
  retail_store_id: uuid
}

"order by sum() on columns of table \"retail_stores_translations\""
input retail_stores_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"retail_stores_translations\""
input retail_stores_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"retail_stores_translations\""
input retail_stores_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"retail_stores_translations\""
input retail_stores_translations_variance_order_by {
  id: order_by
}

"Boolean expression to compare columns of type \"return_item_statuses_enum\". All fields are combined with logical 'AND'."
input return_item_statuses_enum_comparison_exp {
  _eq: return_item_statuses_enum
  _in: [return_item_statuses_enum!]
  _is_null: Boolean
  _neq: return_item_statuses_enum
  _nin: [return_item_statuses_enum!]
}

"order by aggregate values of table \"return_items\""
input return_items_aggregate_order_by {
  count: order_by
  max: return_items_max_order_by
  min: return_items_min_order_by
}

"input type for inserting array relation for remote table \"return_items\""
input return_items_arr_rel_insert_input {
  data: [return_items_insert_input!]!
  "upsert condition"
  on_conflict: return_items_on_conflict
}

"Boolean expression to filter rows from the table \"return_items\". All fields are combined with a logical 'AND'."
input return_items_bool_exp {
  _and: [return_items_bool_exp!]
  _not: return_items_bool_exp
  _or: [return_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  damage_type: String_comparison_exp
  id: uuid_comparison_exp
  order_item: order_items_bool_exp
  order_item_id: uuid_comparison_exp
  return: returns_bool_exp
  return_id: uuid_comparison_exp
  return_reason: String_comparison_exp
  status: return_item_statuses_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"return_items\""
input return_items_insert_input {
  created_at: timestamptz
  damage_type: String
  id: uuid
  order_item: order_items_obj_rel_insert_input
  order_item_id: uuid
  return: returns_obj_rel_insert_input
  return_id: uuid
  return_reason: String
  status: return_item_statuses_enum
  updated_at: timestamptz
}

"order by max() on columns of table \"return_items\""
input return_items_max_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item_id: order_by
  return_id: order_by
  return_reason: order_by
  updated_at: order_by
}

"order by min() on columns of table \"return_items\""
input return_items_min_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item_id: order_by
  return_id: order_by
  return_reason: order_by
  updated_at: order_by
}

"on_conflict condition type for table \"return_items\""
input return_items_on_conflict {
  constraint: return_items_constraint!
  update_columns: [return_items_update_column!]! = []
  where: return_items_bool_exp
}

"Ordering options when selecting data from \"return_items\"."
input return_items_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item: order_items_order_by
  order_item_id: order_by
  return: returns_order_by
  return_id: order_by
  return_reason: order_by
  status: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"return_items\""
input return_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: return_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input return_items_stream_cursor_value_input {
  created_at: timestamptz
  damage_type: String
  id: uuid
  order_item_id: uuid
  return_id: uuid
  return_reason: String
  status: return_item_statuses_enum
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"return_statuses_enum\". All fields are combined with logical 'AND'."
input return_statuses_enum_comparison_exp {
  _eq: return_statuses_enum
  _in: [return_statuses_enum!]
  _is_null: Boolean
  _neq: return_statuses_enum
  _nin: [return_statuses_enum!]
}

"Boolean expression to filter rows from the table \"returns\". All fields are combined with a logical 'AND'."
input returns_bool_exp {
  _and: [returns_bool_exp!]
  _not: returns_bool_exp
  _or: [returns_bool_exp!]
  address: order_addresses_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  items: return_items_bool_exp
  preferred_language: String_comparison_exp
  return_shipping_address_id: uuid_comparison_exp
  return_shipping_label_id: uuid_comparison_exp
  shipping_label: shipping_labels_bool_exp
  status: return_statuses_enum_comparison_exp
  stripe_refund_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"returns\""
input returns_insert_input {
  address: order_addresses_obj_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: return_items_arr_rel_insert_input
  preferred_language: String
  return_shipping_address_id: uuid
  return_shipping_label_id: uuid
  status: return_statuses_enum
  stripe_refund_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"input type for inserting object relation for remote table \"returns\""
input returns_obj_rel_insert_input {
  data: returns_insert_input!
  "upsert condition"
  on_conflict: returns_on_conflict
}

"on_conflict condition type for table \"returns\""
input returns_on_conflict {
  constraint: returns_constraint!
  update_columns: [returns_update_column!]! = []
  where: returns_bool_exp
}

"Ordering options when selecting data from \"returns\"."
input returns_order_by {
  address: order_addresses_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  items_aggregate: return_items_aggregate_order_by
  preferred_language: order_by
  return_shipping_address_id: order_by
  return_shipping_label_id: order_by
  shipping_label: shipping_labels_order_by
  status: order_by
  stripe_refund_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"returns\""
input returns_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: returns_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input returns_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  preferred_language: String
  return_shipping_address_id: uuid
  return_shipping_label_id: uuid
  status: return_statuses_enum
  stripe_refund_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"review_statuses_enum\". All fields are combined with logical 'AND'."
input review_statuses_enum_comparison_exp {
  _eq: review_statuses_enum
  _in: [review_statuses_enum!]
  _is_null: Boolean
  _neq: review_statuses_enum
  _nin: [review_statuses_enum!]
}

"Boolean expression to filter rows from the table \"roles\". All fields are combined with a logical 'AND'."
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  role: String_comparison_exp
}

"Boolean expression to compare columns of type \"roles_enum\". All fields are combined with logical 'AND'."
input roles_enum_comparison_exp {
  _eq: roles_enum
  _in: [roles_enum!]
  _is_null: Boolean
  _neq: roles_enum
  _nin: [roles_enum!]
}

"Ordering options when selecting data from \"roles\"."
input roles_order_by {
  role: order_by
}

"Streaming cursor of the table \"roles\""
input roles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: roles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input roles_stream_cursor_value_input {
  role: String
}

input search_listings_31pl_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_listings_args {
  brand_id: uuid
  search: String
}

input search_listings_tnf_args {
  brand_id: uuid
  search: String
  tag_search: json
}

"order by aggregate values of table \"search_page_translations\""
input search_page_translations_aggregate_order_by {
  avg: search_page_translations_avg_order_by
  count: order_by
  max: search_page_translations_max_order_by
  min: search_page_translations_min_order_by
  stddev: search_page_translations_stddev_order_by
  stddev_pop: search_page_translations_stddev_pop_order_by
  stddev_samp: search_page_translations_stddev_samp_order_by
  sum: search_page_translations_sum_order_by
  var_pop: search_page_translations_var_pop_order_by
  var_samp: search_page_translations_var_samp_order_by
  variance: search_page_translations_variance_order_by
}

"order by avg() on columns of table \"search_page_translations\""
input search_page_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"search_page_translations\". All fields are combined with a logical 'AND'."
input search_page_translations_bool_exp {
  _and: [search_page_translations_bool_exp!]
  _not: search_page_translations_bool_exp
  _or: [search_page_translations_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: Int_comparison_exp
  locale: String_comparison_exp
  search_page: search_pages_bool_exp
  search_page_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"search_page_translations\""
input search_page_translations_max_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"search_page_translations\""
input search_page_translations_min_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"search_page_translations\"."
input search_page_translations_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page: search_pages_order_by
  search_page_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"search_page_translations\""
input search_page_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"search_page_translations\""
input search_page_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"search_page_translations\""
input search_page_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"search_page_translations\""
input search_page_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: search_page_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input search_page_translations_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: Int
  locale: String
  search_page_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"search_page_translations\""
input search_page_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"search_page_translations\""
input search_page_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"search_page_translations\""
input search_page_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"search_page_translations\""
input search_page_translations_variance_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"search_pages\". All fields are combined with a logical 'AND'."
input search_pages_bool_exp {
  _and: [search_pages_bool_exp!]
  _not: search_pages_bool_exp
  _or: [search_pages_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  collection: collections_bool_exp
  collection_id: uuid_comparison_exp
  content: search_page_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  search_page_translations: search_page_translations_bool_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"search_pages\"."
input search_pages_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  collection: collections_order_by
  collection_id: order_by
  content_aggregate: search_page_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  search_page_translations_aggregate: search_page_translations_aggregate_order_by
  slug: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"search_pages\""
input search_pages_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: search_pages_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input search_pages_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  collection_id: uuid
  created_at: timestamptz
  id: uuid
  slug: String
  updated_at: timestamptz
}

input search_products_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_products_by_sku_args {
  brand_id: uuid
  sku_text: String
}

input search_products_by_sku_collapsed_args {
  brand_id: uuid
  sku_text: String
}

input search_products_collapsed_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_styles_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_unique_listed_product_styles_tnf_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_users_args {
  search: String
}

"Boolean expression to filter rows from the table \"searchable_products\". All fields are combined with a logical 'AND'."
input searchable_products_bool_exp {
  _and: [searchable_products_bool_exp!]
  _not: searchable_products_bool_exp
  _or: [searchable_products_bool_exp!]
  brand: brands_bool_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product: products_bool_exp
  product_brand_id: uuid_comparison_exp
  sizes: String_comparison_exp
  skus: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"searchable_products\"."
input searchable_products_order_by {
  brand: brands_order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  product: products_order_by
  product_brand_id: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

input searchable_products_results_aggregate_bool_exp {
  count: searchable_products_results_aggregate_bool_exp_count
}

input searchable_products_results_aggregate_bool_exp_count {
  arguments: [searchable_products_results_select_column!]
  distinct: Boolean
  filter: searchable_products_results_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"searchable_products_results\""
input searchable_products_results_aggregate_order_by {
  count: order_by
  max: searchable_products_results_max_order_by
  min: searchable_products_results_min_order_by
}

"Boolean expression to filter rows from the table \"searchable_products_results\". All fields are combined with a logical 'AND'."
input searchable_products_results_bool_exp {
  _and: [searchable_products_results_bool_exp!]
  _not: searchable_products_results_bool_exp
  _or: [searchable_products_results_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product: products_bool_exp
  sizes: String_comparison_exp
  skus: String_comparison_exp
  type: String_comparison_exp
}

"order by max() on columns of table \"searchable_products_results\""
input searchable_products_results_max_order_by {
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"order by min() on columns of table \"searchable_products_results\""
input searchable_products_results_min_order_by {
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"Ordering options when selecting data from \"searchable_products_results\"."
input searchable_products_results_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  product: products_order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"Streaming cursor of the table \"searchable_products_results\""
input searchable_products_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: searchable_products_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input searchable_products_results_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  id: uuid
  name: String
  sizes: String
  skus: String
  type: String
}

"Streaming cursor of the table \"searchable_products\""
input searchable_products_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: searchable_products_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input searchable_products_stream_cursor_value_input {
  color: String
  color_mapping: String
  id: uuid
  name: String
  product_brand_id: uuid
  sizes: String
  skus: String
  type: String
}

"Boolean expression to filter rows from the table \"seller_ratings\". All fields are combined with a logical 'AND'."
input seller_ratings_bool_exp {
  _and: [seller_ratings_bool_exp!]
  _not: seller_ratings_bool_exp
  _or: [seller_ratings_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing_id: uuid_comparison_exp
  rating: Int_comparison_exp
  seller_id: String_comparison_exp
  storefront_id: uuid_comparison_exp
  user_id: String_comparison_exp
  user_rated: Boolean_comparison_exp
}

"input type for incrementing numeric columns in table \"seller_ratings\""
input seller_ratings_inc_input {
  rating: Int
}

"input type for inserting data into table \"seller_ratings\""
input seller_ratings_insert_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

"on_conflict condition type for table \"seller_ratings\""
input seller_ratings_on_conflict {
  constraint: seller_ratings_constraint!
  update_columns: [seller_ratings_update_column!]! = []
  where: seller_ratings_bool_exp
}

"Ordering options when selecting data from \"seller_ratings\"."
input seller_ratings_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  listing_id: order_by
  rating: order_by
  seller_id: order_by
  storefront_id: order_by
  user_id: order_by
  user_rated: order_by
}

"primary key columns input for table: seller_ratings"
input seller_ratings_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"seller_ratings\""
input seller_ratings_set_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

"Streaming cursor of the table \"seller_ratings\""
input seller_ratings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: seller_ratings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input seller_ratings_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

input seller_ratings_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: seller_ratings_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: seller_ratings_set_input
  "filter the rows which have to be updated"
  where: seller_ratings_bool_exp!
}

"Boolean expression to filter rows from the table \"shipping_carriers\". All fields are combined with a logical 'AND'."
input shipping_carriers_bool_exp {
  _and: [shipping_carriers_bool_exp!]
  _not: shipping_carriers_bool_exp
  _or: [shipping_carriers_bool_exp!]
  carrier: String_comparison_exp
}

"Boolean expression to compare columns of type \"shipping_carriers_enum\". All fields are combined with logical 'AND'."
input shipping_carriers_enum_comparison_exp {
  _eq: shipping_carriers_enum
  _in: [shipping_carriers_enum!]
  _is_null: Boolean
  _neq: shipping_carriers_enum
  _nin: [shipping_carriers_enum!]
}

"Ordering options when selecting data from \"shipping_carriers\"."
input shipping_carriers_order_by {
  carrier: order_by
}

"Streaming cursor of the table \"shipping_carriers\""
input shipping_carriers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_carriers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_carriers_stream_cursor_value_input {
  carrier: String
}

"Boolean expression to filter rows from the table \"shipping_information\". All fields are combined with a logical 'AND'."
input shipping_information_bool_exp {
  _and: [shipping_information_bool_exp!]
  _not: shipping_information_bool_exp
  _or: [shipping_information_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  in_store_pickups: in_store_pickups_bool_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  shipping_method: shipping_methods_enum_comparison_exp
  shipping_method_identifier: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"shipping_information\""
input shipping_information_insert_input {
  created_at: timestamptz
  id: uuid
  order_items: order_items_arr_rel_insert_input
  shipping_method: shipping_methods_enum
  shipping_method_identifier: String
  updated_at: timestamptz
}

"input type for inserting object relation for remote table \"shipping_information\""
input shipping_information_obj_rel_insert_input {
  data: shipping_information_insert_input!
  "upsert condition"
  on_conflict: shipping_information_on_conflict
}

"on_conflict condition type for table \"shipping_information\""
input shipping_information_on_conflict {
  constraint: shipping_information_constraint!
  update_columns: [shipping_information_update_column!]! = []
  where: shipping_information_bool_exp
}

"Ordering options when selecting data from \"shipping_information\"."
input shipping_information_order_by {
  created_at: order_by
  id: order_by
  in_store_pickups_aggregate: in_store_pickups_aggregate_order_by
  order_items_aggregate: order_items_aggregate_order_by
  shipping_method: order_by
  shipping_method_identifier: order_by
  updated_at: order_by
}

"primary key columns input for table: shipping_information"
input shipping_information_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"shipping_information\""
input shipping_information_set_input {
  updated_at: timestamptz
}

"Streaming cursor of the table \"shipping_information\""
input shipping_information_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_information_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_information_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  shipping_method: shipping_methods_enum
  shipping_method_identifier: String
  updated_at: timestamptz
}

input shipping_information_updates {
  "sets the columns of the filtered rows to the given values"
  _set: shipping_information_set_input
  "filter the rows which have to be updated"
  where: shipping_information_bool_exp!
}

"order by aggregate values of table \"shipping_labels\""
input shipping_labels_aggregate_order_by {
  count: order_by
  max: shipping_labels_max_order_by
  min: shipping_labels_min_order_by
}

"Boolean expression to filter rows from the table \"shipping_labels\". All fields are combined with a logical 'AND'."
input shipping_labels_bool_exp {
  _and: [shipping_labels_bool_exp!]
  _not: shipping_labels_bool_exp
  _or: [shipping_labels_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  mail_takebacks: mail_takebacks_bool_exp
  private: shipping_labels_private_bool_exp
  return_listings: listings_bool_exp
  return_listings_aggregate: listings_aggregate_bool_exp
  shipping_carrier: shipping_carriers_enum_comparison_exp
  shipping_service: shipping_services_enum_comparison_exp
  shipping_service_id: String_comparison_exp
  status: shipping_statuses_enum_comparison_exp
  tracking_number: String_comparison_exp
  tracking_url: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"shipping_labels\""
input shipping_labels_max_order_by {
  created_at: order_by
  id: order_by
  listing_id: order_by
  shipping_service_id: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"shipping_labels\""
input shipping_labels_min_order_by {
  created_at: order_by
  id: order_by
  listing_id: order_by
  shipping_service_id: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"shipping_labels\"."
input shipping_labels_order_by {
  created_at: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  listings_aggregate: listings_aggregate_order_by
  mail_takebacks_aggregate: mail_takebacks_aggregate_order_by
  private: shipping_labels_private_order_by
  return_listings_aggregate: listings_aggregate_order_by
  shipping_carrier: order_by
  shipping_service: order_by
  shipping_service_id: order_by
  status: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"Boolean expression to filter rows from the table \"shipping_labels_private\". All fields are combined with a logical 'AND'."
input shipping_labels_private_bool_exp {
  _and: [shipping_labels_private_bool_exp!]
  _not: shipping_labels_private_bool_exp
  _or: [shipping_labels_private_bool_exp!]
  id: uuid_comparison_exp
  label_url: String_comparison_exp
  metadata: jsonb_comparison_exp
  shipping_label: shipping_labels_bool_exp
}

"Ordering options when selecting data from \"shipping_labels_private\"."
input shipping_labels_private_order_by {
  id: order_by
  label_url: order_by
  metadata: order_by
  shipping_label: shipping_labels_order_by
}

"Streaming cursor of the table \"shipping_labels_private\""
input shipping_labels_private_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_labels_private_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_labels_private_stream_cursor_value_input {
  id: uuid
  label_url: String
  metadata: jsonb
}

"Streaming cursor of the table \"shipping_labels\""
input shipping_labels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_labels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_labels_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  shipping_carrier: shipping_carriers_enum
  shipping_service: shipping_services_enum
  shipping_service_id: String
  status: shipping_statuses_enum
  tracking_number: String
  tracking_url: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"shipping_methods_enum\". All fields are combined with logical 'AND'."
input shipping_methods_enum_comparison_exp {
  _eq: shipping_methods_enum
  _in: [shipping_methods_enum!]
  _is_null: Boolean
  _neq: shipping_methods_enum
  _nin: [shipping_methods_enum!]
}

"Boolean expression to compare columns of type \"shipping_services_enum\". All fields are combined with logical 'AND'."
input shipping_services_enum_comparison_exp {
  _eq: shipping_services_enum
  _in: [shipping_services_enum!]
  _is_null: Boolean
  _neq: shipping_services_enum
  _nin: [shipping_services_enum!]
}

"Boolean expression to filter rows from the table \"shipping_statuses\". All fields are combined with a logical 'AND'."
input shipping_statuses_bool_exp {
  _and: [shipping_statuses_bool_exp!]
  _not: shipping_statuses_bool_exp
  _or: [shipping_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"shipping_statuses_enum\". All fields are combined with logical 'AND'."
input shipping_statuses_enum_comparison_exp {
  _eq: shipping_statuses_enum
  _in: [shipping_statuses_enum!]
  _is_null: Boolean
  _neq: shipping_statuses_enum
  _nin: [shipping_statuses_enum!]
}

"Ordering options when selecting data from \"shipping_statuses\"."
input shipping_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"shipping_statuses\""
input shipping_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_statuses_stream_cursor_value_input {
  status: String
}

"Boolean expression to filter rows from the table \"short_links\". All fields are combined with a logical 'AND'."
input short_links_bool_exp {
  _and: [short_links_bool_exp!]
  _not: short_links_bool_exp
  _or: [short_links_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  identifier: String_comparison_exp
  path: String_comparison_exp
  query_params: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"short_links\"."
input short_links_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  path: order_by
  query_params: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"short_links\""
input short_links_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: short_links_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input short_links_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  identifier: String
  path: String
  query_params: jsonb
  updated_at: timestamptz
}

"order by aggregate values of table \"sku_images\""
input sku_images_aggregate_order_by {
  avg: sku_images_avg_order_by
  count: order_by
  max: sku_images_max_order_by
  min: sku_images_min_order_by
  stddev: sku_images_stddev_order_by
  stddev_pop: sku_images_stddev_pop_order_by
  stddev_samp: sku_images_stddev_samp_order_by
  sum: sku_images_sum_order_by
  var_pop: sku_images_var_pop_order_by
  var_samp: sku_images_var_samp_order_by
  variance: sku_images_variance_order_by
}

"order by avg() on columns of table \"sku_images\""
input sku_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"sku_images\". All fields are combined with a logical 'AND'."
input sku_images_bool_exp {
  _and: [sku_images_bool_exp!]
  _not: sku_images_bool_exp
  _or: [sku_images_bool_exp!]
  alt: String_comparison_exp
  content: sku_images_translations_bool_exp
  created_at: timestamptz_comparison_exp
  detail: Boolean_comparison_exp
  id: uuid_comparison_exp
  images_translations: sku_images_translations_bool_exp
  images_translations_aggregate: sku_images_translations_aggregate_bool_exp
  index: Int_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  primary: Boolean_comparison_exp
  primary_hover: Boolean_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  src: String_comparison_exp
  swatch: Boolean_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"sku_images\""
input sku_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  sku_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"sku_images\""
input sku_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  sku_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"sku_images\"."
input sku_images_order_by {
  alt: order_by
  content_aggregate: sku_images_translations_aggregate_order_by
  created_at: order_by
  detail: order_by
  id: order_by
  images_translations_aggregate: sku_images_translations_aggregate_order_by
  index: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  primary: order_by
  primary_hover: order_by
  sku: skus_order_by
  sku_id: order_by
  src: order_by
  swatch: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"sku_images\""
input sku_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"sku_images\""
input sku_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"sku_images\""
input sku_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"sku_images\""
input sku_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  detail: Boolean
  id: uuid
  index: Int
  primary: Boolean
  primary_hover: Boolean
  sku_id: uuid
  src: String
  swatch: Boolean
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"sku_images\""
input sku_images_sum_order_by {
  index: order_by
}

input sku_images_translations_aggregate_bool_exp {
  count: sku_images_translations_aggregate_bool_exp_count
}

input sku_images_translations_aggregate_bool_exp_count {
  arguments: [sku_images_translations_select_column!]
  distinct: Boolean
  filter: sku_images_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"sku_images_translations\""
input sku_images_translations_aggregate_order_by {
  avg: sku_images_translations_avg_order_by
  count: order_by
  max: sku_images_translations_max_order_by
  min: sku_images_translations_min_order_by
  stddev: sku_images_translations_stddev_order_by
  stddev_pop: sku_images_translations_stddev_pop_order_by
  stddev_samp: sku_images_translations_stddev_samp_order_by
  sum: sku_images_translations_sum_order_by
  var_pop: sku_images_translations_var_pop_order_by
  var_samp: sku_images_translations_var_samp_order_by
  variance: sku_images_translations_variance_order_by
}

"order by avg() on columns of table \"sku_images_translations\""
input sku_images_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"sku_images_translations\". All fields are combined with a logical 'AND'."
input sku_images_translations_bool_exp {
  _and: [sku_images_translations_bool_exp!]
  _not: sku_images_translations_bool_exp
  _or: [sku_images_translations_bool_exp!]
  alt: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  sku_image_id: uuid_comparison_exp
}

"order by max() on columns of table \"sku_images_translations\""
input sku_images_translations_max_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"order by min() on columns of table \"sku_images_translations\""
input sku_images_translations_min_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"Ordering options when selecting data from \"sku_images_translations\"."
input sku_images_translations_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"order by stddev() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"sku_images_translations\""
input sku_images_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_images_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_images_translations_stream_cursor_value_input {
  alt: String
  id: Int
  lang: String
  sku_image_id: uuid
}

"order by sum() on columns of table \"sku_images_translations\""
input sku_images_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"sku_images_translations\""
input sku_images_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"sku_images_translations\""
input sku_images_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"sku_images_translations\""
input sku_images_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"sku_images\""
input sku_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"sku_images\""
input sku_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"sku_images\""
input sku_images_variance_order_by {
  index: order_by
}

input sku_variant_type_options_aggregate_bool_exp {
  count: sku_variant_type_options_aggregate_bool_exp_count
}

input sku_variant_type_options_aggregate_bool_exp_count {
  arguments: [sku_variant_type_options_select_column!]
  distinct: Boolean
  filter: sku_variant_type_options_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"sku_variant_type_options\""
input sku_variant_type_options_aggregate_order_by {
  count: order_by
  max: sku_variant_type_options_max_order_by
  min: sku_variant_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"sku_variant_type_options\". All fields are combined with a logical 'AND'."
input sku_variant_type_options_bool_exp {
  _and: [sku_variant_type_options_bool_exp!]
  _not: sku_variant_type_options_bool_exp
  _or: [sku_variant_type_options_bool_exp!]
  id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_option: variant_type_options_bool_exp
  variant_type_option_id: uuid_comparison_exp
  variant_type_options_translations: variant_type_options_translations_bool_exp
  variant_types_translations: variant_types_translations_bool_exp
}

"order by max() on columns of table \"sku_variant_type_options\""
input sku_variant_type_options_max_order_by {
  id: order_by
  sku_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"sku_variant_type_options\""
input sku_variant_type_options_min_order_by {
  id: order_by
  sku_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"sku_variant_type_options\"."
input sku_variant_type_options_order_by {
  id: order_by
  sku: skus_order_by
  sku_id: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_option: variant_type_options_order_by
  variant_type_option_id: order_by
  variant_type_options_translations_aggregate: variant_type_options_translations_aggregate_order_by
  variant_types_translations_aggregate: variant_types_translations_aggregate_order_by
}

"Streaming cursor of the table \"sku_variant_type_options\""
input sku_variant_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_variant_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_variant_type_options_stream_cursor_value_input {
  id: uuid
  sku_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"order by aggregate values of table \"skus\""
input skus_aggregate_order_by {
  avg: skus_avg_order_by
  count: order_by
  max: skus_max_order_by
  min: skus_min_order_by
  stddev: skus_stddev_order_by
  stddev_pop: skus_stddev_pop_order_by
  stddev_samp: skus_stddev_samp_order_by
  sum: skus_sum_order_by
  var_pop: skus_var_pop_order_by
  var_samp: skus_var_samp_order_by
  variance: skus_variance_order_by
}

"order by avg() on columns of table \"skus\""
input skus_avg_order_by {
  original_price: order_by
  weight: order_by
}

"Boolean expression to filter rows from the table \"skus\". All fields are combined with a logical 'AND'."
input skus_bool_exp {
  _and: [skus_bool_exp!]
  _not: skus_bool_exp
  _or: [skus_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  care: String_comparison_exp
  content: skus_translations_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  dimensions: String_comparison_exp
  dimensions_lite: String_comparison_exp
  external_sku_ids: external_sku_ids_bool_exp
  id: uuid_comparison_exp
  images: sku_images_bool_exp
  is_material: Boolean_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  luggage_sleeve: Boolean_comparison_exp
  new_logo: Boolean_comparison_exp
  original_price: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  size: String_comparison_exp
  sku: String_comparison_exp
  sku_variant_type_options: sku_variant_type_options_bool_exp
  sku_variant_type_options_aggregate: sku_variant_type_options_aggregate_bool_exp
  skus_translations: skus_translations_bool_exp
  skus_translations_aggregate: skus_translations_aggregate_bool_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  weight: numeric_comparison_exp
  weight_unit: String_comparison_exp
}

"order by max() on columns of table \"skus\""
input skus_max_order_by {
  brand_id: order_by
  care: order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  original_price: order_by
  product_id: order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"order by min() on columns of table \"skus\""
input skus_min_order_by {
  brand_id: order_by
  care: order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  original_price: order_by
  product_id: order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"Ordering options when selecting data from \"skus\"."
input skus_order_by {
  brand: brands_order_by
  brand_id: order_by
  care: order_by
  content_aggregate: skus_translations_aggregate_order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  external_sku_ids_aggregate: external_sku_ids_aggregate_order_by
  id: order_by
  images_aggregate: sku_images_aggregate_order_by
  is_material: order_by
  listings_aggregate: listings_aggregate_order_by
  luggage_sleeve: order_by
  new_logo: order_by
  original_price: order_by
  product: products_order_by
  product_id: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  sku_variant_type_options_aggregate: sku_variant_type_options_aggregate_order_by
  skus_translations_aggregate: skus_translations_aggregate_order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"order by stddev() on columns of table \"skus\""
input skus_stddev_order_by {
  original_price: order_by
  weight: order_by
}

"order by stddev_pop() on columns of table \"skus\""
input skus_stddev_pop_order_by {
  original_price: order_by
  weight: order_by
}

"order by stddev_samp() on columns of table \"skus\""
input skus_stddev_samp_order_by {
  original_price: order_by
  weight: order_by
}

"Streaming cursor of the table \"skus\""
input skus_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: skus_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input skus_stream_cursor_value_input {
  brand_id: uuid
  care: String
  created_at: timestamptz
  description: String
  dimensions: String
  dimensions_lite: String
  id: uuid
  is_material: Boolean
  luggage_sleeve: Boolean
  new_logo: Boolean
  original_price: Int
  product_id: uuid
  product_style_id: uuid
  size: String
  sku: String
  uid: String
  updated_at: timestamptz
  weight: numeric
  weight_unit: String
}

"order by sum() on columns of table \"skus\""
input skus_sum_order_by {
  original_price: order_by
  weight: order_by
}

input skus_translations_aggregate_bool_exp {
  count: skus_translations_aggregate_bool_exp_count
}

input skus_translations_aggregate_bool_exp_count {
  arguments: [skus_translations_select_column!]
  distinct: Boolean
  filter: skus_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"skus_translations\""
input skus_translations_aggregate_order_by {
  avg: skus_translations_avg_order_by
  count: order_by
  max: skus_translations_max_order_by
  min: skus_translations_min_order_by
  stddev: skus_translations_stddev_order_by
  stddev_pop: skus_translations_stddev_pop_order_by
  stddev_samp: skus_translations_stddev_samp_order_by
  sum: skus_translations_sum_order_by
  var_pop: skus_translations_var_pop_order_by
  var_samp: skus_translations_var_samp_order_by
  variance: skus_translations_variance_order_by
}

"order by avg() on columns of table \"skus_translations\""
input skus_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"skus_translations\". All fields are combined with a logical 'AND'."
input skus_translations_bool_exp {
  _and: [skus_translations_bool_exp!]
  _not: skus_translations_bool_exp
  _or: [skus_translations_bool_exp!]
  care: String_comparison_exp
  description: String_comparison_exp
  dimensions: String_comparison_exp
  dimensions_lite: String_comparison_exp
  id: bigint_comparison_exp
  lang: String_comparison_exp
  size: String_comparison_exp
  sku_id: uuid_comparison_exp
}

"order by max() on columns of table \"skus_translations\""
input skus_translations_max_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"order by min() on columns of table \"skus_translations\""
input skus_translations_min_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"Ordering options when selecting data from \"skus_translations\"."
input skus_translations_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"order by stddev() on columns of table \"skus_translations\""
input skus_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"skus_translations\""
input skus_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"skus_translations\""
input skus_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"skus_translations\""
input skus_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: skus_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input skus_translations_stream_cursor_value_input {
  care: String
  description: String
  dimensions: String
  dimensions_lite: String
  id: bigint
  lang: String
  size: String
  sku_id: uuid
}

"order by sum() on columns of table \"skus_translations\""
input skus_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"skus_translations\""
input skus_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"skus_translations\""
input skus_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"skus_translations\""
input skus_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"skus\""
input skus_var_pop_order_by {
  original_price: order_by
  weight: order_by
}

"order by var_samp() on columns of table \"skus\""
input skus_var_samp_order_by {
  original_price: order_by
  weight: order_by
}

"order by variance() on columns of table \"skus\""
input skus_variance_order_by {
  original_price: order_by
  weight: order_by
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"order by aggregate values of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_aggregate_order_by {
  avg: storefront_fulfillment_in_store_options_avg_order_by
  count: order_by
  max: storefront_fulfillment_in_store_options_max_order_by
  min: storefront_fulfillment_in_store_options_min_order_by
  stddev: storefront_fulfillment_in_store_options_stddev_order_by
  stddev_pop: storefront_fulfillment_in_store_options_stddev_pop_order_by
  stddev_samp: storefront_fulfillment_in_store_options_stddev_samp_order_by
  sum: storefront_fulfillment_in_store_options_sum_order_by
  var_pop: storefront_fulfillment_in_store_options_var_pop_order_by
  var_samp: storefront_fulfillment_in_store_options_var_samp_order_by
  variance: storefront_fulfillment_in_store_options_variance_order_by
}

"order by avg() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_in_store_options\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_in_store_options_bool_exp {
  _and: [storefront_fulfillment_in_store_options_bool_exp!]
  _not: storefront_fulfillment_in_store_options_bool_exp
  _or: [storefront_fulfillment_in_store_options_bool_exp!]
  brand_fulfillment_in_store_option: brand_fulfillment_in_store_options_bool_exp
  brand_fulfillment_in_store_options_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  storefront_fulfillment_in_store_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_max_order_by {
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_min_order_by {
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_in_store_options\"."
input storefront_fulfillment_in_store_options_order_by {
  brand_fulfillment_in_store_option: brand_fulfillment_in_store_options_order_by
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_in_store_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_in_store_options_stream_cursor_value_input {
  brand_fulfillment_in_store_options_id: uuid
  created_at: timestamptz
  id: uuid
  shipping_fee: Int
  storefront_fulfillment_in_store_settings_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_in_store_settings_max_order_by
  min: storefront_fulfillment_in_store_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_in_store_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_in_store_settings_bool_exp {
  _and: [storefront_fulfillment_in_store_settings_bool_exp!]
  _not: storefront_fulfillment_in_store_settings_bool_exp
  _or: [storefront_fulfillment_in_store_settings_bool_exp!]
  brand_fulfillment_in_store_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: storefront_fulfillment_in_store_options_bool_exp
  storefront_fulfillment_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_max_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_min_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_in_store_settings\"."
input storefront_fulfillment_in_store_settings_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: storefront_fulfillment_in_store_options_aggregate_order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_in_store_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_in_store_settings_stream_cursor_value_input {
  brand_fulfillment_in_store_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_fulfillment_settings_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_aggregate_order_by {
  avg: storefront_fulfillment_postal_options_avg_order_by
  count: order_by
  max: storefront_fulfillment_postal_options_max_order_by
  min: storefront_fulfillment_postal_options_min_order_by
  stddev: storefront_fulfillment_postal_options_stddev_order_by
  stddev_pop: storefront_fulfillment_postal_options_stddev_pop_order_by
  stddev_samp: storefront_fulfillment_postal_options_stddev_samp_order_by
  sum: storefront_fulfillment_postal_options_sum_order_by
  var_pop: storefront_fulfillment_postal_options_var_pop_order_by
  var_samp: storefront_fulfillment_postal_options_var_samp_order_by
  variance: storefront_fulfillment_postal_options_variance_order_by
}

"order by avg() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_postal_options\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_postal_options_bool_exp {
  _and: [storefront_fulfillment_postal_options_bool_exp!]
  _not: storefront_fulfillment_postal_options_bool_exp
  _or: [storefront_fulfillment_postal_options_bool_exp!]
  brand_fulfillment_postal_options_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  storefront_fulfillment_postal_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_max_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_min_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_postal_options\"."
input storefront_fulfillment_postal_options_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_postal_options_stream_cursor_value_input {
  brand_fulfillment_postal_options_id: uuid
  created_at: timestamptz
  id: uuid
  shipping_fee: Int
  storefront_fulfillment_postal_settings_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_postal_settings_max_order_by
  min: storefront_fulfillment_postal_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_postal_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_postal_settings_bool_exp {
  _and: [storefront_fulfillment_postal_settings_bool_exp!]
  _not: storefront_fulfillment_postal_settings_bool_exp
  _or: [storefront_fulfillment_postal_settings_bool_exp!]
  brand_fulfillment_postal_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: storefront_fulfillment_postal_options_bool_exp
  storefront_fulfillment_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_max_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_min_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_postal_settings\"."
input storefront_fulfillment_postal_settings_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: storefront_fulfillment_postal_options_aggregate_order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_postal_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_postal_settings_stream_cursor_value_input {
  brand_fulfillment_postal_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_fulfillment_settings_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_settings_max_order_by
  min: storefront_fulfillment_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_settings_bool_exp {
  _and: [storefront_fulfillment_settings_bool_exp!]
  _not: storefront_fulfillment_settings_bool_exp
  _or: [storefront_fulfillment_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  in_store_settings: storefront_fulfillment_in_store_settings_bool_exp
  postal_settings: storefront_fulfillment_postal_settings_bool_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_settings\"."
input storefront_fulfillment_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  in_store_settings_aggregate: storefront_fulfillment_in_store_settings_aggregate_order_by
  postal_settings_aggregate: storefront_fulfillment_postal_settings_aggregate_order_by
  storefront_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_id: uuid
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"storefront_images\". All fields are combined with a logical 'AND'."
input storefront_images_bool_exp {
  _and: [storefront_images_bool_exp!]
  _not: storefront_images_bool_exp
  _or: [storefront_images_bool_exp!]
  alt: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"storefront_images\"."
input storefront_images_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_images\""
input storefront_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  id: uuid
  path: String
  src: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"storefront_payout_settings\". All fields are combined with a logical 'AND'."
input storefront_payout_settings_bool_exp {
  _and: [storefront_payout_settings_bool_exp!]
  _not: storefront_payout_settings_bool_exp
  _or: [storefront_payout_settings_bool_exp!]
  cashout_percent: numeric_comparison_exp
  store_credit_percent: numeric_comparison_exp
  storefronts: storefronts_bool_exp
  stripe_account_id: String_comparison_exp
}

"Ordering options when selecting data from \"storefront_payout_settings\"."
input storefront_payout_settings_order_by {
  cashout_percent: order_by
  store_credit_percent: order_by
  storefronts_aggregate: storefronts_aggregate_order_by
  stripe_account_id: order_by
}

"Streaming cursor of the table \"storefront_payout_settings\""
input storefront_payout_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_payout_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_payout_settings_stream_cursor_value_input {
  cashout_percent: numeric
  store_credit_percent: numeric
  stripe_account_id: String
}

"Boolean expression to filter rows from the table \"storefront_reviews\". All fields are combined with a logical 'AND'."
input storefront_reviews_bool_exp {
  _and: [storefront_reviews_bool_exp!]
  _not: storefront_reviews_bool_exp
  _or: [storefront_reviews_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
  rating: Int_comparison_exp
  status: review_statuses_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"storefront_reviews\""
input storefront_reviews_insert_input {
  comment: String
  order: orders_obj_rel_insert_input
  order_id: uuid
  rating: Int
  storefront_id: uuid
}

"on_conflict condition type for table \"storefront_reviews\""
input storefront_reviews_on_conflict {
  constraint: storefront_reviews_constraint!
  update_columns: [storefront_reviews_update_column!]! = []
  where: storefront_reviews_bool_exp
}

"Ordering options when selecting data from \"storefront_reviews\"."
input storefront_reviews_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  order: orders_order_by
  order_id: order_by
  rating: order_by
  status: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_reviews\""
input storefront_reviews_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_reviews_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_reviews_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  order_id: uuid
  rating: Int
  status: review_statuses_enum
  storefront_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"storefront_statuses_enum\". All fields are combined with logical 'AND'."
input storefront_statuses_enum_comparison_exp {
  _eq: storefront_statuses_enum
  _in: [storefront_statuses_enum!]
  _is_null: Boolean
  _neq: storefront_statuses_enum
  _nin: [storefront_statuses_enum!]
}

"Boolean expression to compare columns of type \"storefront_types_enum\". All fields are combined with logical 'AND'."
input storefront_types_enum_comparison_exp {
  _eq: storefront_types_enum
  _in: [storefront_types_enum!]
  _is_null: Boolean
  _neq: storefront_types_enum
  _nin: [storefront_types_enum!]
}

"order by aggregate values of table \"storefront_verified_attributes\""
input storefront_verified_attributes_aggregate_order_by {
  count: order_by
  max: storefront_verified_attributes_max_order_by
  min: storefront_verified_attributes_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_verified_attributes\". All fields are combined with a logical 'AND'."
input storefront_verified_attributes_bool_exp {
  _and: [storefront_verified_attributes_bool_exp!]
  _not: storefront_verified_attributes_bool_exp
  _or: [storefront_verified_attributes_bool_exp!]
  attribute: verified_identity_attributes_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
}

"order by max() on columns of table \"storefront_verified_attributes\""
input storefront_verified_attributes_max_order_by {
  storefront_id: order_by
}

"order by min() on columns of table \"storefront_verified_attributes\""
input storefront_verified_attributes_min_order_by {
  storefront_id: order_by
}

"Ordering options when selecting data from \"storefront_verified_attributes\"."
input storefront_verified_attributes_order_by {
  attribute: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
}

"Streaming cursor of the table \"storefront_verified_attributes\""
input storefront_verified_attributes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_verified_attributes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_verified_attributes_stream_cursor_value_input {
  attribute: verified_identity_attributes_enum
  storefront_id: uuid
}

"order by aggregate values of table \"storefronts\""
input storefronts_aggregate_order_by {
  count: order_by
  max: storefronts_max_order_by
  min: storefronts_min_order_by
}

"Boolean expression to filter rows from the table \"storefronts\". All fields are combined with a logical 'AND'."
input storefronts_bool_exp {
  _and: [storefronts_bool_exp!]
  _not: storefronts_bool_exp
  _or: [storefronts_bool_exp!]
  address: addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  balances: user_balances_bool_exp
  balances_aggregate: user_balances_aggregate_bool_exp
  bio: String_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  dac7_verified: dac7_verified_storefronts_bool_exp
  fulfillment_settings: storefront_fulfillment_settings_bool_exp
  hide_address: Boolean_comparison_exp
  id: uuid_comparison_exp
  links: jsonb_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  logo: storefront_images_bool_exp
  logo_id: uuid_comparison_exp
  name: String_comparison_exp
  owner: users_bool_exp
  payout_settings: storefront_payout_settings_bool_exp
  primary_address_id: uuid_comparison_exp
  slug: String_comparison_exp
  status: storefront_statuses_enum_comparison_exp
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  type: storefront_types_enum_comparison_exp
  verified: Boolean_comparison_exp
  verified_attributes: storefront_verified_attributes_bool_exp
}

"order by max() on columns of table \"storefronts\""
input storefronts_max_order_by {
  bio: order_by
  brand_id: order_by
  id: order_by
  logo_id: order_by
  name: order_by
  primary_address_id: order_by
  slug: order_by
}

"order by min() on columns of table \"storefronts\""
input storefronts_min_order_by {
  bio: order_by
  brand_id: order_by
  id: order_by
  logo_id: order_by
  name: order_by
  primary_address_id: order_by
  slug: order_by
}

"Ordering options when selecting data from \"storefronts\"."
input storefronts_order_by {
  address: addresses_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  balances_aggregate: user_balances_aggregate_order_by
  bio: order_by
  brand: brands_order_by
  brand_id: order_by
  dac7_verified: dac7_verified_storefronts_order_by
  fulfillment_settings_aggregate: storefront_fulfillment_settings_aggregate_order_by
  hide_address: order_by
  id: order_by
  links: order_by
  listings_aggregate: listings_aggregate_order_by
  logo: storefront_images_order_by
  logo_id: order_by
  name: order_by
  owner: users_order_by
  payout_settings: storefront_payout_settings_order_by
  primary_address_id: order_by
  slug: order_by
  status: order_by
  transactions_aggregate: transactions_aggregate_order_by
  type: order_by
  verified: order_by
  verified_attributes_aggregate: storefront_verified_attributes_aggregate_order_by
}

"primary key columns input for table: storefronts"
input storefronts_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"storefronts\""
input storefronts_set_input {
  primary_address_id: uuid
}

"Streaming cursor of the table \"storefronts\""
input storefronts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefronts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefronts_stream_cursor_value_input {
  bio: String
  brand_id: uuid
  hide_address: Boolean
  id: uuid
  links: jsonb
  logo_id: uuid
  name: String
  primary_address_id: uuid
  slug: String
  status: storefront_statuses_enum
  type: storefront_types_enum
  verified: Boolean
}

input storefronts_updates {
  "sets the columns of the filtered rows to the given values"
  _set: storefronts_set_input
  "filter the rows which have to be updated"
  where: storefronts_bool_exp!
}

"Boolean expression to compare columns of type \"takeback_item_statuses_enum\". All fields are combined with logical 'AND'."
input takeback_item_statuses_enum_comparison_exp {
  _eq: takeback_item_statuses_enum
  _in: [takeback_item_statuses_enum!]
  _is_null: Boolean
  _neq: takeback_item_statuses_enum
  _nin: [takeback_item_statuses_enum!]
}

"order by aggregate values of table \"takeback_items\""
input takeback_items_aggregate_order_by {
  count: order_by
  max: takeback_items_max_order_by
  min: takeback_items_min_order_by
}

"Boolean expression to filter rows from the table \"takeback_items\". All fields are combined with a logical 'AND'."
input takeback_items_bool_exp {
  _and: [takeback_items_bool_exp!]
  _not: takeback_items_bool_exp
  _or: [takeback_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  credit: credit_bool_exp
  credit_id: uuid_comparison_exp
  estimate_credit: credit_bool_exp
  estimate_credit_id: uuid_comparison_exp
  form_submission: form_submissions_bool_exp
  form_submission_id: uuid_comparison_exp
  id: uuid_comparison_exp
  lpn: String_comparison_exp
  product: products_bool_exp
  product_style: product_styles_bool_exp
  status: takeback_item_statuses_enum_comparison_exp
  style_code: String_comparison_exp
  takeback: takebacks_bool_exp
  takeback_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"takeback_items\""
input takeback_items_max_order_by {
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  style_code: order_by
  takeback_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"takeback_items\""
input takeback_items_min_order_by {
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  style_code: order_by
  takeback_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"takeback_items\"."
input takeback_items_order_by {
  created_at: order_by
  credit: credit_order_by
  credit_id: order_by
  estimate_credit: credit_order_by
  estimate_credit_id: order_by
  form_submission: form_submissions_order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  product: products_order_by
  product_style: product_styles_order_by
  status: order_by
  style_code: order_by
  takeback: takebacks_order_by
  takeback_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"takeback_items\""
input takeback_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: takeback_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input takeback_items_stream_cursor_value_input {
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  form_submission_id: uuid
  id: uuid
  lpn: String
  status: takeback_item_statuses_enum
  style_code: String
  takeback_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"takeback_statuses_enum\". All fields are combined with logical 'AND'."
input takeback_statuses_enum_comparison_exp {
  _eq: takeback_statuses_enum
  _in: [takeback_statuses_enum!]
  _is_null: Boolean
  _neq: takeback_statuses_enum
  _nin: [takeback_statuses_enum!]
}

input takebacks_aggregate_bool_exp {
  count: takebacks_aggregate_bool_exp_count
}

input takebacks_aggregate_bool_exp_count {
  arguments: [takebacks_select_column!]
  distinct: Boolean
  filter: takebacks_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"takebacks\""
input takebacks_aggregate_order_by {
  count: order_by
  max: takebacks_max_order_by
  min: takebacks_min_order_by
}

"Boolean expression to filter rows from the table \"takebacks\". All fields are combined with a logical 'AND'."
input takebacks_bool_exp {
  _and: [takebacks_bool_exp!]
  _not: takebacks_bool_exp
  _or: [takebacks_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  credit: credit_bool_exp
  credit_id: uuid_comparison_exp
  estimate_credit: credit_bool_exp
  estimate_credit_id: uuid_comparison_exp
  id: uuid_comparison_exp
  status: takeback_statuses_enum_comparison_exp
  store_number: String_comparison_exp
  storefront: storefronts_bool_exp
  takeback_items: takeback_items_bool_exp
  takeback_mail_takeback: mail_takebacks_bool_exp
  takeback_number: String_comparison_exp
  transaction: transactions_bool_exp
  transaction_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"takebacks\""
input takebacks_max_order_by {
  brand_id: order_by
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  id: order_by
  store_number: order_by
  takeback_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"takebacks\""
input takebacks_min_order_by {
  brand_id: order_by
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  id: order_by
  store_number: order_by
  takeback_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"takebacks\"."
input takebacks_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  credit: credit_order_by
  credit_id: order_by
  estimate_credit: credit_order_by
  estimate_credit_id: order_by
  id: order_by
  status: order_by
  store_number: order_by
  storefront: storefronts_order_by
  takeback_items_aggregate: takeback_items_aggregate_order_by
  takeback_mail_takeback_aggregate: mail_takebacks_aggregate_order_by
  takeback_number: order_by
  transaction: transactions_order_by
  transaction_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"takebacks\""
input takebacks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: takebacks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input takebacks_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  id: uuid
  status: takeback_statuses_enum
  store_number: String
  takeback_number: String
  transaction_id: uuid
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"transaction_types\". All fields are combined with a logical 'AND'."
input transaction_types_bool_exp {
  _and: [transaction_types_bool_exp!]
  _not: transaction_types_bool_exp
  _or: [transaction_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"transaction_types_enum\". All fields are combined with logical 'AND'."
input transaction_types_enum_comparison_exp {
  _eq: transaction_types_enum
  _in: [transaction_types_enum!]
  _is_null: Boolean
  _neq: transaction_types_enum
  _nin: [transaction_types_enum!]
}

"Ordering options when selecting data from \"transaction_types\"."
input transaction_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"transaction_types\""
input transaction_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: transaction_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input transaction_types_stream_cursor_value_input {
  type: String
}

input transactions_aggregate_bool_exp {
  count: transactions_aggregate_bool_exp_count
}

input transactions_aggregate_bool_exp_count {
  arguments: [transactions_select_column!]
  distinct: Boolean
  filter: transactions_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"transactions\""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"order by avg() on columns of table \"transactions\""
input transactions_avg_order_by {
  amount: order_by
  fee: order_by
}

"Boolean expression to filter rows from the table \"transactions\". All fields are combined with a logical 'AND'."
input transactions_bool_exp {
  _and: [transactions_bool_exp!]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp!]
  amount: Int_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  fee: Int_comparison_exp
  gift_cards: gift_cards_bool_exp
  gift_cards_aggregate: gift_cards_aggregate_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  type: transaction_types_enum_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"transactions\""
input transactions_max_order_by {
  amount: order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  id: order_by
  listing_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"transactions\""
input transactions_min_order_by {
  amount: order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  id: order_by
  listing_id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"transactions\"."
input transactions_order_by {
  amount: order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  gift_cards_aggregate: gift_cards_aggregate_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"transactions\""
input transactions_stddev_order_by {
  amount: order_by
  fee: order_by
}

"order by stddev_pop() on columns of table \"transactions\""
input transactions_stddev_pop_order_by {
  amount: order_by
  fee: order_by
}

"order by stddev_samp() on columns of table \"transactions\""
input transactions_stddev_samp_order_by {
  amount: order_by
  fee: order_by
}

"Streaming cursor of the table \"transactions\""
input transactions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: transactions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input transactions_stream_cursor_value_input {
  amount: Int
  brand_id: uuid
  created_at: timestamptz
  fee: Int
  id: uuid
  listing_id: uuid
  type: transaction_types_enum
  user_id: String
}

"order by sum() on columns of table \"transactions\""
input transactions_sum_order_by {
  amount: order_by
  fee: order_by
}

"order by var_pop() on columns of table \"transactions\""
input transactions_var_pop_order_by {
  amount: order_by
  fee: order_by
}

"order by var_samp() on columns of table \"transactions\""
input transactions_var_samp_order_by {
  amount: order_by
  fee: order_by
}

"order by variance() on columns of table \"transactions\""
input transactions_variance_order_by {
  amount: order_by
  fee: order_by
}

"Boolean expression to filter rows from the table \"unassociated_listing_data\". All fields are combined with a logical 'AND'."
input unassociated_listing_data_bool_exp {
  _and: [unassociated_listing_data_bool_exp!]
  _not: unassociated_listing_data_bool_exp
  _or: [unassociated_listing_data_bool_exp!]
  brand_id: uuid_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_metadata: jsonb_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  original_price: Int_comparison_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  variant_data: jsonb_comparison_exp
}

"Ordering options when selecting data from \"unassociated_listing_data\"."
input unassociated_listing_data_order_by {
  brand_id: order_by
  category: brand_categories_order_by
  category_id: order_by
  created_at: order_by
  custom_metadata: order_by
  description: order_by
  id: order_by
  name: order_by
  original_price: order_by
  storefront_id: order_by
  updated_at: order_by
  user_id: order_by
  variant_data: order_by
}

"Boolean expression to filter rows from the table \"unassociated_listing_data_schemas\". All fields are combined with a logical 'AND'."
input unassociated_listing_data_schemas_bool_exp {
  _and: [unassociated_listing_data_schemas_bool_exp!]
  _not: unassociated_listing_data_schemas_bool_exp
  _or: [unassociated_listing_data_schemas_bool_exp!]
  brand_id: uuid_comparison_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  question_set_id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"unassociated_listing_data_schemas\"."
input unassociated_listing_data_schemas_order_by {
  brand_id: order_by
  category_id: order_by
  created_at: order_by
  id: order_by
  question_set_id: order_by
  schema: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"unassociated_listing_data_schemas\""
input unassociated_listing_data_schemas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unassociated_listing_data_schemas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unassociated_listing_data_schemas_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  created_at: timestamptz
  id: uuid
  question_set_id: uuid
  schema: jsonb
  updated_at: timestamptz
}

"Streaming cursor of the table \"unassociated_listing_data\""
input unassociated_listing_data_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unassociated_listing_data_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unassociated_listing_data_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  created_at: timestamptz
  custom_metadata: jsonb
  description: String
  id: uuid
  name: String
  original_price: Int
  storefront_id: uuid
  updated_at: timestamptz
  user_id: String
  variant_data: jsonb
}

input unique_listed_product_styles_tnf_args {
  brand_id: uuid
  tag_search: json
}

input unique_listing_tags_by_brand_args {
  brand_id: uuid
  prefix: String
}

input unique_listing_tags_by_brand_collection_args {
  brand_id: uuid
  collection: String
  prefix: String
}

input unique_listings_31pl_args {
  brand_id: uuid
  tag_search: json
}

input unique_listings_by_brand_args {
  brand_id: uuid
}

input unique_listings_by_brand_tnf_args {
  brand_id: uuid
  tag_search: json
}

"Boolean expression to filter rows from the table \"unique_listings_results\". All fields are combined with a logical 'AND'."
input unique_listings_results_bool_exp {
  _and: [unique_listings_results_bool_exp!]
  _not: unique_listings_results_bool_exp
  _or: [unique_listings_results_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  sizes: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"unique_listings_results\"."
input unique_listings_results_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  name: order_by
  priority: order_by
  product: products_order_by
  product_id: order_by
  sizes: order_by
  type: order_by
}

"Streaming cursor of the table \"unique_listings_results\""
input unique_listings_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_listings_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_listings_results_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  sizes: String
  type: String
}

"Boolean expression to filter rows from the table \"unique_listings_results_tnf\". All fields are combined with a logical 'AND'."
input unique_listings_results_tnf_bool_exp {
  _and: [unique_listings_results_tnf_bool_exp!]
  _not: unique_listings_results_tnf_bool_exp
  _or: [unique_listings_results_tnf_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  size_groupings: String_comparison_exp
  sizes: String_comparison_exp
  tags: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"unique_listings_results_tnf\"."
input unique_listings_results_tnf_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  name: order_by
  priority: order_by
  product: products_order_by
  product_id: order_by
  size_groupings: order_by
  sizes: order_by
  tags: order_by
  type: order_by
}

"Streaming cursor of the table \"unique_listings_results_tnf\""
input unique_listings_results_tnf_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_listings_results_tnf_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_listings_results_tnf_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  size_groupings: String
  sizes: String
  tags: String
  type: String
}

"Boolean expression to filter rows from the table \"unique_tags_results\". All fields are combined with a logical 'AND'."
input unique_tags_results_bool_exp {
  _and: [unique_tags_results_bool_exp!]
  _not: unique_tags_results_bool_exp
  _or: [unique_tags_results_bool_exp!]
  value: String_comparison_exp
}

"Ordering options when selecting data from \"unique_tags_results\"."
input unique_tags_results_order_by {
  value: order_by
}

"Streaming cursor of the table \"unique_tags_results\""
input unique_tags_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_tags_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_tags_results_stream_cursor_value_input {
  value: String
}

"order by aggregate values of table \"user_addresses\""
input user_addresses_aggregate_order_by {
  avg: user_addresses_avg_order_by
  count: order_by
  max: user_addresses_max_order_by
  min: user_addresses_min_order_by
  stddev: user_addresses_stddev_order_by
  stddev_pop: user_addresses_stddev_pop_order_by
  stddev_samp: user_addresses_stddev_samp_order_by
  sum: user_addresses_sum_order_by
  var_pop: user_addresses_var_pop_order_by
  var_samp: user_addresses_var_samp_order_by
  variance: user_addresses_variance_order_by
}

"input type for inserting array relation for remote table \"user_addresses\""
input user_addresses_arr_rel_insert_input {
  data: [user_addresses_insert_input!]!
  "upsert condition"
  on_conflict: user_addresses_on_conflict
}

"order by avg() on columns of table \"user_addresses\""
input user_addresses_avg_order_by {
  floors: order_by
}

"Boolean expression to filter rows from the table \"user_addresses\". All fields are combined with a logical 'AND'."
input user_addresses_bool_exp {
  _and: [user_addresses_bool_exp!]
  _not: user_addresses_bool_exp
  _or: [user_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  building_access: building_access_types_enum_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  floors: Int_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  organization: String_comparison_exp
  phone_number: String_comparison_exp
  postal_code: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"user_addresses\""
input user_addresses_inc_input {
  floors: Int
}

"input type for inserting data into table \"user_addresses\""
input user_addresses_insert_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
}

"order by max() on columns of table \"user_addresses\""
input user_addresses_max_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_addresses\""
input user_addresses_min_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"user_addresses\""
input user_addresses_obj_rel_insert_input {
  data: user_addresses_insert_input!
  "upsert condition"
  on_conflict: user_addresses_on_conflict
}

"on_conflict condition type for table \"user_addresses\""
input user_addresses_on_conflict {
  constraint: user_addresses_constraint!
  update_columns: [user_addresses_update_column!]! = []
  where: user_addresses_bool_exp
}

"Ordering options when selecting data from \"user_addresses\"."
input user_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  building_access: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_addresses"
input user_addresses_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_addresses\""
input user_addresses_set_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
}

"order by stddev() on columns of table \"user_addresses\""
input user_addresses_stddev_order_by {
  floors: order_by
}

"order by stddev_pop() on columns of table \"user_addresses\""
input user_addresses_stddev_pop_order_by {
  floors: order_by
}

"order by stddev_samp() on columns of table \"user_addresses\""
input user_addresses_stddev_samp_order_by {
  floors: order_by
}

"Streaming cursor of the table \"user_addresses\""
input user_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"user_addresses\""
input user_addresses_sum_order_by {
  floors: order_by
}

input user_addresses_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: user_addresses_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: user_addresses_set_input
  "filter the rows which have to be updated"
  where: user_addresses_bool_exp!
}

"order by var_pop() on columns of table \"user_addresses\""
input user_addresses_var_pop_order_by {
  floors: order_by
}

"order by var_samp() on columns of table \"user_addresses\""
input user_addresses_var_samp_order_by {
  floors: order_by
}

"order by variance() on columns of table \"user_addresses\""
input user_addresses_variance_order_by {
  floors: order_by
}

"Boolean expression to filter rows from the table \"user_alerts\". All fields are combined with a logical 'AND'."
input user_alerts_bool_exp {
  _and: [user_alerts_bool_exp!]
  _not: user_alerts_bool_exp
  _or: [user_alerts_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  uid: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_alerts\""
input user_alerts_insert_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"user_alerts\""
input user_alerts_on_conflict {
  constraint: user_alerts_constraint!
  update_columns: [user_alerts_update_column!]! = []
  where: user_alerts_bool_exp
}

"Ordering options when selecting data from \"user_alerts\"."
input user_alerts_order_by {
  created_at: order_by
  id: order_by
  product: products_order_by
  product_id: order_by
  sku: skus_order_by
  sku_id: order_by
  uid: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_alerts"
input user_alerts_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_alerts\""
input user_alerts_set_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user_id: String
}

"Streaming cursor of the table \"user_alerts\""
input user_alerts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_alerts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_alerts_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user_id: String
}

input user_alerts_updates {
  "sets the columns of the filtered rows to the given values"
  _set: user_alerts_set_input
  "filter the rows which have to be updated"
  where: user_alerts_bool_exp!
}

input user_balances_aggregate_bool_exp {
  count: user_balances_aggregate_bool_exp_count
}

input user_balances_aggregate_bool_exp_count {
  arguments: [user_balances_select_column!]
  distinct: Boolean
  filter: user_balances_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"user_balances\""
input user_balances_aggregate_order_by {
  avg: user_balances_avg_order_by
  count: order_by
  max: user_balances_max_order_by
  min: user_balances_min_order_by
  stddev: user_balances_stddev_order_by
  stddev_pop: user_balances_stddev_pop_order_by
  stddev_samp: user_balances_stddev_samp_order_by
  sum: user_balances_sum_order_by
  var_pop: user_balances_var_pop_order_by
  var_samp: user_balances_var_samp_order_by
  variance: user_balances_variance_order_by
}

"order by avg() on columns of table \"user_balances\""
input user_balances_avg_order_by {
  current_balance: order_by
}

"Boolean expression to filter rows from the table \"user_balances\". All fields are combined with a logical 'AND'."
input user_balances_bool_exp {
  _and: [user_balances_bool_exp!]
  _not: user_balances_bool_exp
  _or: [user_balances_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  current_balance: Int_comparison_exp
  id: uuid_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"user_balances\""
input user_balances_max_order_by {
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_balances\""
input user_balances_min_order_by {
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront_id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"user_balances\"."
input user_balances_order_by {
  brand: brands_order_by
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"user_balances\""
input user_balances_stddev_order_by {
  current_balance: order_by
}

"order by stddev_pop() on columns of table \"user_balances\""
input user_balances_stddev_pop_order_by {
  current_balance: order_by
}

"order by stddev_samp() on columns of table \"user_balances\""
input user_balances_stddev_samp_order_by {
  current_balance: order_by
}

"Streaming cursor of the table \"user_balances\""
input user_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_balances_stream_cursor_value_input {
  brand_id: uuid
  current_balance: Int
  id: uuid
  storefront_id: uuid
  user_id: String
}

"order by sum() on columns of table \"user_balances\""
input user_balances_sum_order_by {
  current_balance: order_by
}

"order by var_pop() on columns of table \"user_balances\""
input user_balances_var_pop_order_by {
  current_balance: order_by
}

"order by var_samp() on columns of table \"user_balances\""
input user_balances_var_samp_order_by {
  current_balance: order_by
}

"order by variance() on columns of table \"user_balances\""
input user_balances_variance_order_by {
  current_balance: order_by
}

"Boolean expression to filter rows from the table \"user_favorites\". All fields are combined with a logical 'AND'."
input user_favorites_bool_exp {
  _and: [user_favorites_bool_exp!]
  _not: user_favorites_bool_exp
  _or: [user_favorites_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_favorites\""
input user_favorites_insert_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"user_favorites\""
input user_favorites_on_conflict {
  constraint: user_favorites_constraint!
  update_columns: [user_favorites_update_column!]! = []
  where: user_favorites_bool_exp
}

"Ordering options when selecting data from \"user_favorites\"."
input user_favorites_order_by {
  created_at: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  product: products_order_by
  product_id: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_favorites"
input user_favorites_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_favorites\""
input user_favorites_set_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user_id: String
}

"Streaming cursor of the table \"user_favorites\""
input user_favorites_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_favorites_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_favorites_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user_id: String
}

input user_favorites_updates {
  "sets the columns of the filtered rows to the given values"
  _set: user_favorites_set_input
  "filter the rows which have to be updated"
  where: user_favorites_bool_exp!
}

"Boolean expression to filter rows from the table \"user_metadata\". All fields are combined with a logical 'AND'."
input user_metadata_bool_exp {
  _and: [user_metadata_bool_exp!]
  _not: user_metadata_bool_exp
  _or: [user_metadata_bool_exp!]
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  user_id: String_comparison_exp
  value: jsonb_comparison_exp
}

"Ordering options when selecting data from \"user_metadata\"."
input user_metadata_order_by {
  brand_id: order_by
  id: order_by
  key: order_by
  user_id: order_by
  value: order_by
}

"Streaming cursor of the table \"user_metadata\""
input user_metadata_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_metadata_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_metadata_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  key: String
  user_id: String
  value: jsonb
}

"order by aggregate values of table \"user_roles\""
input user_roles_aggregate_order_by {
  count: order_by
  max: user_roles_max_order_by
  min: user_roles_min_order_by
}

"Boolean expression to filter rows from the table \"user_roles\". All fields are combined with a logical 'AND'."
input user_roles_bool_exp {
  _and: [user_roles_bool_exp!]
  _not: user_roles_bool_exp
  _or: [user_roles_bool_exp!]
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  role: roles_enum_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"user_roles\""
input user_roles_max_order_by {
  brand_id: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_roles\""
input user_roles_min_order_by {
  brand_id: order_by
  id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"user_roles\"."
input user_roles_order_by {
  brand_id: order_by
  id: order_by
  role: order_by
  user_id: order_by
}

"Streaming cursor of the table \"user_roles\""
input user_roles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_roles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_roles_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  role: roles_enum
  user_id: String
}

"Boolean expression to compare columns of type \"user_verification_check_statuses_enum\". All fields are combined with logical 'AND'."
input user_verification_check_statuses_enum_comparison_exp {
  _eq: user_verification_check_statuses_enum
  _in: [user_verification_check_statuses_enum!]
  _is_null: Boolean
  _neq: user_verification_check_statuses_enum
  _nin: [user_verification_check_statuses_enum!]
}

"order by aggregate values of table \"user_verification_checks\""
input user_verification_checks_aggregate_order_by {
  count: order_by
  max: user_verification_checks_max_order_by
  min: user_verification_checks_min_order_by
}

"input type for inserting array relation for remote table \"user_verification_checks\""
input user_verification_checks_arr_rel_insert_input {
  data: [user_verification_checks_insert_input!]!
  "upsert condition"
  on_conflict: user_verification_checks_on_conflict
}

"Boolean expression to filter rows from the table \"user_verification_checks\". All fields are combined with a logical 'AND'."
input user_verification_checks_bool_exp {
  _and: [user_verification_checks_bool_exp!]
  _not: user_verification_checks_bool_exp
  _or: [user_verification_checks_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  status: user_verification_check_statuses_enum_comparison_exp
  stripe_verification_response_id: String_comparison_exp
  stripe_verification_session_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_verification_checks\""
input user_verification_checks_insert_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  status: user_verification_check_statuses_enum
  stripe_verification_response_id: String
  stripe_verification_session_id: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"user_verification_checks\""
input user_verification_checks_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_verification_checks\""
input user_verification_checks_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"user_verification_checks\""
input user_verification_checks_on_conflict {
  constraint: user_verification_checks_constraint!
  update_columns: [user_verification_checks_update_column!]! = []
  where: user_verification_checks_bool_exp
}

"Ordering options when selecting data from \"user_verification_checks\"."
input user_verification_checks_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"user_verification_checks\""
input user_verification_checks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_verification_checks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_verification_checks_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  status: user_verification_check_statuses_enum
  stripe_verification_response_id: String
  stripe_verification_session_id: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  addresses: user_addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  brand: brands_bool_exp
  default_shipping_address: user_addresses_bool_exp
  first_name: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  orders: orders_bool_exp
  orders_aggregate: orders_aggregate_bool_exp
  owned_storefronts: storefronts_bool_exp
  private: users_private_bool_exp
  roles: user_roles_bool_exp
  state: String_comparison_exp
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  user_balances: user_balances_bool_exp
  user_balances_aggregate: user_balances_aggregate_bool_exp
  verification_checks: user_verification_checks_bool_exp
}

"input type for inserting data into table \"users\""
input users_insert_input {
  addresses: user_addresses_arr_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  default_shipping_address: user_addresses_obj_rel_insert_input
  default_shipping_address_id: uuid
  email: String
  first_name: String
  id: String
  last_name: String
  orders: orders_arr_rel_insert_input
  state: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_checks: user_verification_checks_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
  data: users_insert_input!
  "upsert condition"
  on_conflict: users_on_conflict
}

"on_conflict condition type for table \"users\""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"Ordering options when selecting data from \"users\"."
input users_order_by {
  addresses_aggregate: user_addresses_aggregate_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  brand: brands_order_by
  default_shipping_address: user_addresses_order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  listings_aggregate: listings_aggregate_order_by
  orders_aggregate: orders_aggregate_order_by
  owned_storefronts_aggregate: storefronts_aggregate_order_by
  private: users_private_order_by
  roles_aggregate: user_roles_aggregate_order_by
  state: order_by
  transactions_aggregate: transactions_aggregate_order_by
  user_balances_aggregate: user_balances_aggregate_order_by
  verification_checks_aggregate: user_verification_checks_aggregate_order_by
}

"primary key columns input for table: users"
input users_pk_columns_input {
  id: String!
}

"Boolean expression to filter rows from the table \"users_private\". All fields are combined with a logical 'AND'."
input users_private_bool_exp {
  _and: [users_private_bool_exp!]
  _not: users_private_bool_exp
  _or: [users_private_bool_exp!]
  addresses: user_addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  current_balance: Int_comparison_exp
  default_shipping_address: user_addresses_bool_exp
  default_shipping_address_id: uuid_comparison_exp
  email: String_comparison_exp
  is_manager: Boolean_comparison_exp
  roles: user_roles_bool_exp
  stripe_account_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"Ordering options when selecting data from \"users_private\"."
input users_private_order_by {
  addresses_aggregate: user_addresses_aggregate_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  brand_id: order_by
  created_at: order_by
  current_balance: order_by
  default_shipping_address: user_addresses_order_by
  default_shipping_address_id: order_by
  email: order_by
  is_manager: order_by
  roles_aggregate: user_roles_aggregate_order_by
  stripe_account_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"users_private\""
input users_private_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: users_private_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input users_private_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  current_balance: Int
  default_shipping_address_id: uuid
  email: String
  is_manager: Boolean
  stripe_account_id: String
  updated_at: timestamptz
  user_id: String
}

"input type for updating data in table \"users\""
input users_set_input {
  brand_id: uuid
  created_at: timestamptz
  default_shipping_address_id: uuid
  email: String
  first_name: String
  id: String
  last_name: String
  state: String
  stripe_account_id: String
  updated_at: timestamptz
}

"Streaming cursor of the table \"users\""
input users_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: users_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input users_stream_cursor_value_input {
  first_name: String
  id: String
  last_name: String
  state: String
}

input users_updates {
  "sets the columns of the filtered rows to the given values"
  _set: users_set_input
  "filter the rows which have to be updated"
  where: users_bool_exp!
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"order by aggregate values of table \"variant_type_options\""
input variant_type_options_aggregate_order_by {
  count: order_by
  max: variant_type_options_max_order_by
  min: variant_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"variant_type_options\". All fields are combined with a logical 'AND'."
input variant_type_options_bool_exp {
  _and: [variant_type_options_bool_exp!]
  _not: variant_type_options_bool_exp
  _or: [variant_type_options_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: variant_type_options_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  option: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_options_translations: variant_type_options_translations_bool_exp
}

"order by max() on columns of table \"variant_type_options\""
input variant_type_options_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type_id: order_by
}

"order by min() on columns of table \"variant_type_options\""
input variant_type_options_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type_id: order_by
}

"Ordering options when selecting data from \"variant_type_options\"."
input variant_type_options_order_by {
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: variant_type_options_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_options_translations_aggregate: variant_type_options_translations_aggregate_order_by
}

"Streaming cursor of the table \"variant_type_options\""
input variant_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_type_options_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  option: String
  updated_at: timestamptz
  variant_type_id: uuid
}

"order by aggregate values of table \"variant_type_options_translations\""
input variant_type_options_translations_aggregate_order_by {
  avg: variant_type_options_translations_avg_order_by
  count: order_by
  max: variant_type_options_translations_max_order_by
  min: variant_type_options_translations_min_order_by
  stddev: variant_type_options_translations_stddev_order_by
  stddev_pop: variant_type_options_translations_stddev_pop_order_by
  stddev_samp: variant_type_options_translations_stddev_samp_order_by
  sum: variant_type_options_translations_sum_order_by
  var_pop: variant_type_options_translations_var_pop_order_by
  var_samp: variant_type_options_translations_var_samp_order_by
  variance: variant_type_options_translations_variance_order_by
}

"order by avg() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_type_options_translations\". All fields are combined with a logical 'AND'."
input variant_type_options_translations_bool_exp {
  _and: [variant_type_options_translations_bool_exp!]
  _not: variant_type_options_translations_bool_exp
  _or: [variant_type_options_translations_bool_exp!]
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  variant_type_option_id: uuid_comparison_exp
}

"order by max() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_max_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_min_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"variant_type_options_translations\"."
input variant_type_options_translations_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"order by stddev() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"variant_type_options_translations\""
input variant_type_options_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_type_options_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_type_options_translations_stream_cursor_value_input {
  display: String
  id: Int
  lang: String
  variant_type_option_id: uuid
}

"order by sum() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_variance_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_types\". All fields are combined with a logical 'AND'."
input variant_types_bool_exp {
  _and: [variant_types_bool_exp!]
  _not: variant_types_bool_exp
  _or: [variant_types_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: variant_types_translations_bool_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
  variant_type_options: variant_type_options_bool_exp
  variant_types_translations: variant_types_translations_bool_exp
}

"Ordering options when selecting data from \"variant_types\"."
input variant_types_order_by {
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: variant_types_translations_aggregate_order_by
  id: order_by
  type: order_by
  variant_type_options_aggregate: variant_type_options_aggregate_order_by
  variant_types_translations_aggregate: variant_types_translations_aggregate_order_by
}

"Streaming cursor of the table \"variant_types\""
input variant_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_types_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  type: String
}

"order by aggregate values of table \"variant_types_translations\""
input variant_types_translations_aggregate_order_by {
  avg: variant_types_translations_avg_order_by
  count: order_by
  max: variant_types_translations_max_order_by
  min: variant_types_translations_min_order_by
  stddev: variant_types_translations_stddev_order_by
  stddev_pop: variant_types_translations_stddev_pop_order_by
  stddev_samp: variant_types_translations_stddev_samp_order_by
  sum: variant_types_translations_sum_order_by
  var_pop: variant_types_translations_var_pop_order_by
  var_samp: variant_types_translations_var_samp_order_by
  variance: variant_types_translations_variance_order_by
}

"order by avg() on columns of table \"variant_types_translations\""
input variant_types_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_types_translations\". All fields are combined with a logical 'AND'."
input variant_types_translations_bool_exp {
  _and: [variant_types_translations_bool_exp!]
  _not: variant_types_translations_bool_exp
  _or: [variant_types_translations_bool_exp!]
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  variant_type_id: uuid_comparison_exp
}

"order by max() on columns of table \"variant_types_translations\""
input variant_types_translations_max_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"order by min() on columns of table \"variant_types_translations\""
input variant_types_translations_min_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"Ordering options when selecting data from \"variant_types_translations\"."
input variant_types_translations_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"order by stddev() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"variant_types_translations\""
input variant_types_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_types_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_types_translations_stream_cursor_value_input {
  display: String
  id: Int
  lang: String
  variant_type_id: uuid
}

"order by sum() on columns of table \"variant_types_translations\""
input variant_types_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"variant_types_translations\""
input variant_types_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"variant_types_translations\""
input variant_types_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"variant_types_translations\""
input variant_types_translations_variance_order_by {
  id: order_by
}

"Boolean expression to compare columns of type \"verified_identity_attributes_enum\". All fields are combined with logical 'AND'."
input verified_identity_attributes_enum_comparison_exp {
  _eq: verified_identity_attributes_enum
  _in: [verified_identity_attributes_enum!]
  _is_null: Boolean
  _neq: verified_identity_attributes_enum
  _nin: [verified_identity_attributes_enum!]
}

"order by aggregate values of table \"wms_items\""
input wms_items_aggregate_order_by {
  count: order_by
  max: wms_items_max_order_by
  min: wms_items_min_order_by
}

"Boolean expression to filter rows from the table \"wms_items\". All fields are combined with a logical 'AND'."
input wms_items_bool_exp {
  _and: [wms_items_bool_exp!]
  _not: wms_items_bool_exp
  _or: [wms_items_bool_exp!]
  brand: brands_bool_exp
  brand_category: brand_categories_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  lpn: String_comparison_exp
  product: products_bool_exp
  product_style: product_styles_bool_exp
  sku: skus_bool_exp
}

"order by max() on columns of table \"wms_items\""
input wms_items_max_order_by {
  id: order_by
  listing_id: order_by
  lpn: order_by
}

"order by min() on columns of table \"wms_items\""
input wms_items_min_order_by {
  id: order_by
  listing_id: order_by
  lpn: order_by
}

"Ordering options when selecting data from \"wms_items\"."
input wms_items_order_by {
  brand: brands_order_by
  brand_category: brand_categories_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  lpn: order_by
  product: products_order_by
  product_style: product_styles_order_by
  sku: skus_order_by
}

"Streaming cursor of the table \"wms_items\""
input wms_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: wms_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input wms_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  lpn: String
}

"Boolean expression to filter rows from the table \"workflow_definitions\". All fields are combined with a logical 'AND'."
input workflow_definitions_bool_exp {
  _and: [workflow_definitions_bool_exp!]
  _not: workflow_definitions_bool_exp
  _or: [workflow_definitions_bool_exp!]
  callbacks: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow_items: workflow_items_bool_exp
  workflows: workflows_bool_exp
}

"Ordering options when selecting data from \"workflow_definitions\"."
input workflow_definitions_order_by {
  callbacks: order_by
  created_at: order_by
  id: order_by
  schema: order_by
  type: order_by
  updated_at: order_by
  workflow_items_aggregate: workflow_items_aggregate_order_by
  workflows_aggregate: workflows_aggregate_order_by
}

"Streaming cursor of the table \"workflow_definitions\""
input workflow_definitions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_definitions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_definitions_stream_cursor_value_input {
  callbacks: jsonb
  created_at: timestamptz
  id: uuid
  schema: jsonb
  type: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"workflow_item_event_types\". All fields are combined with a logical 'AND'."
input workflow_item_event_types_bool_exp {
  _and: [workflow_item_event_types_bool_exp!]
  _not: workflow_item_event_types_bool_exp
  _or: [workflow_item_event_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"workflow_item_event_types_enum\". All fields are combined with logical 'AND'."
input workflow_item_event_types_enum_comparison_exp {
  _eq: workflow_item_event_types_enum
  _in: [workflow_item_event_types_enum!]
  _is_null: Boolean
  _neq: workflow_item_event_types_enum
  _nin: [workflow_item_event_types_enum!]
}

"Ordering options when selecting data from \"workflow_item_event_types\"."
input workflow_item_event_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"workflow_item_event_types\""
input workflow_item_event_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_item_event_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_item_event_types_stream_cursor_value_input {
  type: String
}

"order by aggregate values of table \"workflow_item_events\""
input workflow_item_events_aggregate_order_by {
  count: order_by
  max: workflow_item_events_max_order_by
  min: workflow_item_events_min_order_by
}

"Boolean expression to filter rows from the table \"workflow_item_events\". All fields are combined with a logical 'AND'."
input workflow_item_events_bool_exp {
  _and: [workflow_item_events_bool_exp!]
  _not: workflow_item_events_bool_exp
  _or: [workflow_item_events_bool_exp!]
  event_type: workflow_item_event_types_enum_comparison_exp
  id: uuid_comparison_exp
  payload: jsonb_comparison_exp
  timestamp: timestamptz_comparison_exp
  user: users_bool_exp
  value: String_comparison_exp
  workflow_item: workflow_items_bool_exp
  workflow_item_event_type: workflow_item_event_types_bool_exp
  workflow_item_id: uuid_comparison_exp
}

"order by max() on columns of table \"workflow_item_events\""
input workflow_item_events_max_order_by {
  id: order_by
  timestamp: order_by
  value: order_by
  workflow_item_id: order_by
}

"order by min() on columns of table \"workflow_item_events\""
input workflow_item_events_min_order_by {
  id: order_by
  timestamp: order_by
  value: order_by
  workflow_item_id: order_by
}

"Ordering options when selecting data from \"workflow_item_events\"."
input workflow_item_events_order_by {
  event_type: order_by
  id: order_by
  payload: order_by
  timestamp: order_by
  user: users_order_by
  value: order_by
  workflow_item: workflow_items_order_by
  workflow_item_event_type: workflow_item_event_types_order_by
  workflow_item_id: order_by
}

"Streaming cursor of the table \"workflow_item_events\""
input workflow_item_events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_item_events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_item_events_stream_cursor_value_input {
  event_type: workflow_item_event_types_enum
  id: uuid
  payload: jsonb
  timestamp: timestamptz
  value: String
  workflow_item_id: uuid
}

"order by aggregate values of table \"workflow_items\""
input workflow_items_aggregate_order_by {
  count: order_by
  max: workflow_items_max_order_by
  min: workflow_items_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input workflow_items_append_input {
  data: jsonb
}

"Boolean expression to filter rows from the table \"workflow_items\". All fields are combined with a logical 'AND'."
input workflow_items_bool_exp {
  _and: [workflow_items_bool_exp!]
  _not: workflow_items_bool_exp
  _or: [workflow_items_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  id: uuid_comparison_exp
  state: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow: workflows_bool_exp
  workflow_definition: workflow_definitions_bool_exp
  workflow_definition_id: uuid_comparison_exp
  workflow_id: uuid_comparison_exp
  workflow_item_events: workflow_item_events_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input workflow_items_delete_at_path_input {
  data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input workflow_items_delete_elem_input {
  data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input workflow_items_delete_key_input {
  data: String
}

"order by max() on columns of table \"workflow_items\""
input workflow_items_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow_definition_id: order_by
  workflow_id: order_by
}

"order by min() on columns of table \"workflow_items\""
input workflow_items_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow_definition_id: order_by
  workflow_id: order_by
}

"Ordering options when selecting data from \"workflow_items\"."
input workflow_items_order_by {
  brand_id: order_by
  created_at: order_by
  data: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow: workflows_order_by
  workflow_definition: workflow_definitions_order_by
  workflow_definition_id: order_by
  workflow_id: order_by
  workflow_item_events_aggregate: workflow_item_events_aggregate_order_by
}

"primary key columns input for table: workflow_items"
input workflow_items_pk_columns_input {
  id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input workflow_items_prepend_input {
  data: jsonb
}

"input type for updating data in table \"workflow_items\""
input workflow_items_set_input {
  brand_id: uuid
  created_at: timestamptz
  data: jsonb
  id: uuid
  state: String
  updated_at: timestamptz
  workflow_definition_id: uuid
  workflow_id: uuid
}

"Streaming cursor of the table \"workflow_items\""
input workflow_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_items_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  data: jsonb
  id: uuid
  state: String
  updated_at: timestamptz
  workflow_definition_id: uuid
  workflow_id: uuid
}

input workflow_items_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: workflow_items_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: workflow_items_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: workflow_items_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: workflow_items_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: workflow_items_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: workflow_items_set_input
  "filter the rows which have to be updated"
  where: workflow_items_bool_exp!
}

"order by aggregate values of table \"workflows\""
input workflows_aggregate_order_by {
  count: order_by
  max: workflows_max_order_by
  min: workflows_min_order_by
}

"Boolean expression to filter rows from the table \"workflows\". All fields are combined with a logical 'AND'."
input workflows_bool_exp {
  _and: [workflows_bool_exp!]
  _not: workflows_bool_exp
  _or: [workflows_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow_definition: workflow_definitions_bool_exp
  workflow_definition_id: uuid_comparison_exp
  workflow_items: workflow_items_bool_exp
}

"order by max() on columns of table \"workflows\""
input workflows_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition_id: order_by
}

"order by min() on columns of table \"workflows\""
input workflows_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition_id: order_by
}

"Ordering options when selecting data from \"workflows\"."
input workflows_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition: workflow_definitions_order_by
  workflow_definition_id: order_by
  workflow_items_aggregate: workflow_items_aggregate_order_by
}

"Streaming cursor of the table \"workflows\""
input workflows_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflows_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflows_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  workflow_definition_id: uuid
}
