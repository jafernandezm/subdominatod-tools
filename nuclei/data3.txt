"Streaming cursor of the table \"attempted_discount_codes\""
input attempted_discount_codes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attempted_discount_codes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attempted_discount_codes_stream_cursor_value_input {
  discount_amount: numeric
  id: uuid
  order_intent_id: uuid
}

"order by sum() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_sum_order_by {
  discount_amount: order_by
}

"order by var_pop() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_var_pop_order_by {
  discount_amount: order_by
}

"order by var_samp() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_var_samp_order_by {
  discount_amount: order_by
}

"order by variance() on columns of table \"attempted_discount_codes\""
input attempted_discount_codes_variance_order_by {
  discount_amount: order_by
}

"order by aggregate values of table \"attribute_type_options\""
input attribute_type_options_aggregate_order_by {
  count: order_by
  max: attribute_type_options_max_order_by
  min: attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"attribute_type_options\". All fields are combined with a logical 'AND'."
input attribute_type_options_bool_exp {
  _and: [attribute_type_options_bool_exp!]
  _not: attribute_type_options_bool_exp
  _or: [attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: attribute_type_options_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  option: String_comparison_exp
  translations: attribute_type_options_translations_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"attribute_type_options\""
input attribute_type_options_max_order_by {
  attribute_type_id: order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
}

"order by min() on columns of table \"attribute_type_options\""
input attribute_type_options_min_order_by {
  attribute_type_id: order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"attribute_type_options\"."
input attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: attribute_type_options_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  option: order_by
  translations_aggregate: attribute_type_options_translations_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"attribute_type_options\""
input attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  option: String
  updated_at: timestamptz
}

"order by aggregate values of table \"attribute_type_options_translations\""
input attribute_type_options_translations_aggregate_order_by {
  avg: attribute_type_options_translations_avg_order_by
  count: order_by
  max: attribute_type_options_translations_max_order_by
  min: attribute_type_options_translations_min_order_by
  stddev: attribute_type_options_translations_stddev_order_by
  stddev_pop: attribute_type_options_translations_stddev_pop_order_by
  stddev_samp: attribute_type_options_translations_stddev_samp_order_by
  sum: attribute_type_options_translations_sum_order_by
  var_pop: attribute_type_options_translations_var_pop_order_by
  var_samp: attribute_type_options_translations_var_samp_order_by
  variance: attribute_type_options_translations_variance_order_by
}

"order by avg() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"attribute_type_options_translations\". All fields are combined with a logical 'AND'."
input attribute_type_options_translations_bool_exp {
  _and: [attribute_type_options_translations_bool_exp!]
  _not: attribute_type_options_translations_bool_exp
  _or: [attribute_type_options_translations_bool_exp!]
  attribute_type_option_id: uuid_comparison_exp
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
}

"order by max() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_max_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by min() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_min_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"Ordering options when selecting data from \"attribute_type_options_translations\"."
input attribute_type_options_translations_order_by {
  attribute_type_option_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by stddev() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"attribute_type_options_translations\""
input attribute_type_options_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_type_options_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_type_options_translations_stream_cursor_value_input {
  attribute_type_option_id: uuid
  display: String
  id: Int
  lang: String
}

"order by sum() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"attribute_type_options_translations\""
input attribute_type_options_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"attribute_types\""
input attribute_types_aggregate_order_by {
  count: order_by
  max: attribute_types_max_order_by
  min: attribute_types_min_order_by
}

"Boolean expression to filter rows from the table \"attribute_types\". All fields are combined with a logical 'AND'."
input attribute_types_bool_exp {
  _and: [attribute_types_bool_exp!]
  _not: attribute_types_bool_exp
  _or: [attribute_types_bool_exp!]
  attribute_type_options: attribute_type_options_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: attribute_types_translations_bool_exp
  id: uuid_comparison_exp
  translations: attribute_types_translations_bool_exp
  type: String_comparison_exp
}

"order by max() on columns of table \"attribute_types\""
input attribute_types_max_order_by {
  brand_id: order_by
  id: order_by
  type: order_by
}

"order by min() on columns of table \"attribute_types\""
input attribute_types_min_order_by {
  brand_id: order_by
  id: order_by
  type: order_by
}

"Ordering options when selecting data from \"attribute_types\"."
input attribute_types_order_by {
  attribute_type_options_aggregate: attribute_type_options_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: attribute_types_translations_aggregate_order_by
  id: order_by
  translations_aggregate: attribute_types_translations_aggregate_order_by
  type: order_by
}

"Streaming cursor of the table \"attribute_types\""
input attribute_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_types_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  type: String
}

"order by aggregate values of table \"attribute_types_translations\""
input attribute_types_translations_aggregate_order_by {
  avg: attribute_types_translations_avg_order_by
  count: order_by
  max: attribute_types_translations_max_order_by
  min: attribute_types_translations_min_order_by
  stddev: attribute_types_translations_stddev_order_by
  stddev_pop: attribute_types_translations_stddev_pop_order_by
  stddev_samp: attribute_types_translations_stddev_samp_order_by
  sum: attribute_types_translations_sum_order_by
  var_pop: attribute_types_translations_var_pop_order_by
  var_samp: attribute_types_translations_var_samp_order_by
  variance: attribute_types_translations_variance_order_by
}

"order by avg() on columns of table \"attribute_types_translations\""
input attribute_types_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"attribute_types_translations\". All fields are combined with a logical 'AND'."
input attribute_types_translations_bool_exp {
  _and: [attribute_types_translations_bool_exp!]
  _not: attribute_types_translations_bool_exp
  _or: [attribute_types_translations_bool_exp!]
  attribute_type_id: uuid_comparison_exp
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
}

"order by max() on columns of table \"attribute_types_translations\""
input attribute_types_translations_max_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by min() on columns of table \"attribute_types_translations\""
input attribute_types_translations_min_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"Ordering options when selecting data from \"attribute_types_translations\"."
input attribute_types_translations_order_by {
  attribute_type_id: order_by
  display: order_by
  id: order_by
  lang: order_by
}

"order by stddev() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"attribute_types_translations\""
input attribute_types_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"attribute_types_translations\""
input attribute_types_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: attribute_types_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input attribute_types_translations_stream_cursor_value_input {
  attribute_type_id: uuid
  display: String
  id: Int
  lang: String
}

"order by sum() on columns of table \"attribute_types_translations\""
input attribute_types_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"attribute_types_translations\""
input attribute_types_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"attribute_types_translations\""
input attribute_types_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"attribute_types_translations\""
input attribute_types_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"auction_bids\""
input auction_bids_aggregate_order_by {
  avg: auction_bids_avg_order_by
  count: order_by
  max: auction_bids_max_order_by
  min: auction_bids_min_order_by
  stddev: auction_bids_stddev_order_by
  stddev_pop: auction_bids_stddev_pop_order_by
  stddev_samp: auction_bids_stddev_samp_order_by
  sum: auction_bids_sum_order_by
  var_pop: auction_bids_var_pop_order_by
  var_samp: auction_bids_var_samp_order_by
  variance: auction_bids_variance_order_by
}

"order by avg() on columns of table \"auction_bids\""
input auction_bids_avg_order_by {
  amount: order_by
  order: order_by
}

"Boolean expression to filter rows from the table \"auction_bids\". All fields are combined with a logical 'AND'."
input auction_bids_bool_exp {
  _and: [auction_bids_bool_exp!]
  _not: auction_bids_bool_exp
  _or: [auction_bids_bool_exp!]
  address: addresses_bool_exp
  address_id: uuid_comparison_exp
  amount: bigint_comparison_exp
  auction: auctions_bool_exp
  auction_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  payment_intent_id: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by aggregate values of table \"auction_bids_history\""
input auction_bids_history_aggregate_order_by {
  avg: auction_bids_history_avg_order_by
  count: order_by
  max: auction_bids_history_max_order_by
  min: auction_bids_history_min_order_by
  stddev: auction_bids_history_stddev_order_by
  stddev_pop: auction_bids_history_stddev_pop_order_by
  stddev_samp: auction_bids_history_stddev_samp_order_by
  sum: auction_bids_history_sum_order_by
  var_pop: auction_bids_history_var_pop_order_by
  var_samp: auction_bids_history_var_samp_order_by
  variance: auction_bids_history_variance_order_by
}

"order by avg() on columns of table \"auction_bids_history\""
input auction_bids_history_avg_order_by {
  amount: order_by
  order: order_by
}

"Boolean expression to filter rows from the table \"auction_bids_history\". All fields are combined with a logical 'AND'."
input auction_bids_history_bool_exp {
  _and: [auction_bids_history_bool_exp!]
  _not: auction_bids_history_bool_exp
  _or: [auction_bids_history_bool_exp!]
  amount: bigint_comparison_exp
  auction: auctions_bool_exp
  auction_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"auction_bids_history\""
input auction_bids_history_max_order_by {
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user_id: order_by
}

"order by min() on columns of table \"auction_bids_history\""
input auction_bids_history_min_order_by {
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"auction_bids_history\"."
input auction_bids_history_order_by {
  amount: order_by
  auction: auctions_order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_pop() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_pop_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_samp() on columns of table \"auction_bids_history\""
input auction_bids_history_stddev_samp_order_by {
  amount: order_by
  order: order_by
}

"Streaming cursor of the table \"auction_bids_history\""
input auction_bids_history_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auction_bids_history_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auction_bids_history_stream_cursor_value_input {
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  user_id: String
}

"order by sum() on columns of table \"auction_bids_history\""
input auction_bids_history_sum_order_by {
  amount: order_by
  order: order_by
}

"order by var_pop() on columns of table \"auction_bids_history\""
input auction_bids_history_var_pop_order_by {
  amount: order_by
  order: order_by
}

"order by var_samp() on columns of table \"auction_bids_history\""
input auction_bids_history_var_samp_order_by {
  amount: order_by
  order: order_by
}

"order by variance() on columns of table \"auction_bids_history\""
input auction_bids_history_variance_order_by {
  amount: order_by
  order: order_by
}

"input type for inserting data into table \"auction_bids\""
input auction_bids_insert_input {
  address: addresses_obj_rel_insert_input
  address_id: uuid
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  payment_intent_id: String
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"auction_bids\""
input auction_bids_max_order_by {
  address_id: order_by
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"auction_bids\""
input auction_bids_min_order_by {
  address_id: order_by
  amount: order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user_id: order_by
}

"on_conflict condition type for table \"auction_bids\""
input auction_bids_on_conflict {
  constraint: auction_bids_constraint!
  update_columns: [auction_bids_update_column!]! = []
  where: auction_bids_bool_exp
}

"Ordering options when selecting data from \"auction_bids\"."
input auction_bids_order_by {
  address: addresses_order_by
  address_id: order_by
  amount: order_by
  auction: auctions_order_by
  auction_id: order_by
  created_at: order_by
  id: order_by
  order: order_by
  payment_intent_id: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"auction_bids\""
input auction_bids_stddev_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_pop() on columns of table \"auction_bids\""
input auction_bids_stddev_pop_order_by {
  amount: order_by
  order: order_by
}

"order by stddev_samp() on columns of table \"auction_bids\""
input auction_bids_stddev_samp_order_by {
  amount: order_by
  order: order_by
}

"Streaming cursor of the table \"auction_bids\""
input auction_bids_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auction_bids_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auction_bids_stream_cursor_value_input {
  address_id: uuid
  amount: bigint
  auction_id: uuid
  created_at: timestamptz
  id: uuid
  order: Int
  payment_intent_id: String
  user_id: String
}

"order by sum() on columns of table \"auction_bids\""
input auction_bids_sum_order_by {
  amount: order_by
  order: order_by
}

"order by var_pop() on columns of table \"auction_bids\""
input auction_bids_var_pop_order_by {
  amount: order_by
  order: order_by
}

"order by var_samp() on columns of table \"auction_bids\""
input auction_bids_var_samp_order_by {
  amount: order_by
  order: order_by
}

"order by variance() on columns of table \"auction_bids\""
input auction_bids_variance_order_by {
  amount: order_by
  order: order_by
}

"order by aggregate values of table \"auctions\""
input auctions_aggregate_order_by {
  avg: auctions_avg_order_by
  count: order_by
  max: auctions_max_order_by
  min: auctions_min_order_by
  stddev: auctions_stddev_order_by
  stddev_pop: auctions_stddev_pop_order_by
  stddev_samp: auctions_stddev_samp_order_by
  sum: auctions_sum_order_by
  var_pop: auctions_var_pop_order_by
  var_samp: auctions_var_samp_order_by
  variance: auctions_variance_order_by
}

"order by avg() on columns of table \"auctions\""
input auctions_avg_order_by {
  max_price: order_by
}

"Boolean expression to filter rows from the table \"auctions\". All fields are combined with a logical 'AND'."
input auctions_bool_exp {
  _and: [auctions_bool_exp!]
  _not: auctions_bool_exp
  _or: [auctions_bool_exp!]
  bids: auction_bids_bool_exp
  bids_histories: auction_bids_history_bool_exp
  end: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  max_price: Int_comparison_exp
  start: timestamptz_comparison_exp
}

"order by max() on columns of table \"auctions\""
input auctions_max_order_by {
  end: order_by
  id: order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"order by min() on columns of table \"auctions\""
input auctions_min_order_by {
  end: order_by
  id: order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"Ordering options when selecting data from \"auctions\"."
input auctions_order_by {
  bids_aggregate: auction_bids_aggregate_order_by
  bids_histories_aggregate: auction_bids_history_aggregate_order_by
  end: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  max_price: order_by
  start: order_by
}

"order by stddev() on columns of table \"auctions\""
input auctions_stddev_order_by {
  max_price: order_by
}

"order by stddev_pop() on columns of table \"auctions\""
input auctions_stddev_pop_order_by {
  max_price: order_by
}

"order by stddev_samp() on columns of table \"auctions\""
input auctions_stddev_samp_order_by {
  max_price: order_by
}

"Streaming cursor of the table \"auctions\""
input auctions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: auctions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input auctions_stream_cursor_value_input {
  end: timestamptz
  id: uuid
  listing_id: uuid
  max_price: Int
  start: timestamptz
}

"order by sum() on columns of table \"auctions\""
input auctions_sum_order_by {
  max_price: order_by
}

"order by var_pop() on columns of table \"auctions\""
input auctions_var_pop_order_by {
  max_price: order_by
}

"order by var_samp() on columns of table \"auctions\""
input auctions_var_samp_order_by {
  max_price: order_by
}

"order by variance() on columns of table \"auctions\""
input auctions_variance_order_by {
  max_price: order_by
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"order by aggregate values of table \"brand_categories\""
input brand_categories_aggregate_order_by {
  avg: brand_categories_avg_order_by
  count: order_by
  max: brand_categories_max_order_by
  min: brand_categories_min_order_by
  stddev: brand_categories_stddev_order_by
  stddev_pop: brand_categories_stddev_pop_order_by
  stddev_samp: brand_categories_stddev_samp_order_by
  sum: brand_categories_sum_order_by
  var_pop: brand_categories_var_pop_order_by
  var_samp: brand_categories_var_samp_order_by
  variance: brand_categories_variance_order_by
}

"order by avg() on columns of table \"brand_categories\""
input brand_categories_avg_order_by {
  default_price_multiplier: order_by
}

"Boolean expression to filter rows from the table \"brand_categories\". All fields are combined with a logical 'AND'."
input brand_categories_bool_exp {
  _and: [brand_categories_bool_exp!]
  _not: brand_categories_bool_exp
  _or: [brand_categories_bool_exp!]
  brand: brands_bool_exp
  brand_categories: brand_categories_bool_exp
  brand_category: brand_categories_bool_exp
  brand_id: uuid_comparison_exp
  category_translations: brand_categories_translations_bool_exp
  category_translations_aggregate: brand_categories_translations_aggregate_bool_exp
  content: brand_categories_translations_bool_exp
  created_at: timestamptz_comparison_exp
  default_price_multiplier: numeric_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  products: products_bool_exp
  productsBySuperCategoryId: products_bool_exp
  productsBySuperCategoryId_aggregate: products_aggregate_bool_exp
  products_aggregate: products_aggregate_bool_exp
  singular: String_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_categories\""
input brand_categories_max_order_by {
  brand_id: order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_categories\""
input brand_categories_min_order_by {
  brand_id: order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_categories\"."
input brand_categories_order_by {
  brand: brands_order_by
  brand_categories_aggregate: brand_categories_aggregate_order_by
  brand_category: brand_categories_order_by
  brand_id: order_by
  category_translations_aggregate: brand_categories_translations_aggregate_order_by
  content_aggregate: brand_categories_translations_aggregate_order_by
  created_at: order_by
  default_price_multiplier: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  productsBySuperCategoryId_aggregate: products_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  singular: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_categories\""
input brand_categories_stddev_order_by {
  default_price_multiplier: order_by
}

"order by stddev_pop() on columns of table \"brand_categories\""
input brand_categories_stddev_pop_order_by {
  default_price_multiplier: order_by
}

"order by stddev_samp() on columns of table \"brand_categories\""
input brand_categories_stddev_samp_order_by {
  default_price_multiplier: order_by
}

"Streaming cursor of the table \"brand_categories\""
input brand_categories_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_categories_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_categories_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  default_price_multiplier: numeric
  id: uuid
  name: String
  parent_id: uuid
  singular: String
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_categories\""
input brand_categories_sum_order_by {
  default_price_multiplier: order_by
}

input brand_categories_translations_aggregate_bool_exp {
  count: brand_categories_translations_aggregate_bool_exp_count
}

input brand_categories_translations_aggregate_bool_exp_count {
  arguments: [brand_categories_translations_select_column!]
  distinct: Boolean
  filter: brand_categories_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"brand_categories_translations\""
input brand_categories_translations_aggregate_order_by {
  avg: brand_categories_translations_avg_order_by
  count: order_by
  max: brand_categories_translations_max_order_by
  min: brand_categories_translations_min_order_by
  stddev: brand_categories_translations_stddev_order_by
  stddev_pop: brand_categories_translations_stddev_pop_order_by
  stddev_samp: brand_categories_translations_stddev_samp_order_by
  sum: brand_categories_translations_sum_order_by
  var_pop: brand_categories_translations_var_pop_order_by
  var_samp: brand_categories_translations_var_samp_order_by
  variance: brand_categories_translations_variance_order_by
}

"order by avg() on columns of table \"brand_categories_translations\""
input brand_categories_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"brand_categories_translations\". All fields are combined with a logical 'AND'."
input brand_categories_translations_bool_exp {
  _and: [brand_categories_translations_bool_exp!]
  _not: brand_categories_translations_bool_exp
  _or: [brand_categories_translations_bool_exp!]
  category_id: uuid_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  singular: String_comparison_exp
}

"order by max() on columns of table \"brand_categories_translations\""
input brand_categories_translations_max_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"order by min() on columns of table \"brand_categories_translations\""
input brand_categories_translations_min_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"Ordering options when selecting data from \"brand_categories_translations\"."
input brand_categories_translations_order_by {
  category_id: order_by
  id: order_by
  lang: order_by
  name: order_by
  singular: order_by
}

"order by stddev() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"brand_categories_translations\""
input brand_categories_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"brand_categories_translations\""
input brand_categories_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_categories_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_categories_translations_stream_cursor_value_input {
  category_id: uuid
  id: Int
  lang: String
  name: String
  singular: String
}

"order by sum() on columns of table \"brand_categories_translations\""
input brand_categories_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"brand_categories_translations\""
input brand_categories_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"brand_categories_translations\""
input brand_categories_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"brand_categories_translations\""
input brand_categories_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"brand_categories\""
input brand_categories_var_pop_order_by {
  default_price_multiplier: order_by
}

"order by var_samp() on columns of table \"brand_categories\""
input brand_categories_var_samp_order_by {
  default_price_multiplier: order_by
}

"order by variance() on columns of table \"brand_categories\""
input brand_categories_variance_order_by {
  default_price_multiplier: order_by
}

"order by aggregate values of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_aggregate_order_by {
  avg: brand_fulfillment_in_store_options_avg_order_by
  count: order_by
  max: brand_fulfillment_in_store_options_max_order_by
  min: brand_fulfillment_in_store_options_min_order_by
  stddev: brand_fulfillment_in_store_options_stddev_order_by
  stddev_pop: brand_fulfillment_in_store_options_stddev_pop_order_by
  stddev_samp: brand_fulfillment_in_store_options_stddev_samp_order_by
  sum: brand_fulfillment_in_store_options_sum_order_by
  var_pop: brand_fulfillment_in_store_options_var_pop_order_by
  var_samp: brand_fulfillment_in_store_options_var_samp_order_by
  variance: brand_fulfillment_in_store_options_variance_order_by
}

"order by avg() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_in_store_options\". All fields are combined with a logical 'AND'."
input brand_fulfillment_in_store_options_bool_exp {
  _and: [brand_fulfillment_in_store_options_bool_exp!]
  _not: brand_fulfillment_in_store_options_bool_exp
  _or: [brand_fulfillment_in_store_options_bool_exp!]
  brand_fulfillment_in_store_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_max_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_min_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_in_store_options\"."
input brand_fulfillment_in_store_options_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_in_store_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_in_store_options_stream_cursor_value_input {
  brand_fulfillment_in_store_settings_id: uuid
  created_at: timestamptz
  id: uuid
  retail_store_id: uuid
  shipping_fee: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"brand_fulfillment_in_store_options\""
input brand_fulfillment_in_store_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_in_store_settings_max_order_by
  min: brand_fulfillment_in_store_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_in_store_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_in_store_settings_bool_exp {
  _and: [brand_fulfillment_in_store_settings_bool_exp!]
  _not: brand_fulfillment_in_store_settings_bool_exp
  _or: [brand_fulfillment_in_store_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: brand_fulfillment_in_store_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_in_store_settings\"."
input brand_fulfillment_in_store_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: brand_fulfillment_in_store_options_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_in_store_settings\""
input brand_fulfillment_in_store_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_in_store_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_in_store_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_aggregate_order_by {
  avg: brand_fulfillment_postal_options_avg_order_by
  count: order_by
  max: brand_fulfillment_postal_options_max_order_by
  min: brand_fulfillment_postal_options_min_order_by
  stddev: brand_fulfillment_postal_options_stddev_order_by
  stddev_pop: brand_fulfillment_postal_options_stddev_pop_order_by
  stddev_samp: brand_fulfillment_postal_options_stddev_samp_order_by
  sum: brand_fulfillment_postal_options_sum_order_by
  var_pop: brand_fulfillment_postal_options_var_pop_order_by
  var_samp: brand_fulfillment_postal_options_var_samp_order_by
  variance: brand_fulfillment_postal_options_variance_order_by
}

"order by avg() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_postal_options\". All fields are combined with a logical 'AND'."
input brand_fulfillment_postal_options_bool_exp {
  _and: [brand_fulfillment_postal_options_bool_exp!]
  _not: brand_fulfillment_postal_options_bool_exp
  _or: [brand_fulfillment_postal_options_bool_exp!]
  brand_fulfillment_postal_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  postal_options_id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_max_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_min_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_postal_options\"."
input brand_fulfillment_postal_options_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  postal_options_id: order_by
  shipping_fee: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_postal_options_stream_cursor_value_input {
  brand_fulfillment_postal_settings_id: uuid
  created_at: timestamptz
  id: uuid
  postal_options_id: uuid
  shipping_fee: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"brand_fulfillment_postal_options\""
input brand_fulfillment_postal_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_postal_settings_max_order_by
  min: brand_fulfillment_postal_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_postal_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_postal_settings_bool_exp {
  _and: [brand_fulfillment_postal_settings_bool_exp!]
  _not: brand_fulfillment_postal_settings_bool_exp
  _or: [brand_fulfillment_postal_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: brand_fulfillment_postal_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_postal_settings\"."
input brand_fulfillment_postal_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: brand_fulfillment_postal_options_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_postal_settings\""
input brand_fulfillment_postal_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_postal_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_postal_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_aggregate_order_by {
  count: order_by
  max: brand_fulfillment_settings_max_order_by
  min: brand_fulfillment_settings_min_order_by
}

"Boolean expression to filter rows from the table \"brand_fulfillment_settings\". All fields are combined with a logical 'AND'."
input brand_fulfillment_settings_bool_exp {
  _and: [brand_fulfillment_settings_bool_exp!]
  _not: brand_fulfillment_settings_bool_exp
  _or: [brand_fulfillment_settings_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  fulfillment_type: fulfillment_types_enum_comparison_exp
  id: uuid_comparison_exp
  in_store_settings: brand_fulfillment_in_store_settings_bool_exp
  name: String_comparison_exp
  postal_settings: brand_fulfillment_postal_settings_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"order by min() on columns of table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"brand_fulfillment_settings\"."
input brand_fulfillment_settings_order_by {
  brand_id: order_by
  created_at: order_by
  fulfillment_type: order_by
  id: order_by
  in_store_settings_aggregate: brand_fulfillment_in_store_settings_aggregate_order_by
  name: order_by
  postal_settings_aggregate: brand_fulfillment_postal_settings_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brand_fulfillment_settings\""
input brand_fulfillment_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_fulfillment_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_fulfillment_settings_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  fulfillment_type: fulfillment_types_enum
  id: uuid
  name: String
  updated_at: timestamptz
}

"order by aggregate values of table \"brand_passwords\""
input brand_passwords_aggregate_order_by {
  count: order_by
  max: brand_passwords_max_order_by
  min: brand_passwords_min_order_by
}

"Boolean expression to filter rows from the table \"brand_passwords\". All fields are combined with a logical 'AND'."
input brand_passwords_bool_exp {
  _and: [brand_passwords_bool_exp!]
  _not: brand_passwords_bool_exp
  _or: [brand_passwords_bool_exp!]
  brand_id: uuid_comparison_exp
  enabled: Boolean_comparison_exp
}

"order by max() on columns of table \"brand_passwords\""
input brand_passwords_max_order_by {
  brand_id: order_by
}

"order by min() on columns of table \"brand_passwords\""
input brand_passwords_min_order_by {
  brand_id: order_by
}

"Ordering options when selecting data from \"brand_passwords\"."
input brand_passwords_order_by {
  brand_id: order_by
  enabled: order_by
}

"Streaming cursor of the table \"brand_passwords\""
input brand_passwords_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brand_passwords_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brand_passwords_stream_cursor_value_input {
  brand_id: uuid
  enabled: Boolean
}

"Boolean expression to filter rows from the table \"brands\". All fields are combined with a logical 'AND'."
input brands_bool_exp {
  _and: [brands_bool_exp!]
  _not: brands_bool_exp
  _or: [brands_bool_exp!]
  attribute_type_options: attribute_type_options_bool_exp
  attribute_types: attribute_types_bool_exp
  categories: brand_categories_bool_exp
  condition_questions: condition_questions_bool_exp
  content: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  fulfillment_settings: brand_fulfillment_settings_bool_exp
  id: uuid_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  name: String_comparison_exp
  passwords: brand_passwords_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  searchable_products_results: searchable_products_results_bool_exp
  searchable_products_results_aggregate: searchable_products_results_aggregate_bool_exp
  settings: jsonb_comparison_exp
  skus: skus_bool_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"brands\"."
input brands_order_by {
  attribute_type_options_aggregate: attribute_type_options_aggregate_order_by
  attribute_types_aggregate: attribute_types_aggregate_order_by
  categories_aggregate: brand_categories_aggregate_order_by
  condition_questions_aggregate: condition_questions_aggregate_order_by
  content: order_by
  created_at: order_by
  fulfillment_settings_aggregate: brand_fulfillment_settings_aggregate_order_by
  id: order_by
  listings_aggregate: listings_aggregate_order_by
  name: order_by
  passwords_aggregate: brand_passwords_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  searchable_products_results_aggregate: searchable_products_results_aggregate_order_by
  settings: order_by
  skus_aggregate: skus_aggregate_order_by
  slug: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"brands\""
input brands_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: brands_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input brands_stream_cursor_value_input {
  content: jsonb
  created_at: timestamptz
  id: uuid
  name: String
  settings: jsonb
  slug: String
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"building_access_types_enum\". All fields are combined with logical 'AND'."
input building_access_types_enum_comparison_exp {
  _eq: building_access_types_enum
  _in: [building_access_types_enum!]
  _is_null: Boolean
  _neq: building_access_types_enum
  _nin: [building_access_types_enum!]
}

"Boolean expression to compare columns of type \"chat_channel_types_enum\". All fields are combined with logical 'AND'."
input chat_channel_types_enum_comparison_exp {
  _eq: chat_channel_types_enum
  _in: [chat_channel_types_enum!]
  _is_null: Boolean
  _neq: chat_channel_types_enum
  _nin: [chat_channel_types_enum!]
}

"Boolean expression to filter rows from the table \"chat_channels\". All fields are combined with a logical 'AND'."
input chat_channels_bool_exp {
  _and: [chat_channels_bool_exp!]
  _not: chat_channels_bool_exp
  _or: [chat_channels_bool_exp!]
  brand_id: uuid_comparison_exp
  channel_external_identifier: String_comparison_exp
  channel_type: chat_channel_types_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  key: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"chat_channels\"."
input chat_channels_order_by {
  brand_id: order_by
  channel_external_identifier: order_by
  channel_type: order_by
  created_at: order_by
  key: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"chat_channels\""
input chat_channels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: chat_channels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input chat_channels_stream_cursor_value_input {
  brand_id: uuid
  channel_external_identifier: String
  channel_type: chat_channel_types_enum
  created_at: timestamptz
  key: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"collapsed_product_results\". All fields are combined with a logical 'AND'."
input collapsed_product_results_bool_exp {
  _and: [collapsed_product_results_bool_exp!]
  _not: collapsed_product_results_bool_exp
  _or: [collapsed_product_results_bool_exp!]
  part_id: String_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"collapsed_product_results\"."
input collapsed_product_results_order_by {
  part_id: order_by
  product: products_order_by
  product_id: order_by
}

"Streaming cursor of the table \"collapsed_product_results\""
input collapsed_product_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collapsed_product_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collapsed_product_results_stream_cursor_value_input {
  part_id: String
  product_id: uuid
}

"Boolean expression to filter rows from the table \"collection_media_groups\". All fields are combined with a logical 'AND'."
input collection_media_groups_bool_exp {
  _and: [collection_media_groups_bool_exp!]
  _not: collection_media_groups_bool_exp
  _or: [collection_media_groups_bool_exp!]
  collection_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  media_group_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"collection_media_groups\"."
input collection_media_groups_order_by {
  collection_id: order_by
  created_at: order_by
  media_group_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"collection_media_groups\""
input collection_media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collection_media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collection_media_groups_stream_cursor_value_input {
  collection_id: uuid
  created_at: timestamptz
  media_group_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"collection_types_enum\". All fields are combined with logical 'AND'."
input collection_types_enum_comparison_exp {
  _eq: collection_types_enum
  _in: [collection_types_enum!]
  _is_null: Boolean
  _neq: collection_types_enum
  _nin: [collection_types_enum!]
}

"Boolean expression to filter rows from the table \"collections\". All fields are combined with a logical 'AND'."
input collections_bool_exp {
  _and: [collections_bool_exp!]
  _not: collections_bool_exp
  _or: [collections_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: collections_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  read_only: Boolean_comparison_exp
  slug: String_comparison_exp
  translations: collections_translations_bool_exp
  type: collection_types_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"collections\"."
input collections_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: collections_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  read_only: order_by
  slug: order_by
  translations_aggregate: collections_translations_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"collections\""
input collections_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collections_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collections_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  read_only: Boolean
  slug: String
  type: collection_types_enum
  updated_at: timestamptz
}

"order by aggregate values of table \"collections_translations\""
input collections_translations_aggregate_order_by {
  avg: collections_translations_avg_order_by
  count: order_by
  max: collections_translations_max_order_by
  min: collections_translations_min_order_by
  stddev: collections_translations_stddev_order_by
  stddev_pop: collections_translations_stddev_pop_order_by
  stddev_samp: collections_translations_stddev_samp_order_by
  sum: collections_translations_sum_order_by
  var_pop: collections_translations_var_pop_order_by
  var_samp: collections_translations_var_samp_order_by
  variance: collections_translations_variance_order_by
}

"order by avg() on columns of table \"collections_translations\""
input collections_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"collections_translations\". All fields are combined with a logical 'AND'."
input collections_translations_bool_exp {
  _and: [collections_translations_bool_exp!]
  _not: collections_translations_bool_exp
  _or: [collections_translations_bool_exp!]
  collection_id: uuid_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: Int_comparison_exp
  locale: String_comparison_exp
}

"order by max() on columns of table \"collections_translations\""
input collections_translations_max_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"order by min() on columns of table \"collections_translations\""
input collections_translations_min_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"Ordering options when selecting data from \"collections_translations\"."
input collections_translations_order_by {
  collection_id: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
}

"order by stddev() on columns of table \"collections_translations\""
input collections_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"collections_translations\""
input collections_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"collections_translations\""
input collections_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"collections_translations\""
input collections_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collections_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collections_translations_stream_cursor_value_input {
  collection_id: uuid
  description: String
  display_name: String
  id: Int
  locale: String
}

"order by sum() on columns of table \"collections_translations\""
input collections_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"collections_translations\""
input collections_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"collections_translations\""
input collections_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"collections_translations\""
input collections_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"condition_questions\""
input condition_questions_aggregate_order_by {
  avg: condition_questions_avg_order_by
  count: order_by
  max: condition_questions_max_order_by
  min: condition_questions_min_order_by
  stddev: condition_questions_stddev_order_by
  stddev_pop: condition_questions_stddev_pop_order_by
  stddev_samp: condition_questions_stddev_samp_order_by
  sum: condition_questions_sum_order_by
  var_pop: condition_questions_var_pop_order_by
  var_samp: condition_questions_var_samp_order_by
  variance: condition_questions_variance_order_by
}

"order by avg() on columns of table \"condition_questions\""
input condition_questions_avg_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"Boolean expression to filter rows from the table \"condition_questions\". All fields are combined with a logical 'AND'."
input condition_questions_bool_exp {
  _and: [condition_questions_bool_exp!]
  _not: condition_questions_bool_exp
  _or: [condition_questions_bool_exp!]
  addl_info_comment: Boolean_comparison_exp
  addl_info_comment_required: Boolean_comparison_exp
  addl_info_images: Boolean_comparison_exp
  addl_info_images_required: Boolean_comparison_exp
  addl_info_on_response_value: Boolean_comparison_exp
  addl_info_prompt: String_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: condition_questions_translations_bool_exp
  depends_on_question: condition_questions_bool_exp
  depends_on_question_id: uuid_comparison_exp
  depends_on_response_value: Boolean_comparison_exp
  fail_description: String_comparison_exp
  fail_on_response_value: Boolean_comparison_exp
  help_text: String_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing_description_false: String_comparison_exp
  listing_description_true: String_comparison_exp
  question_set_id: uuid_comparison_exp
  score_false: Int_comparison_exp
  score_true: Int_comparison_exp
  severity: Boolean_comparison_exp
  severity_on_response_value: Boolean_comparison_exp
  severity_text: String_comparison_exp
  text: String_comparison_exp
}

"order by max() on columns of table \"condition_questions\""
input condition_questions_max_order_by {
  addl_info_prompt: order_by
  brand_id: order_by
  depends_on_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity_text: order_by
  text: order_by
}

"order by min() on columns of table \"condition_questions\""
input condition_questions_min_order_by {
  addl_info_prompt: order_by
  brand_id: order_by
  depends_on_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity_text: order_by
  text: order_by
}

"Ordering options when selecting data from \"condition_questions\"."
input condition_questions_order_by {
  addl_info_comment: order_by
  addl_info_comment_required: order_by
  addl_info_images: order_by
  addl_info_images_required: order_by
  addl_info_on_response_value: order_by
  addl_info_prompt: order_by
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: condition_questions_translations_aggregate_order_by
  depends_on_question: condition_questions_order_by
  depends_on_question_id: order_by
  depends_on_response_value: order_by
  fail_description: order_by
  fail_on_response_value: order_by
  help_text: order_by
  hidden: order_by
  id: order_by
  index: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  question_set_id: order_by
  score_false: order_by
  score_true: order_by
  severity: order_by
  severity_on_response_value: order_by
  severity_text: order_by
  text: order_by
}

"order by stddev() on columns of table \"condition_questions\""
input condition_questions_stddev_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by stddev_pop() on columns of table \"condition_questions\""
input condition_questions_stddev_pop_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by stddev_samp() on columns of table \"condition_questions\""
input condition_questions_stddev_samp_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"Streaming cursor of the table \"condition_questions\""
input condition_questions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_questions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_questions_stream_cursor_value_input {
  addl_info_comment: Boolean
  addl_info_comment_required: Boolean
  addl_info_images: Boolean
  addl_info_images_required: Boolean
  addl_info_on_response_value: Boolean
  addl_info_prompt: String
  brand_id: uuid
  depends_on_question_id: uuid
  depends_on_response_value: Boolean
  fail_description: String
  fail_on_response_value: Boolean
  help_text: String
  hidden: Boolean
  id: uuid
  index: Int
  listing_description_false: String
  listing_description_true: String
  question_set_id: uuid
  score_false: Int
  score_true: Int
  severity: Boolean
  severity_on_response_value: Boolean
  severity_text: String
  text: String
}

"order by sum() on columns of table \"condition_questions\""
input condition_questions_sum_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by aggregate values of table \"condition_questions_translations\""
input condition_questions_translations_aggregate_order_by {
  avg: condition_questions_translations_avg_order_by
  count: order_by
  max: condition_questions_translations_max_order_by
  min: condition_questions_translations_min_order_by
  stddev: condition_questions_translations_stddev_order_by
  stddev_pop: condition_questions_translations_stddev_pop_order_by
  stddev_samp: condition_questions_translations_stddev_samp_order_by
  sum: condition_questions_translations_sum_order_by
  var_pop: condition_questions_translations_var_pop_order_by
  var_samp: condition_questions_translations_var_samp_order_by
  variance: condition_questions_translations_variance_order_by
}

"order by avg() on columns of table \"condition_questions_translations\""
input condition_questions_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"condition_questions_translations\". All fields are combined with a logical 'AND'."
input condition_questions_translations_bool_exp {
  _and: [condition_questions_translations_bool_exp!]
  _not: condition_questions_translations_bool_exp
  _or: [condition_questions_translations_bool_exp!]
  addl_info_prompt: String_comparison_exp
  condition_question_id: uuid_comparison_exp
  fail_description: String_comparison_exp
  help_text: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  listing_description_false: String_comparison_exp
  listing_description_true: String_comparison_exp
  severity_text: String_comparison_exp
  text: String_comparison_exp
}

"order by max() on columns of table \"condition_questions_translations\""
input condition_questions_translations_max_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"order by min() on columns of table \"condition_questions_translations\""
input condition_questions_translations_min_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"Ordering options when selecting data from \"condition_questions_translations\"."
input condition_questions_translations_order_by {
  addl_info_prompt: order_by
  condition_question_id: order_by
  fail_description: order_by
  help_text: order_by
  id: order_by
  lang: order_by
  listing_description_false: order_by
  listing_description_true: order_by
  severity_text: order_by
  text: order_by
}

"order by stddev() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"condition_questions_translations\""
input condition_questions_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"condition_questions_translations\""
input condition_questions_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_questions_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_questions_translations_stream_cursor_value_input {
  addl_info_prompt: String
  condition_question_id: uuid
  fail_description: String
  help_text: String
  id: Int
  lang: String
  listing_description_false: String
  listing_description_true: String
  severity_text: String
  text: String
}

"order by sum() on columns of table \"condition_questions_translations\""
input condition_questions_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"condition_questions_translations\""
input condition_questions_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"condition_questions_translations\""
input condition_questions_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"condition_questions_translations\""
input condition_questions_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"condition_questions\""
input condition_questions_var_pop_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by var_samp() on columns of table \"condition_questions\""
input condition_questions_var_samp_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by variance() on columns of table \"condition_questions\""
input condition_questions_variance_order_by {
  index: order_by
  score_false: order_by
  score_true: order_by
}

"order by aggregate values of table \"condition_responses\""
input condition_responses_aggregate_order_by {
  avg: condition_responses_avg_order_by
  count: order_by
  max: condition_responses_max_order_by
  min: condition_responses_min_order_by
  stddev: condition_responses_stddev_order_by
  stddev_pop: condition_responses_stddev_pop_order_by
  stddev_samp: condition_responses_stddev_samp_order_by
  sum: condition_responses_sum_order_by
  var_pop: condition_responses_var_pop_order_by
  var_samp: condition_responses_var_samp_order_by
  variance: condition_responses_variance_order_by
}

"order by avg() on columns of table \"condition_responses\""
input condition_responses_avg_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"condition_responses\". All fields are combined with a logical 'AND'."
input condition_responses_bool_exp {
  _and: [condition_responses_bool_exp!]
  _not: condition_responses_bool_exp
  _or: [condition_responses_bool_exp!]
  comment: String_comparison_exp
  condition_question: condition_questions_bool_exp
  condition_question_id: uuid_comparison_exp
  id: uuid_comparison_exp
  images: listing_images_bool_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  response: Boolean_comparison_exp
  score: Int_comparison_exp
  severity: Int_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"condition_responses\""
input condition_responses_insert_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  images: listing_images_arr_rel_insert_input
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by max() on columns of table \"condition_responses\""
input condition_responses_max_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by min() on columns of table \"condition_responses\""
input condition_responses_min_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"condition_responses\""
input condition_responses_obj_rel_insert_input {
  data: condition_responses_insert_input!
  "upsert condition"
  on_conflict: condition_responses_on_conflict
}

"on_conflict condition type for table \"condition_responses\""
input condition_responses_on_conflict {
  constraint: condition_responses_constraint!
  update_columns: [condition_responses_update_column!]! = []
  where: condition_responses_bool_exp
}

"Ordering options when selecting data from \"condition_responses\"."
input condition_responses_order_by {
  comment: order_by
  condition_question: condition_questions_order_by
  condition_question_id: order_by
  id: order_by
  images_aggregate: listing_images_aggregate_order_by
  listing: listings_order_by
  listing_id: order_by
  response: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"condition_responses\""
input condition_responses_stddev_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_pop() on columns of table \"condition_responses\""
input condition_responses_stddev_pop_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_samp() on columns of table \"condition_responses\""
input condition_responses_stddev_samp_order_by {
  score: order_by
  severity: order_by
}

"Streaming cursor of the table \"condition_responses\""
input condition_responses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: condition_responses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input condition_responses_stream_cursor_value_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by sum() on columns of table \"condition_responses\""
input condition_responses_sum_order_by {
  score: order_by
  severity: order_by
}

"order by var_pop() on columns of table \"condition_responses\""
input condition_responses_var_pop_order_by {
  score: order_by
  severity: order_by
}

"order by var_samp() on columns of table \"condition_responses\""
input condition_responses_var_samp_order_by {
  score: order_by
  severity: order_by
}

"order by variance() on columns of table \"condition_responses\""
input condition_responses_variance_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"credit\". All fields are combined with a logical 'AND'."
input credit_bool_exp {
  _and: [credit_bool_exp!]
  _not: credit_bool_exp
  _or: [credit_bool_exp!]
  credit_takeback: takebacks_bool_exp
  credit_takeback_aggregate: takebacks_aggregate_bool_exp
  credit_takeback_item: takeback_items_bool_exp
  credit_type: credit_types_enum_comparison_exp
  currency_code: String_comparison_exp
  currency_value: Int_comparison_exp
  estimated_credit_takeback: takebacks_bool_exp
  estimated_credit_takeback_aggregate: takebacks_aggregate_bool_exp
  estimated_credit_takeback_item: takeback_items_bool_exp
  id: uuid_comparison_exp
}

"Ordering options when selecting data from \"credit\"."
input credit_order_by {
  credit_takeback_aggregate: takebacks_aggregate_order_by
  credit_takeback_item_aggregate: takeback_items_aggregate_order_by
  credit_type: order_by
  currency_code: order_by
  currency_value: order_by
  estimated_credit_takeback_aggregate: takebacks_aggregate_order_by
  estimated_credit_takeback_item_aggregate: takeback_items_aggregate_order_by
  id: order_by
}

"Streaming cursor of the table \"credit\""
input credit_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: credit_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input credit_stream_cursor_value_input {
  credit_type: credit_types_enum
  currency_code: String
  currency_value: Int
  id: uuid
}

"Boolean expression to compare columns of type \"credit_types_enum\". All fields are combined with logical 'AND'."
input credit_types_enum_comparison_exp {
  _eq: credit_types_enum
  _in: [credit_types_enum!]
  _is_null: Boolean
  _neq: credit_types_enum
  _nin: [credit_types_enum!]
}

"Boolean expression to filter rows from the table \"dac7_verified_storefronts\". All fields are combined with a logical 'AND'."
input dac7_verified_storefronts_bool_exp {
  _and: [dac7_verified_storefronts_bool_exp!]
  _not: dac7_verified_storefronts_bool_exp
  _or: [dac7_verified_storefronts_bool_exp!]
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"dac7_verified_storefronts\"."
input dac7_verified_storefronts_order_by {
  storefront: storefronts_order_by
  storefront_id: order_by
}

"Streaming cursor of the table \"dac7_verified_storefronts\""
input dac7_verified_storefronts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: dac7_verified_storefronts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input dac7_verified_storefronts_stream_cursor_value_input {
  storefront_id: uuid
}

"append existing jsonb value of filtered columns with new jsonb value"
input email_signups_append_input {
  payload: jsonb
}

"Boolean expression to filter rows from the table \"email_signups\". All fields are combined with a logical 'AND'."
input email_signups_bool_exp {
  _and: [email_signups_bool_exp!]
  _not: email_signups_bool_exp
  _or: [email_signups_bool_exp!]
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input email_signups_delete_at_path_input {
  payload: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input email_signups_delete_elem_input {
  payload: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input email_signups_delete_key_input {
  payload: String
}

"input type for inserting data into table \"email_signups\""
input email_signups_insert_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  interest_in_selling: Boolean
  payload: jsonb
  type: String
}

"on_conflict condition type for table \"email_signups\""
input email_signups_on_conflict {
  constraint: email_signups_constraint!
  update_columns: [email_signups_update_column!]! = []
  where: email_signups_bool_exp
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input email_signups_prepend_input {
  payload: jsonb
}

"input type for updating data in table \"email_signups\""
input email_signups_set_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  interest_in_selling: Boolean
  payload: jsonb
  type: String
}

input email_signups_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: email_signups_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: email_signups_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: email_signups_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: email_signups_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: email_signups_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: email_signups_set_input
  "filter the rows which have to be updated"
  where: email_signups_bool_exp!
}

"order by aggregate values of table \"external_sku_ids\""
input external_sku_ids_aggregate_order_by {
  count: order_by
  max: external_sku_ids_max_order_by
  min: external_sku_ids_min_order_by
}

"Boolean expression to filter rows from the table \"external_sku_ids\". All fields are combined with a logical 'AND'."
input external_sku_ids_bool_exp {
  _and: [external_sku_ids_bool_exp!]
  _not: external_sku_ids_bool_exp
  _or: [external_sku_ids_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  external_id: String_comparison_exp
  external_id_type: String_comparison_exp
  id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
}

"order by max() on columns of table \"external_sku_ids\""
input external_sku_ids_max_order_by {
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku_id: order_by
}

"order by min() on columns of table \"external_sku_ids\""
input external_sku_ids_min_order_by {
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku_id: order_by
}

"Ordering options when selecting data from \"external_sku_ids\"."
input external_sku_ids_order_by {
  brand: brands_order_by
  brand_id: order_by
  external_id: order_by
  external_id_type: order_by
  id: order_by
  sku: skus_order_by
  sku_id: order_by
}

"Streaming cursor of the table \"external_sku_ids\""
input external_sku_ids_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: external_sku_ids_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input external_sku_ids_stream_cursor_value_input {
  brand_id: uuid
  external_id: String
  external_id_type: String
  id: uuid
  sku_id: uuid
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"Boolean expression to filter rows from the table \"form_submissions\". All fields are combined with a logical 'AND'."
input form_submissions_bool_exp {
  _and: [form_submissions_bool_exp!]
  _not: form_submissions_bool_exp
  _or: [form_submissions_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  form: forms_bool_exp
  form_id: uuid_comparison_exp
  id: uuid_comparison_exp
  submission_data: jsonb_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"form_submissions\""
input form_submissions_insert_input {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  submission_data: jsonb
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"form_submissions\""
input form_submissions_on_conflict {
  constraint: form_submissions_constraint!
  update_columns: [form_submissions_update_column!]! = []
  where: form_submissions_bool_exp
}

"Ordering options when selecting data from \"form_submissions\"."
input form_submissions_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  form: forms_order_by
  form_id: order_by
  id: order_by
  submission_data: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"form_submissions\""
input form_submissions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: form_submissions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input form_submissions_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  form_id: uuid
  id: uuid
  submission_data: jsonb
  user_id: String
}

"Boolean expression to filter rows from the table \"forms\". All fields are combined with a logical 'AND'."
input forms_bool_exp {
  _and: [forms_bool_exp!]
  _not: forms_bool_exp
  _or: [forms_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"forms\"."
input forms_order_by {
  brand: brands_order_by
  brand_id: order_by
  id: order_by
  schema: order_by
  type: order_by
}

"Streaming cursor of the table \"forms\""
input forms_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: forms_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input forms_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  schema: jsonb
  type: String
}

"Boolean expression to filter rows from the table \"fulfillment_intents\". All fields are combined with a logical 'AND'."
input fulfillment_intents_bool_exp {
  _and: [fulfillment_intents_bool_exp!]
  _not: fulfillment_intents_bool_exp
  _or: [fulfillment_intents_bool_exp!]
  fulfillment_service: fulfillment_services_bool_exp
  id: uuid_comparison_exp
}

"Ordering options when selecting data from \"fulfillment_intents\"."
input fulfillment_intents_order_by {
  fulfillment_service: fulfillment_services_order_by
  id: order_by
}

"Streaming cursor of the table \"fulfillment_intents\""
input fulfillment_intents_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillment_intents_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillment_intents_stream_cursor_value_input {
  id: uuid
}

"Boolean expression to filter rows from the table \"fulfillment_services\". All fields are combined with a logical 'AND'."
input fulfillment_services_bool_exp {
  _and: [fulfillment_services_bool_exp!]
  _not: fulfillment_services_bool_exp
  _or: [fulfillment_services_bool_exp!]
  id: uuid_comparison_exp
  type: fulfillment_types_v2_enum_comparison_exp
}

"Ordering options when selecting data from \"fulfillment_services\"."
input fulfillment_services_order_by {
  id: order_by
  type: order_by
}

"Streaming cursor of the table \"fulfillment_services\""
input fulfillment_services_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillment_services_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillment_services_stream_cursor_value_input {
  id: uuid
  type: fulfillment_types_v2_enum
}

"Boolean expression to compare columns of type \"fulfillment_types_enum\". All fields are combined with logical 'AND'."
input fulfillment_types_enum_comparison_exp {
  _eq: fulfillment_types_enum
  _in: [fulfillment_types_enum!]
  _is_null: Boolean
  _neq: fulfillment_types_enum
  _nin: [fulfillment_types_enum!]
}

"Boolean expression to compare columns of type \"fulfillment_types_v2_enum\". All fields are combined with logical 'AND'."
input fulfillment_types_v2_enum_comparison_exp {
  _eq: fulfillment_types_v2_enum
  _in: [fulfillment_types_v2_enum!]
  _is_null: Boolean
  _neq: fulfillment_types_v2_enum
  _nin: [fulfillment_types_v2_enum!]
}

"Boolean expression to filter rows from the table \"fulfillments\". All fields are combined with a logical 'AND'."
input fulfillments_bool_exp {
  _and: [fulfillments_bool_exp!]
  _not: fulfillments_bool_exp
  _or: [fulfillments_bool_exp!]
  brand: brands_bool_exp
  fulfillment_intent: fulfillment_intents_bool_exp
  fulfillment_service: fulfillment_services_bool_exp
  fulfillment_service_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  shipping_label: shipping_labels_bool_exp
  storefront: storefronts_bool_exp
}

"Ordering options when selecting data from \"fulfillments\"."
input fulfillments_order_by {
  brand: brands_order_by
  fulfillment_intent: fulfillment_intents_order_by
  fulfillment_service: fulfillment_services_order_by
  fulfillment_service_id: order_by
  id: order_by
  order_items_aggregate: order_items_aggregate_order_by
  shipping_label: shipping_labels_order_by
  storefront: storefronts_order_by
}

"Streaming cursor of the table \"fulfillments\""
input fulfillments_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fulfillments_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fulfillments_stream_cursor_value_input {
  fulfillment_service_id: uuid
  id: uuid
}

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"Boolean expression to compare columns of type \"geography\". All fields are combined with logical 'AND'."
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]
  "is the column within a given distance from the given geography value"
  _st_d_within: st_d_within_geography_input
  "does the column spatially intersect the given geography value"
  _st_intersects: geography
}

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"Boolean expression to compare columns of type \"geometry\". All fields are combined with logical 'AND'."
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]
  "is the column within a given 3D distance from the given geometry value"
  _st_3d_d_within: st_d_within_input
  "does the column spatially intersect the given geometry value in 3D"
  _st_3d_intersects: geometry
  "does the column contain the given geometry value"
  _st_contains: geometry
  "does the column cross the given geometry value"
  _st_crosses: geometry
  "is the column within a given distance from the given geometry value"
  _st_d_within: st_d_within_input
  "is the column equal to given geometry value (directionality is ignored)"
  _st_equals: geometry
  "does the column spatially intersect the given geometry value"
  _st_intersects: geometry
  "does the column 'spatially overlap' (intersect but not completely contain) the given geometry value"
  _st_overlaps: geometry
  "does the column have atleast one point in common with the given geometry value"
  _st_touches: geometry
  "is the column contained in the given geometry value"
  _st_within: geometry
}

"Boolean expression to compare columns of type \"gift_card_statuses_enum\". All fields are combined with logical 'AND'."
input gift_card_statuses_enum_comparison_exp {
  _eq: gift_card_statuses_enum
  _in: [gift_card_statuses_enum!]
  _is_null: Boolean
  _neq: gift_card_statuses_enum
  _nin: [gift_card_statuses_enum!]
}

input gift_cards_aggregate_bool_exp {
  count: gift_cards_aggregate_bool_exp_count
}

input gift_cards_aggregate_bool_exp_count {
  arguments: [gift_cards_select_column!]
  distinct: Boolean
  filter: gift_cards_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"gift_cards\""
input gift_cards_aggregate_order_by {
  count: order_by
  max: gift_cards_max_order_by
  min: gift_cards_min_order_by
}

"Boolean expression to filter rows from the table \"gift_cards\". All fields are combined with a logical 'AND'."
input gift_cards_bool_exp {
  _and: [gift_cards_bool_exp!]
  _not: gift_cards_bool_exp
  _or: [gift_cards_bool_exp!]
  external_id: String_comparison_exp
  id: uuid_comparison_exp
  status: gift_card_statuses_enum_comparison_exp
  transaction: transactions_bool_exp
  transaction_id: uuid_comparison_exp
}

"order by max() on columns of table \"gift_cards\""
input gift_cards_max_order_by {
  external_id: order_by
  id: order_by
  transaction_id: order_by
}

"order by min() on columns of table \"gift_cards\""
input gift_cards_min_order_by {
  external_id: order_by
  id: order_by
  transaction_id: order_by
}

"Ordering options when selecting data from \"gift_cards\"."
input gift_cards_order_by {
  external_id: order_by
  id: order_by
  status: order_by
  transaction: transactions_order_by
  transaction_id: order_by
}

"Streaming cursor of the table \"gift_cards\""
input gift_cards_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: gift_cards_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input gift_cards_stream_cursor_value_input {
  external_id: String
  id: uuid
  status: gift_card_statuses_enum
  transaction_id: uuid
}

"Boolean expression to filter rows from the table \"images\". All fields are combined with a logical 'AND'."
input images_bool_exp {
  _and: [images_bool_exp!]
  _not: images_bool_exp
  _or: [images_bool_exp!]
  alt: String_comparison_exp
  created_at: timestamptz_comparison_exp
  href: String_comparison_exp
  id: uuid_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"images\"."
input images_order_by {
  alt: order_by
  created_at: order_by
  href: order_by
  id: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"images\""
input images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  href: String
  id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"in_store_pickup_statuses_enum\". All fields are combined with logical 'AND'."
input in_store_pickup_statuses_enum_comparison_exp {
  _eq: in_store_pickup_statuses_enum
  _in: [in_store_pickup_statuses_enum!]
  _is_null: Boolean
  _neq: in_store_pickup_statuses_enum
  _nin: [in_store_pickup_statuses_enum!]
}

"order by aggregate values of table \"in_store_pickups\""
input in_store_pickups_aggregate_order_by {
  count: order_by
  max: in_store_pickups_max_order_by
  min: in_store_pickups_min_order_by
}

"Boolean expression to filter rows from the table \"in_store_pickups\". All fields are combined with a logical 'AND'."
input in_store_pickups_bool_exp {
  _and: [in_store_pickups_bool_exp!]
  _not: in_store_pickups_bool_exp
  _or: [in_store_pickups_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  identifier: String_comparison_exp
  shipping_information: shipping_information_bool_exp
  shipping_information_id: uuid_comparison_exp
  status: in_store_pickup_statuses_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"in_store_pickups\""
input in_store_pickups_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"in_store_pickups\""
input in_store_pickups_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"in_store_pickups\"."
input in_store_pickups_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  shipping_information: shipping_information_order_by
  shipping_information_id: order_by
  status: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"in_store_pickups\""
input in_store_pickups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: in_store_pickups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input in_store_pickups_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  identifier: String
  shipping_information_id: uuid
  status: in_store_pickup_statuses_enum
  updated_at: timestamptz
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"listing_auto_price_reduce\". All fields are combined with a logical 'AND'."
input listing_auto_price_reduce_bool_exp {
  _and: [listing_auto_price_reduce_bool_exp!]
  _not: listing_auto_price_reduce_bool_exp
  _or: [listing_auto_price_reduce_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  interval_days: Int_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  min_price: Int_comparison_exp
  percent: Int_comparison_exp
  price_updated_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_inc_input {
  interval_days: Int
  min_price: Int
  percent: Int
}

"input type for inserting data into table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_insert_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

"on_conflict condition type for table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_on_conflict {
  constraint: listing_auto_price_reduce_constraint!
  update_columns: [listing_auto_price_reduce_update_column!]! = []
  where: listing_auto_price_reduce_bool_exp
}

"Ordering options when selecting data from \"listing_auto_price_reduce\"."
input listing_auto_price_reduce_order_by {
  created_at: order_by
  id: order_by
  interval_days: order_by
  listing: listings_order_by
  listing_id: order_by
  min_price: order_by
  percent: order_by
  price_updated_at: order_by
  updated_at: order_by
  user_id: order_by
}

"primary key columns input for table: listing_auto_price_reduce"
input listing_auto_price_reduce_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_set_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

"Streaming cursor of the table \"listing_auto_price_reduce\""
input listing_auto_price_reduce_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_auto_price_reduce_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_auto_price_reduce_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  interval_days: Int
  listing_id: uuid
  min_price: Int
  percent: Int
  price_updated_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

input listing_auto_price_reduce_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: listing_auto_price_reduce_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: listing_auto_price_reduce_set_input
  "filter the rows which have to be updated"
  where: listing_auto_price_reduce_bool_exp!
}

"Boolean expression to filter rows from the table \"listing_channels\". All fields are combined with a logical 'AND'."
input listing_channels_bool_exp {
  _and: [listing_channels_bool_exp!]
  _not: listing_channels_bool_exp
  _or: [listing_channels_bool_exp!]
  brand_id: uuid_comparison_exp
  display: String_comparison_exp
  id: uuid_comparison_exp
  platform: listing_platforms_bool_exp
  platform_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"listing_channels\"."
input listing_channels_order_by {
  brand_id: order_by
  display: order_by
  id: order_by
  platform: listing_platforms_order_by
  platform_id: order_by
}

"Streaming cursor of the table \"listing_channels\""
input listing_channels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_channels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_channels_stream_cursor_value_input {
  brand_id: uuid
  display: String
  id: uuid
  platform_id: uuid
}

"Boolean expression to filter rows from the table \"listing_event_types\". All fields are combined with a logical 'AND'."
input listing_event_types_bool_exp {
  _and: [listing_event_types_bool_exp!]
  _not: listing_event_types_bool_exp
  _or: [listing_event_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"listing_event_types_enum\". All fields are combined with logical 'AND'."
input listing_event_types_enum_comparison_exp {
  _eq: listing_event_types_enum
  _in: [listing_event_types_enum!]
  _is_null: Boolean
  _neq: listing_event_types_enum
  _nin: [listing_event_types_enum!]
}

"Ordering options when selecting data from \"listing_event_types\"."
input listing_event_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"listing_event_types\""
input listing_event_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_event_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_event_types_stream_cursor_value_input {
  type: String
}

"order by aggregate values of table \"listing_events\""
input listing_events_aggregate_order_by {
  count: order_by
  max: listing_events_max_order_by
  min: listing_events_min_order_by
}

"Boolean expression to filter rows from the table \"listing_events\". All fields are combined with a logical 'AND'."
input listing_events_bool_exp {
  _and: [listing_events_bool_exp!]
  _not: listing_events_bool_exp
  _or: [listing_events_bool_exp!]
  event_type: listing_event_types_enum_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  listing_status: listing_statuses_enum_comparison_exp
  payload: jsonb_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_by_user: users_bool_exp
  value: String_comparison_exp
}

"order by max() on columns of table \"listing_events\""
input listing_events_max_order_by {
  id: order_by
  listing_id: order_by
  timestamp: order_by
  value: order_by
}

"order by min() on columns of table \"listing_events\""
input listing_events_min_order_by {
  id: order_by
  listing_id: order_by
  timestamp: order_by
  value: order_by
}

"Ordering options when selecting data from \"listing_events\"."
input listing_events_order_by {
  event_type: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  listing_status: order_by
  payload: order_by
  timestamp: order_by
  updated_by_user: users_order_by
  value: order_by
}

"Streaming cursor of the table \"listing_events\""
input listing_events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_events_stream_cursor_value_input {
  event_type: listing_event_types_enum
  id: uuid
  listing_id: uuid
  listing_status: listing_statuses_enum
  payload: jsonb
  timestamp: timestamptz
  value: String
}

"order by aggregate values of table \"listing_images\""
input listing_images_aggregate_order_by {
  avg: listing_images_avg_order_by
  count: order_by
  max: listing_images_max_order_by
  min: listing_images_min_order_by
  stddev: listing_images_stddev_order_by
  stddev_pop: listing_images_stddev_pop_order_by
  stddev_samp: listing_images_stddev_samp_order_by
  sum: listing_images_sum_order_by
  var_pop: listing_images_var_pop_order_by
  var_samp: listing_images_var_samp_order_by
  variance: listing_images_variance_order_by
}

"input type for inserting array relation for remote table \"listing_images\""
input listing_images_arr_rel_insert_input {
  data: [listing_images_insert_input!]!
  "upsert condition"
  on_conflict: listing_images_on_conflict
}

"order by avg() on columns of table \"listing_images\""
input listing_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"listing_images\". All fields are combined with a logical 'AND'."
input listing_images_bool_exp {
  _and: [listing_images_bool_exp!]
  _not: listing_images_bool_exp
  _or: [listing_images_bool_exp!]
  alt: String_comparison_exp
  condition_response: condition_responses_bool_exp
  condition_response_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  path: String_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"listing_images\""
input listing_images_insert_input {
  alt: String
  condition_response: condition_responses_obj_rel_insert_input
  condition_response_id: uuid
  created_at: timestamptz
  hidden: Boolean
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"listing_images\""
input listing_images_max_order_by {
  alt: order_by
  condition_response_id: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"listing_images\""
input listing_images_min_order_by {
  alt: order_by
  condition_response_id: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"listing_images\""
input listing_images_on_conflict {
  constraint: listing_images_constraint!
  update_columns: [listing_images_update_column!]! = []
  where: listing_images_bool_exp
}

"Ordering options when selecting data from \"listing_images\"."
input listing_images_order_by {
  alt: order_by
  condition_response: condition_responses_order_by
  condition_response_id: order_by
  created_at: order_by
  hidden: order_by
  id: order_by
  index: order_by
  listing: listings_order_by
  listing_id: order_by
  path: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"listing_images\""
input listing_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"listing_images\""
input listing_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"listing_images\""
input listing_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"listing_images\""
input listing_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_images_stream_cursor_value_input {
  alt: String
  condition_response_id: uuid
  created_at: timestamptz
  hidden: Boolean
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"listing_images\""
input listing_images_sum_order_by {
  index: order_by
}

"order by var_pop() on columns of table \"listing_images\""
input listing_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"listing_images\""
input listing_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"listing_images\""
input listing_images_variance_order_by {
  index: order_by
}

"order by aggregate values of table \"listing_metadata\""
input listing_metadata_aggregate_order_by {
  count: order_by
  max: listing_metadata_max_order_by
  min: listing_metadata_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input listing_metadata_append_input {
  value: jsonb
}

"Boolean expression to filter rows from the table \"listing_metadata\". All fields are combined with a logical 'AND'."
input listing_metadata_bool_exp {
  _and: [listing_metadata_bool_exp!]
  _not: listing_metadata_bool_exp
  _or: [listing_metadata_bool_exp!]
  id: uuid_comparison_exp
  key: String_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  value: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input listing_metadata_delete_at_path_input {
  value: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input listing_metadata_delete_elem_input {
  value: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input listing_metadata_delete_key_input {
  value: String
}

"input type for inserting data into table \"listing_metadata\""
input listing_metadata_insert_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

"order by max() on columns of table \"listing_metadata\""
input listing_metadata_max_order_by {
  id: order_by
  key: order_by
  listing_id: order_by
}

"order by min() on columns of table \"listing_metadata\""
input listing_metadata_min_order_by {
  id: order_by
  key: order_by
  listing_id: order_by
}

"on_conflict condition type for table \"listing_metadata\""
input listing_metadata_on_conflict {
  constraint: listing_metadata_constraint!
  update_columns: [listing_metadata_update_column!]! = []
  where: listing_metadata_bool_exp
}

"Ordering options when selecting data from \"listing_metadata\"."
input listing_metadata_order_by {
  id: order_by
  key: order_by
  listing: listings_order_by
  listing_id: order_by
  value: order_by
}

"primary key columns input for table: listing_metadata"
input listing_metadata_pk_columns_input {
  id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input listing_metadata_prepend_input {
  value: jsonb
}

"input type for updating data in table \"listing_metadata\""
input listing_metadata_set_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

"Streaming cursor of the table \"listing_metadata\""
input listing_metadata_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_metadata_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_metadata_stream_cursor_value_input {
  id: uuid
  key: String
  listing_id: uuid
  value: jsonb
}

input listing_metadata_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: listing_metadata_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: listing_metadata_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: listing_metadata_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: listing_metadata_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: listing_metadata_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: listing_metadata_set_input
  "filter the rows which have to be updated"
  where: listing_metadata_bool_exp!
}

"Boolean expression to compare columns of type \"listing_platform_types_enum\". All fields are combined with logical 'AND'."
input listing_platform_types_enum_comparison_exp {
  _eq: listing_platform_types_enum
  _in: [listing_platform_types_enum!]
  _is_null: Boolean
  _neq: listing_platform_types_enum
  _nin: [listing_platform_types_enum!]
}

"Boolean expression to filter rows from the table \"listing_platforms\". All fields are combined with a logical 'AND'."
input listing_platforms_bool_exp {
  _and: [listing_platforms_bool_exp!]
  _not: listing_platforms_bool_exp
  _or: [listing_platforms_bool_exp!]
  id: uuid_comparison_exp
  type: listing_platform_types_enum_comparison_exp
}

"Ordering options when selecting data from \"listing_platforms\"."
input listing_platforms_order_by {
  id: order_by
  type: order_by
}

"Streaming cursor of the table \"listing_platforms\""
input listing_platforms_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_platforms_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_platforms_stream_cursor_value_input {
  id: uuid
  type: listing_platform_types_enum
}

"Boolean expression to filter rows from the table \"listing_relistings\". All fields are combined with a logical 'AND'."
input listing_relistings_bool_exp {
  _and: [listing_relistings_bool_exp!]
  _not: listing_relistings_bool_exp
  _or: [listing_relistings_bool_exp!]
  new_listing_id: uuid_comparison_exp
  previous_listing_id: uuid_comparison_exp
}

"Ordering options when selecting data from \"listing_relistings\"."
input listing_relistings_order_by {
  new_listing_id: order_by
  previous_listing_id: order_by
}

"Streaming cursor of the table \"listing_relistings\""
input listing_relistings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_relistings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_relistings_stream_cursor_value_input {
  new_listing_id: uuid
  previous_listing_id: uuid
}

"Boolean expression to filter rows from the table \"listing_reviews\". All fields are combined with a logical 'AND'."
input listing_reviews_bool_exp {
  _and: [listing_reviews_bool_exp!]
  _not: listing_reviews_bool_exp
  _or: [listing_reviews_bool_exp!]
}

"input type for inserting data into table \"listing_reviews\""
input listing_reviews_insert_input {
  comments: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  outcome: listing_review_outcomes_enum
  updated_at: timestamptz
  user_id: String
}

"on_conflict condition type for table \"listing_reviews\""
input listing_reviews_on_conflict {
  constraint: listing_reviews_constraint!
  update_columns: [listing_reviews_update_column!]! = []
  where: listing_reviews_bool_exp
}

"Boolean expression to filter rows from the table \"listing_statuses\". All fields are combined with a logical 'AND'."
input listing_statuses_bool_exp {
  _and: [listing_statuses_bool_exp!]
  _not: listing_statuses_bool_exp
  _or: [listing_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"listing_statuses_enum\". All fields are combined with logical 'AND'."
input listing_statuses_enum_comparison_exp {
  _eq: listing_statuses_enum
  _in: [listing_statuses_enum!]
  _is_null: Boolean
  _neq: listing_statuses_enum
  _nin: [listing_statuses_enum!]
}

"Ordering options when selecting data from \"listing_statuses\"."
input listing_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"listing_statuses\""
input listing_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_statuses_stream_cursor_value_input {
  status: String
}

"Boolean expression to filter rows from the table \"listing_user_action_timestamp\". All fields are combined with a logical 'AND'."
input listing_user_action_timestamp_bool_exp {
  _and: [listing_user_action_timestamp_bool_exp!]
  _not: listing_user_action_timestamp_bool_exp
  _or: [listing_user_action_timestamp_bool_exp!]
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  user_action_timestamp: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"listing_user_action_timestamp\"."
input listing_user_action_timestamp_order_by {
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  user_action_timestamp: order_by
}

"Streaming cursor of the table \"listing_user_action_timestamp\""
input listing_user_action_timestamp_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listing_user_action_timestamp_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listing_user_action_timestamp_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  user_action_timestamp: timestamptz
}

"Boolean expression to compare columns of type \"listing_visibilities_enum\". All fields are combined with logical 'AND'."
input listing_visibilities_enum_comparison_exp {
  _eq: listing_visibilities_enum
  _in: [listing_visibilities_enum!]
  _is_null: Boolean
  _neq: listing_visibilities_enum
  _nin: [listing_visibilities_enum!]
}

input listings_aggregate_bool_exp {
  count: listings_aggregate_bool_exp_count
}

input listings_aggregate_bool_exp_count {
  arguments: [listings_select_column!]
  distinct: Boolean
  filter: listings_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"listings\""
input listings_aggregate_order_by {
  avg: listings_avg_order_by
  count: order_by
  max: listings_max_order_by
  min: listings_min_order_by
  stddev: listings_stddev_order_by
  stddev_pop: listings_stddev_pop_order_by
  stddev_samp: listings_stddev_samp_order_by
  sum: listings_sum_order_by
  var_pop: listings_var_pop_order_by
  var_samp: listings_var_samp_order_by
  variance: listings_variance_order_by
}

"order by avg() on columns of table \"listings\""
input listings_avg_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"Boolean expression to filter rows from the table \"listings\". All fields are combined with a logical 'AND'."
input listings_bool_exp {
  _and: [listings_bool_exp!]
  _not: listings_bool_exp
  _or: [listings_bool_exp!]
  auctions: auctions_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  bumped_at: timestamptz_comparison_exp
  channel: listing_channels_bool_exp
  channel_id: uuid_comparison_exp
  condition_responses: condition_responses_bool_exp
  condition_score: Int_comparison_exp
  confidence_score: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  events: listing_events_bool_exp
  id: uuid_comparison_exp
  images: listing_images_bool_exp
  listing_auto_price_reduce: listing_auto_price_reduce_bool_exp
  listing_metadata: listing_metadata_bool_exp
  listing_user_action_timestamp: listing_user_action_timestamp_bool_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  original_price: Int_comparison_exp
  price: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  relisted_listing: listing_relistings_bool_exp
  return_shipping_label: shipping_labels_bool_exp
  return_shipping_label_id: uuid_comparison_exp
  seller_comment: String_comparison_exp
  shipping_label: shipping_labels_bool_exp
  shipping_label_id: uuid_comparison_exp
  shipping_labels: shipping_labels_bool_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  status: listing_statuses_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  unassociated_listing_data: unassociated_listing_data_bool_exp
  unassociated_listing_data_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
  visibility: listing_visibilities_enum_comparison_exp
  wms_items: wms_items_bool_exp
}

"order by max() on columns of table \"listings\""
input listings_max_order_by {
  brand_id: order_by
  bumped_at: order_by
  channel_id: order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  id: order_by
  original_price: order_by
  price: order_by
  product_id: order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label_id: order_by
  sku_id: order_by
  storefront_id: order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"listings\""
input listings_min_order_by {
  brand_id: order_by
  bumped_at: order_by
  channel_id: order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  id: order_by
  original_price: order_by
  price: order_by
  product_id: order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label_id: order_by
  sku_id: order_by
  storefront_id: order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"listings\"."
input listings_order_by {
  auctions_aggregate: auctions_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  bumped_at: order_by
  channel: listing_channels_order_by
  channel_id: order_by
  condition_responses_aggregate: condition_responses_aggregate_order_by
  condition_score: order_by
  confidence_score: order_by
  created_at: order_by
  events_aggregate: listing_events_aggregate_order_by
  id: order_by
  images_aggregate: listing_images_aggregate_order_by
  listing_auto_price_reduce: listing_auto_price_reduce_order_by
  listing_metadata_aggregate: listing_metadata_aggregate_order_by
  listing_user_action_timestamp: listing_user_action_timestamp_order_by
  order_items_aggregate: order_items_aggregate_order_by
  original_price: order_by
  price: order_by
  product: products_order_by
  product_id: order_by
  relisted_listing: listing_relistings_order_by
  return_shipping_label: shipping_labels_order_by
  return_shipping_label_id: order_by
  seller_comment: order_by
  shipping_label: shipping_labels_order_by
  shipping_label_id: order_by
  shipping_labels_aggregate: shipping_labels_aggregate_order_by
  sku: skus_order_by
  sku_id: order_by
  status: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  unassociated_listing_data: unassociated_listing_data_order_by
  unassociated_listing_data_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  visibility: order_by
  wms_items_aggregate: wms_items_aggregate_order_by
}

"order by stddev() on columns of table \"listings\""
input listings_stddev_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by stddev_pop() on columns of table \"listings\""
input listings_stddev_pop_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by stddev_samp() on columns of table \"listings\""
input listings_stddev_samp_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"Streaming cursor of the table \"listings\""
input listings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: listings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input listings_stream_cursor_value_input {
  brand_id: uuid
  bumped_at: timestamptz
  channel_id: uuid
  condition_score: Int
  confidence_score: Int
  created_at: timestamptz
  id: uuid
  original_price: Int
  price: Int
  product_id: uuid
  return_shipping_label_id: uuid
  seller_comment: String
  shipping_label_id: uuid
  sku_id: uuid
  status: listing_statuses_enum
  storefront_id: uuid
  unassociated_listing_data_id: uuid
  updated_at: timestamptz
  user_id: String
  visibility: listing_visibilities_enum
}

"order by sum() on columns of table \"listings\""
input listings_sum_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by var_pop() on columns of table \"listings\""
input listings_var_pop_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by var_samp() on columns of table \"listings\""
input listings_var_samp_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by variance() on columns of table \"listings\""
input listings_variance_order_by {
  condition_score: order_by
  confidence_score: order_by
  original_price: order_by
  price: order_by
}

"order by aggregate values of table \"mail_takebacks\""
input mail_takebacks_aggregate_order_by {
  count: order_by
  max: mail_takebacks_max_order_by
  min: mail_takebacks_min_order_by
}

"Boolean expression to filter rows from the table \"mail_takebacks\". All fields are combined with a logical 'AND'."
input mail_takebacks_bool_exp {
  _and: [mail_takebacks_bool_exp!]
  _not: mail_takebacks_bool_exp
  _or: [mail_takebacks_bool_exp!]
  id: uuid_comparison_exp
  return_address: addresses_bool_exp
  return_shipping_address_id: uuid_comparison_exp
  shipping_label: shipping_labels_bool_exp
  shipping_label_id: uuid_comparison_exp
  takeback: takebacks_bool_exp
  takeback_id: uuid_comparison_exp
}

"order by max() on columns of table \"mail_takebacks\""
input mail_takebacks_max_order_by {
  id: order_by
  return_shipping_address_id: order_by
  shipping_label_id: order_by
  takeback_id: order_by
}

"order by min() on columns of table \"mail_takebacks\""
input mail_takebacks_min_order_by {
  id: order_by
  return_shipping_address_id: order_by
  shipping_label_id: order_by
  takeback_id: order_by
}

"Ordering options when selecting data from \"mail_takebacks\"."
input mail_takebacks_order_by {
  id: order_by
  return_address: addresses_order_by
  return_shipping_address_id: order_by
  shipping_label: shipping_labels_order_by
  shipping_label_id: order_by
  takeback: takebacks_order_by
  takeback_id: order_by
}

"Streaming cursor of the table \"mail_takebacks\""
input mail_takebacks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: mail_takebacks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input mail_takebacks_stream_cursor_value_input {
  id: uuid
  return_shipping_address_id: uuid
  shipping_label_id: uuid
  takeback_id: uuid
}

"order by aggregate values of table \"media_group_items\""
input media_group_items_aggregate_order_by {
  avg: media_group_items_avg_order_by
  count: order_by
  max: media_group_items_max_order_by
  min: media_group_items_min_order_by
  stddev: media_group_items_stddev_order_by
  stddev_pop: media_group_items_stddev_pop_order_by
  stddev_samp: media_group_items_stddev_samp_order_by
  sum: media_group_items_sum_order_by
  var_pop: media_group_items_var_pop_order_by
  var_samp: media_group_items_var_samp_order_by
  variance: media_group_items_variance_order_by
}

"order by avg() on columns of table \"media_group_items\""
input media_group_items_avg_order_by {
  position: order_by
}

"Boolean expression to filter rows from the table \"media_group_items\". All fields are combined with a logical 'AND'."
input media_group_items_bool_exp {
  _and: [media_group_items_bool_exp!]
  _not: media_group_items_bool_exp
  _or: [media_group_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image: images_bool_exp
  image_id: uuid_comparison_exp
  media_group_id: uuid_comparison_exp
  position: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"media_group_items\""
input media_group_items_max_order_by {
  created_at: order_by
  id: order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"order by min() on columns of table \"media_group_items\""
input media_group_items_min_order_by {
  created_at: order_by
  id: order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"media_group_items\"."
input media_group_items_order_by {
  created_at: order_by
  id: order_by
  image: images_order_by
  image_id: order_by
  media_group_id: order_by
  position: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"media_group_items\""
input media_group_items_stddev_order_by {
  position: order_by
}

"order by stddev_pop() on columns of table \"media_group_items\""
input media_group_items_stddev_pop_order_by {
  position: order_by
}

"order by stddev_samp() on columns of table \"media_group_items\""
input media_group_items_stddev_samp_order_by {
  position: order_by
}

"Streaming cursor of the table \"media_group_items\""
input media_group_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: media_group_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input media_group_items_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  image_id: uuid
  media_group_id: uuid
  position: Int
  updated_at: timestamptz
}

"order by sum() on columns of table \"media_group_items\""
input media_group_items_sum_order_by {
  position: order_by
}

"order by var_pop() on columns of table \"media_group_items\""
input media_group_items_var_pop_order_by {
  position: order_by
}

"order by var_samp() on columns of table \"media_group_items\""
input media_group_items_var_samp_order_by {
  position: order_by
}

"order by variance() on columns of table \"media_group_items\""
input media_group_items_variance_order_by {
  position: order_by
}

"Boolean expression to filter rows from the table \"media_groups\". All fields are combined with a logical 'AND'."
input media_groups_bool_exp {
  _and: [media_groups_bool_exp!]
  _not: media_groups_bool_exp
  _or: [media_groups_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: media_group_items_bool_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"media_groups\"."
input media_groups_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: media_group_items_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"media_groups\""
input media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input media_groups_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"mobile_uploads\". All fields are combined with a logical 'AND'."
input mobile_uploads_bool_exp {
  _and: [mobile_uploads_bool_exp!]
  _not: mobile_uploads_bool_exp
  _or: [mobile_uploads_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  session_id: String_comparison_exp
}

"input type for inserting data into table \"mobile_uploads\""
input mobile_uploads_insert_input {
  created_at: timestamptz
  id: uuid
  path: String
  session_id: String
}

"on_conflict condition type for table \"mobile_uploads\""
input mobile_uploads_on_conflict {
  constraint: mobile_uploads_constraint!
  update_columns: [mobile_uploads_update_column!]! = []
  where: mobile_uploads_bool_exp
}

"Ordering options when selecting data from \"mobile_uploads\"."
input mobile_uploads_order_by {
  created_at: order_by
  id: order_by
  path: order_by
  session_id: order_by
}

"Streaming cursor of the table \"mobile_uploads\""
input mobile_uploads_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: mobile_uploads_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input mobile_uploads_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  path: String
  session_id: String
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"order_addresses\". All fields are combined with a logical 'AND'."
input order_addresses_bool_exp {
  _and: [order_addresses_bool_exp!]
  _not: order_addresses_bool_exp
  _or: [order_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  country: String_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  organization: String_comparison_exp
  phone_number: String_comparison_exp
  postal_code: String_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_addresses\""
input order_addresses_insert_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
}

"input type for inserting object relation for remote table \"order_addresses\""
input order_addresses_obj_rel_insert_input {
  data: order_addresses_insert_input!
  "upsert condition"
  on_conflict: order_addresses_on_conflict
}

"on_conflict condition type for table \"order_addresses\""
input order_addresses_on_conflict {
  constraint: order_addresses_constraint!
  update_columns: [order_addresses_update_column!]! = []
  where: order_addresses_bool_exp
}

"Ordering options when selecting data from \"order_addresses\"."
input order_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  user_id: order_by
}

"Streaming cursor of the table \"order_addresses\""
input order_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  user_id: String
}

"order by aggregate values of table \"order_intent_items\""
input order_intent_items_aggregate_order_by {
  avg: order_intent_items_avg_order_by
  count: order_by
  max: order_intent_items_max_order_by
  min: order_intent_items_min_order_by
  stddev: order_intent_items_stddev_order_by
  stddev_pop: order_intent_items_stddev_pop_order_by
  stddev_samp: order_intent_items_stddev_samp_order_by
  sum: order_intent_items_sum_order_by
  var_pop: order_intent_items_var_pop_order_by
  var_samp: order_intent_items_var_samp_order_by
  variance: order_intent_items_variance_order_by
}

"input type for inserting array relation for remote table \"order_intent_items\""
input order_intent_items_arr_rel_insert_input {
  data: [order_intent_items_insert_input!]!
  "upsert condition"
  on_conflict: order_intent_items_on_conflict
}

"order by avg() on columns of table \"order_intent_items\""
input order_intent_items_avg_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_intent_items\". All fields are combined with a logical 'AND'."
input order_intent_items_bool_exp {
  _and: [order_intent_items_bool_exp!]
  _not: order_intent_items_bool_exp
  _or: [order_intent_items_bool_exp!]
  fulfillment_intent: fulfillment_intents_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  order_intent: order_intents_bool_exp
  order_intent_id: uuid_comparison_exp
  price: Int_comparison_exp
  shipping_information: shipping_information_bool_exp
  shipping_information_id: uuid_comparison_exp
  tax: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_intent_items\""
input order_intent_items_insert_input {
  id: uuid
  listing_id: uuid
  order_intent: order_intents_obj_rel_insert_input
  order_intent_id: uuid
  price: Int
  shipping_information: shipping_information_obj_rel_insert_input
  shipping_information_id: uuid
  tax: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"order_intent_items\""
input order_intent_items_max_order_by {
  id: order_by
  listing_id: order_by
  order_intent_id: order_by
  price: order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"order_intent_items\""
input order_intent_items_min_order_by {
  id: order_by
  listing_id: order_by
  order_intent_id: order_by
  price: order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"order_intent_items\""
input order_intent_items_on_conflict {
  constraint: order_intent_items_constraint!
  update_columns: [order_intent_items_update_column!]! = []
  where: order_intent_items_bool_exp
}

"Ordering options when selecting data from \"order_intent_items\"."
input order_intent_items_order_by {
  fulfillment_intent: fulfillment_intents_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  order_intent: order_intents_order_by
  order_intent_id: order_by
  price: order_by
  shipping_information: shipping_information_order_by
  shipping_information_id: order_by
  tax: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"order_intent_items\""
input order_intent_items_stddev_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_pop() on columns of table \"order_intent_items\""
input order_intent_items_stddev_pop_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_samp() on columns of table \"order_intent_items\""
input order_intent_items_stddev_samp_order_by {
  price: order_by
  tax: order_by
}

"Streaming cursor of the table \"order_intent_items\""
input order_intent_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_intent_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_intent_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  order_intent_id: uuid
  price: Int
  shipping_information_id: uuid
  tax: Int
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"order_intent_items\""
input order_intent_items_sum_order_by {
  price: order_by
  tax: order_by
}

"order by var_pop() on columns of table \"order_intent_items\""
input order_intent_items_var_pop_order_by {
  price: order_by
  tax: order_by
}

"order by var_samp() on columns of table \"order_intent_items\""
input order_intent_items_var_samp_order_by {
  price: order_by
  tax: order_by
}

"order by variance() on columns of table \"order_intent_items\""
input order_intent_items_variance_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to compare columns of type \"order_intent_statuses_enum\". All fields are combined with logical 'AND'."
input order_intent_statuses_enum_comparison_exp {
  _eq: order_intent_statuses_enum
  _in: [order_intent_statuses_enum!]
  _is_null: Boolean
  _neq: order_intent_statuses_enum
  _nin: [order_intent_statuses_enum!]
}

"Boolean expression to filter rows from the table \"order_intents\". All fields are combined with a logical 'AND'."
input order_intents_bool_exp {
  _and: [order_intents_bool_exp!]
  _not: order_intents_bool_exp
  _or: [order_intents_bool_exp!]
  attempted_discount_codes: attempted_discount_codes_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: order_intent_items_bool_exp
  order_number: String_comparison_exp
  preferred_language: String_comparison_exp
  shipping: Int_comparison_exp
  shipping_address: order_addresses_bool_exp
  shipping_address_id: uuid_comparison_exp
  shipping_tax: Int_comparison_exp
  status: order_intent_statuses_enum_comparison_exp
  stripe_payment_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_intents\""
input order_intents_insert_input {
  attempted_discount_codes: attempted_discount_codes_arr_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: order_intent_items_arr_rel_insert_input
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address: order_addresses_obj_rel_insert_input
  shipping_address_id: uuid
  status: order_intent_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"input type for inserting object relation for remote table \"order_intents\""
input order_intents_obj_rel_insert_input {
  data: order_intents_insert_input!
  "upsert condition"
  on_conflict: order_intents_on_conflict
}

"on_conflict condition type for table \"order_intents\""
input order_intents_on_conflict {
  constraint: order_intents_constraint!
  update_columns: [order_intents_update_column!]! = []
  where: order_intents_bool_exp
}

"Ordering options when selecting data from \"order_intents\"."
input order_intents_order_by {
  attempted_discount_codes_aggregate: attempted_discount_codes_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: order_intent_items_aggregate_order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address: order_addresses_order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  status: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"order_intents\""
input order_intents_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_intents_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_intents_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_intent_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

input order_items_aggregate_bool_exp {
  count: order_items_aggregate_bool_exp_count
}

input order_items_aggregate_bool_exp_count {
  arguments: [order_items_select_column!]
  distinct: Boolean
  filter: order_items_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"order_items\""
input order_items_aggregate_order_by {
  avg: order_items_avg_order_by
  count: order_by
  max: order_items_max_order_by
  min: order_items_min_order_by
  stddev: order_items_stddev_order_by
  stddev_pop: order_items_stddev_pop_order_by
  stddev_samp: order_items_stddev_samp_order_by
  sum: order_items_sum_order_by
  var_pop: order_items_var_pop_order_by
  var_samp: order_items_var_samp_order_by
  variance: order_items_variance_order_by
}

"input type for inserting array relation for remote table \"order_items\""
input order_items_arr_rel_insert_input {
  data: [order_items_insert_input!]!
  "upsert condition"
  on_conflict: order_items_on_conflict
}

"order by avg() on columns of table \"order_items\""
input order_items_avg_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_items\". All fields are combined with a logical 'AND'."
input order_items_bool_exp {
  _and: [order_items_bool_exp!]
  _not: order_items_bool_exp
  _or: [order_items_bool_exp!]
  fulfillment: fulfillments_bool_exp
  fulfillment_intent: fulfillment_intents_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
  price: Int_comparison_exp
  return_items: return_items_bool_exp
  shipping_information: shipping_information_bool_exp
  tax: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"order_items\""
input order_items_insert_input {
  id: uuid
  listing_id: uuid
  order: orders_obj_rel_insert_input
  order_id: uuid
  price: Int
  return_items: return_items_arr_rel_insert_input
  shipping_information: shipping_information_obj_rel_insert_input
  tax: Int
  user: users_obj_rel_insert_input
}

"order by max() on columns of table \"order_items\""
input order_items_max_order_by {
  id: order_by
  listing_id: order_by
  order_id: order_by
  price: order_by
  tax: order_by
  user_id: order_by
}

"order by min() on columns of table \"order_items\""
input order_items_min_order_by {
  id: order_by
  listing_id: order_by
  order_id: order_by
  price: order_by
  tax: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"order_items\""
input order_items_obj_rel_insert_input {
  data: order_items_insert_input!
  "upsert condition"
  on_conflict: order_items_on_conflict
}

"on_conflict condition type for table \"order_items\""
input order_items_on_conflict {
  constraint: order_items_constraint!
  update_columns: [order_items_update_column!]! = []
  where: order_items_bool_exp
}

"Ordering options when selecting data from \"order_items\"."
input order_items_order_by {
  fulfillment: fulfillments_order_by
  fulfillment_intent: fulfillment_intents_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  order: orders_order_by
  order_id: order_by
  price: order_by
  return_items_aggregate: return_items_aggregate_order_by
  shipping_information: shipping_information_order_by
  tax: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"order_items\""
input order_items_stddev_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_pop() on columns of table \"order_items\""
input order_items_stddev_pop_order_by {
  price: order_by
  tax: order_by
}

"order by stddev_samp() on columns of table \"order_items\""
input order_items_stddev_samp_order_by {
  price: order_by
  tax: order_by
}

"Streaming cursor of the table \"order_items\""
input order_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  order_id: uuid
  price: Int
  tax: Int
  user_id: String
}

"order by sum() on columns of table \"order_items\""
input order_items_sum_order_by {
  price: order_by
  tax: order_by
}

"order by var_pop() on columns of table \"order_items\""
input order_items_var_pop_order_by {
  price: order_by
  tax: order_by
}

"order by var_samp() on columns of table \"order_items\""
input order_items_var_samp_order_by {
  price: order_by
  tax: order_by
}

"order by variance() on columns of table \"order_items\""
input order_items_variance_order_by {
  price: order_by
  tax: order_by
}

"Boolean expression to filter rows from the table \"order_statuses\". All fields are combined with a logical 'AND'."
input order_statuses_bool_exp {
  _and: [order_statuses_bool_exp!]
  _not: order_statuses_bool_exp
  _or: [order_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"order_statuses_enum\". All fields are combined with logical 'AND'."
input order_statuses_enum_comparison_exp {
  _eq: order_statuses_enum
  _in: [order_statuses_enum!]
  _is_null: Boolean
  _neq: order_statuses_enum
  _nin: [order_statuses_enum!]
}

"Ordering options when selecting data from \"order_statuses\"."
input order_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"order_statuses\""
input order_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: order_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input order_statuses_stream_cursor_value_input {
  status: String
}

input orders_aggregate_bool_exp {
  count: orders_aggregate_bool_exp_count
}

input orders_aggregate_bool_exp_count {
  arguments: [orders_select_column!]
  distinct: Boolean
  filter: orders_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"orders\""
input orders_aggregate_order_by {
  avg: orders_avg_order_by
  count: order_by
  max: orders_max_order_by
  min: orders_min_order_by
  stddev: orders_stddev_order_by
  stddev_pop: orders_stddev_pop_order_by
  stddev_samp: orders_stddev_samp_order_by
  sum: orders_sum_order_by
  var_pop: orders_var_pop_order_by
  var_samp: orders_var_samp_order_by
  variance: orders_variance_order_by
}

"input type for inserting array relation for remote table \"orders\""
input orders_arr_rel_insert_input {
  data: [orders_insert_input!]!
  "upsert condition"
  on_conflict: orders_on_conflict
}

"order by avg() on columns of table \"orders\""
input orders_avg_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"Boolean expression to filter rows from the table \"orders\". All fields are combined with a logical 'AND'."
input orders_bool_exp {
  _and: [orders_bool_exp!]
  _not: orders_bool_exp
  _or: [orders_bool_exp!]
  applied_discount_codes: applied_discount_codes_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  items: order_items_bool_exp
  items_aggregate: order_items_aggregate_bool_exp
  order_number: String_comparison_exp
  preferred_language: String_comparison_exp
  shipping: Int_comparison_exp
  shipping_address: order_addresses_bool_exp
  shipping_address_id: uuid_comparison_exp
  shipping_tax: Int_comparison_exp
  status: order_statuses_enum_comparison_exp
  stripe_payment_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orders\""
input orders_insert_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: order_items_arr_rel_insert_input
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address: order_addresses_obj_rel_insert_input
  shipping_address_id: uuid
  status: order_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"orders\""
input orders_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"orders\""
input orders_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"orders\""
input orders_obj_rel_insert_input {
  data: orders_insert_input!
  "upsert condition"
  on_conflict: orders_on_conflict
}

"on_conflict condition type for table \"orders\""
input orders_on_conflict {
  constraint: orders_constraint!
  update_columns: [orders_update_column!]! = []
  where: orders_bool_exp
}

"Ordering options when selecting data from \"orders\"."
input orders_order_by {
  applied_discount_codes_aggregate: applied_discount_codes_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  items_aggregate: order_items_aggregate_order_by
  order_number: order_by
  preferred_language: order_by
  shipping: order_by
  shipping_address: order_addresses_order_by
  shipping_address_id: order_by
  shipping_tax: order_by
  status: order_by
  stripe_payment_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orders\""
input orders_stddev_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by stddev_pop() on columns of table \"orders\""
input orders_stddev_pop_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by stddev_samp() on columns of table \"orders\""
input orders_stddev_samp_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"Streaming cursor of the table \"orders\""
input orders_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orders_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orders_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  order_number: String
  preferred_language: String
  shipping: Int
  shipping_address_id: uuid
  shipping_tax: Int
  status: order_statuses_enum
  stripe_payment_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"orders\""
input orders_sum_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by var_pop() on columns of table \"orders\""
input orders_var_pop_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by var_samp() on columns of table \"orders\""
input orders_var_samp_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by variance() on columns of table \"orders\""
input orders_variance_order_by {
  shipping: order_by
  shipping_tax: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
}

"order by aggregate values of table \"orphan_condition_responses\""
input orphan_condition_responses_aggregate_order_by {
  avg: orphan_condition_responses_avg_order_by
  count: order_by
  max: orphan_condition_responses_max_order_by
  min: orphan_condition_responses_min_order_by
  stddev: orphan_condition_responses_stddev_order_by
  stddev_pop: orphan_condition_responses_stddev_pop_order_by
  stddev_samp: orphan_condition_responses_stddev_samp_order_by
  sum: orphan_condition_responses_sum_order_by
  var_pop: orphan_condition_responses_var_pop_order_by
  var_samp: orphan_condition_responses_var_samp_order_by
  variance: orphan_condition_responses_variance_order_by
}

"input type for inserting array relation for remote table \"orphan_condition_responses\""
input orphan_condition_responses_arr_rel_insert_input {
  data: [orphan_condition_responses_insert_input!]!
  "upsert condition"
  on_conflict: orphan_condition_responses_on_conflict
}

"order by avg() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_avg_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"orphan_condition_responses\". All fields are combined with a logical 'AND'."
input orphan_condition_responses_bool_exp {
  _and: [orphan_condition_responses_bool_exp!]
  _not: orphan_condition_responses_bool_exp
  _or: [orphan_condition_responses_bool_exp!]
  comment: String_comparison_exp
  condition_question: condition_questions_bool_exp
  condition_question_id: uuid_comparison_exp
  id: uuid_comparison_exp
  images: orphan_listings_images_bool_exp
  listing_id: uuid_comparison_exp
  orphan_listing: orphan_listings_bool_exp
  response: Boolean_comparison_exp
  score: Int_comparison_exp
  severity: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orphan_condition_responses\""
input orphan_condition_responses_insert_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  images: orphan_listings_images_arr_rel_insert_input
  listing_id: uuid
  orphan_listing: orphan_listings_obj_rel_insert_input
  response: Boolean
  score: Int
  severity: Int
  user: users_obj_rel_insert_input
  user_id: String
}

"order by max() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_max_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"order by min() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_min_order_by {
  comment: order_by
  condition_question_id: order_by
  id: order_by
  listing_id: order_by
  score: order_by
  severity: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"orphan_condition_responses\""
input orphan_condition_responses_obj_rel_insert_input {
  data: orphan_condition_responses_insert_input!
  "upsert condition"
  on_conflict: orphan_condition_responses_on_conflict
}

"on_conflict condition type for table \"orphan_condition_responses\""
input orphan_condition_responses_on_conflict {
  constraint: orphan_condition_responses_constraint!
  update_columns: [orphan_condition_responses_update_column!]! = []
  where: orphan_condition_responses_bool_exp
}

"Ordering options when selecting data from \"orphan_condition_responses\"."
input orphan_condition_responses_order_by {
  comment: order_by
  condition_question: condition_questions_order_by
  condition_question_id: order_by
  id: order_by
  images_aggregate: orphan_listings_images_aggregate_order_by
  listing_id: order_by
  orphan_listing: orphan_listings_order_by
  response: order_by
  score: order_by
  severity: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_pop() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_pop_order_by {
  score: order_by
  severity: order_by
}

"order by stddev_samp() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_stddev_samp_order_by {
  score: order_by
  severity: order_by
}

"Streaming cursor of the table \"orphan_condition_responses\""
input orphan_condition_responses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_condition_responses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_condition_responses_stream_cursor_value_input {
  comment: String
  condition_question_id: uuid
  id: uuid
  listing_id: uuid
  response: Boolean
  score: Int
  severity: Int
  user_id: String
}

"order by sum() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_sum_order_by {
  score: order_by
  severity: order_by
}

"order by var_pop() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_var_pop_order_by {
  score: order_by
  severity: order_by
}

"order by var_samp() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_var_samp_order_by {
  score: order_by
  severity: order_by
}

"order by variance() on columns of table \"orphan_condition_responses\""
input orphan_condition_responses_variance_order_by {
  score: order_by
  severity: order_by
}

"Boolean expression to filter rows from the table \"orphan_listings\". All fields are combined with a logical 'AND'."
input orphan_listings_bool_exp {
  _and: [orphan_listings_bool_exp!]
  _not: orphan_listings_bool_exp
  _or: [orphan_listings_bool_exp!]
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  condition_responses: orphan_condition_responses_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  images: orphan_listings_images_bool_exp
  product_link: String_comparison_exp
  size: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by aggregate values of table \"orphan_listings_images\""
input orphan_listings_images_aggregate_order_by {
  avg: orphan_listings_images_avg_order_by
  count: order_by
  max: orphan_listings_images_max_order_by
  min: orphan_listings_images_min_order_by
  stddev: orphan_listings_images_stddev_order_by
  stddev_pop: orphan_listings_images_stddev_pop_order_by
  stddev_samp: orphan_listings_images_stddev_samp_order_by
  sum: orphan_listings_images_sum_order_by
  var_pop: orphan_listings_images_var_pop_order_by
  var_samp: orphan_listings_images_var_samp_order_by
  variance: orphan_listings_images_variance_order_by
}

"input type for inserting array relation for remote table \"orphan_listings_images\""
input orphan_listings_images_arr_rel_insert_input {
  data: [orphan_listings_images_insert_input!]!
  "upsert condition"
  on_conflict: orphan_listings_images_on_conflict
}

"order by avg() on columns of table \"orphan_listings_images\""
input orphan_listings_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"orphan_listings_images\". All fields are combined with a logical 'AND'."
input orphan_listings_images_bool_exp {
  _and: [orphan_listings_images_bool_exp!]
  _not: orphan_listings_images_bool_exp
  _or: [orphan_listings_images_bool_exp!]
  alt: String_comparison_exp
  condition_response: orphan_condition_responses_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  listing_id: uuid_comparison_exp
  path: String_comparison_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"orphan_listings_images\""
input orphan_listings_images_insert_input {
  alt: String
  condition_response: orphan_condition_responses_obj_rel_insert_input
  created_at: timestamptz
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"orphan_listings_images\""
input orphan_listings_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"orphan_listings_images\""
input orphan_listings_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"orphan_listings_images\""
input orphan_listings_images_on_conflict {
  constraint: orphan_listings_images_constraint!
  update_columns: [orphan_listings_images_update_column!]! = []
  where: orphan_listings_images_bool_exp
}

"Ordering options when selecting data from \"orphan_listings_images\"."
input orphan_listings_images_order_by {
  alt: order_by
  condition_response: orphan_condition_responses_order_by
  created_at: order_by
  id: order_by
  index: order_by
  listing_id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by stddev() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"orphan_listings_images\""
input orphan_listings_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"orphan_listings_images\""
input orphan_listings_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_listings_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_listings_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  id: uuid
  index: Int
  listing_id: uuid
  path: String
  src: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"orphan_listings_images\""
input orphan_listings_images_sum_order_by {
  index: order_by
}

"order by var_pop() on columns of table \"orphan_listings_images\""
input orphan_listings_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"orphan_listings_images\""
input orphan_listings_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"orphan_listings_images\""
input orphan_listings_images_variance_order_by {
  index: order_by
}

"input type for inserting data into table \"orphan_listings\""
input orphan_listings_insert_input {
  brand_id: uuid
  color: String
  condition_responses: orphan_condition_responses_arr_rel_insert_input
  created_at: timestamptz
  description: String
  id: uuid
  images: orphan_listings_images_arr_rel_insert_input
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"input type for inserting object relation for remote table \"orphan_listings\""
input orphan_listings_obj_rel_insert_input {
  data: orphan_listings_insert_input!
  "upsert condition"
  on_conflict: orphan_listings_on_conflict
}

"on_conflict condition type for table \"orphan_listings\""
input orphan_listings_on_conflict {
  constraint: orphan_listings_constraint!
  update_columns: [orphan_listings_update_column!]! = []
  where: orphan_listings_bool_exp
}

"Ordering options when selecting data from \"orphan_listings\"."
input orphan_listings_order_by {
  brand_id: order_by
  color: order_by
  condition_responses_aggregate: orphan_condition_responses_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  images_aggregate: orphan_listings_images_aggregate_order_by
  product_link: order_by
  size: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"orphan_listings\""
input orphan_listings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: orphan_listings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input orphan_listings_stream_cursor_value_input {
  brand_id: uuid
  color: String
  created_at: timestamptz
  description: String
  id: uuid
  product_link: String
  size: String
  title: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"photo_enhancement_request_statuses_enum\". All fields are combined with logical 'AND'."
input photo_enhancement_request_statuses_enum_comparison_exp {
  _eq: photo_enhancement_request_statuses_enum
  _in: [photo_enhancement_request_statuses_enum!]
  _is_null: Boolean
  _neq: photo_enhancement_request_statuses_enum
  _nin: [photo_enhancement_request_statuses_enum!]
}

"order by aggregate values of table \"photo_enhancement_requests\""
input photo_enhancement_requests_aggregate_order_by {
  count: order_by
  max: photo_enhancement_requests_max_order_by
  min: photo_enhancement_requests_min_order_by
}

"Boolean expression to filter rows from the table \"photo_enhancement_requests\". All fields are combined with a logical 'AND'."
input photo_enhancement_requests_bool_exp {
  _and: [photo_enhancement_requests_bool_exp!]
  _not: photo_enhancement_requests_bool_exp
  _or: [photo_enhancement_requests_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  external_id: String_comparison_exp
  id: uuid_comparison_exp
  image_id: uuid_comparison_exp
  listing_image_id: uuid_comparison_exp
  original_src: String_comparison_exp
  product_image_id: uuid_comparison_exp
  sku_image_id: uuid_comparison_exp
  src: String_comparison_exp
  status: photo_enhancement_request_statuses_enum_comparison_exp
  type: photo_enhancement_types_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"photo_enhancement_requests\""
input photo_enhancement_requests_max_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"photo_enhancement_requests\""
input photo_enhancement_requests_min_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"photo_enhancement_requests\"."
input photo_enhancement_requests_order_by {
  brand_id: order_by
  created_at: order_by
  external_id: order_by
  id: order_by
  image_id: order_by
  listing_image_id: order_by
  original_src: order_by
  product_image_id: order_by
  sku_image_id: order_by
  src: order_by
  status: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"photo_enhancement_requests\""
input photo_enhancement_requests_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: photo_enhancement_requests_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input photo_enhancement_requests_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  external_id: String
  id: uuid
  image_id: uuid
  listing_image_id: uuid
  original_src: String
  product_image_id: uuid
  sku_image_id: uuid
  src: String
  status: photo_enhancement_request_statuses_enum
  type: photo_enhancement_types_enum
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"photo_enhancement_types_enum\". All fields are combined with logical 'AND'."
input photo_enhancement_types_enum_comparison_exp {
  _eq: photo_enhancement_types_enum
  _in: [photo_enhancement_types_enum!]
  _is_null: Boolean
  _neq: photo_enhancement_types_enum
  _nin: [photo_enhancement_types_enum!]
}

"Boolean expression to filter rows from the table \"pos_events\". All fields are combined with a logical 'AND'."
input pos_events_bool_exp {
  _and: [pos_events_bool_exp!]
  _not: pos_events_bool_exp
  _or: [pos_events_bool_exp!]
}

"input type for inserting data into table \"pos_events\""
input pos_events_insert_input {
  event_type: String
  id: uuid
  metadata: jsonb
  order_id: uuid
  pos_station_id: uuid
  timestamp: timestamptz
  user_id: String
}

"on_conflict condition type for table \"pos_events\""
input pos_events_on_conflict {
  constraint: pos_events_constraint!
  update_columns: [pos_events_update_column!]! = []
  where: pos_events_bool_exp
}

"order by aggregate values of table \"pos_stations\""
input pos_stations_aggregate_order_by {
  count: order_by
  max: pos_stations_max_order_by
  min: pos_stations_min_order_by
}

"Boolean expression to filter rows from the table \"pos_stations\". All fields are combined with a logical 'AND'."
input pos_stations_bool_exp {
  _and: [pos_stations_bool_exp!]
  _not: pos_stations_bool_exp
  _or: [pos_stations_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"pos_stations\""
input pos_stations_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"pos_stations\""
input pos_stations_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"pos_stations\"."
input pos_stations_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"pos_stations\""
input pos_stations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: pos_stations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input pos_stations_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  retail_store_id: uuid
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"postal_options\". All fields are combined with a logical 'AND'."
input postal_options_bool_exp {
  _and: [postal_options_bool_exp!]
  _not: postal_options_bool_exp
  _or: [postal_options_bool_exp!]
  carrier: shipping_carriers_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  method: shipping_methods_enum_comparison_exp
  service: shipping_services_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"postal_options\"."
input postal_options_order_by {
  carrier: order_by
  created_at: order_by
  id: order_by
  method: order_by
  service: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"postal_options\""
input postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input postal_options_stream_cursor_value_input {
  carrier: shipping_carriers_enum
  created_at: timestamptz
  id: uuid
  method: shipping_methods_enum
  service: shipping_services_enum
  updated_at: timestamptz
}

"order by aggregate values of table \"product_attribute_type_options\""
input product_attribute_type_options_aggregate_order_by {
  count: order_by
  max: product_attribute_type_options_max_order_by
  min: product_attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_attribute_type_options\". All fields are combined with a logical 'AND'."
input product_attribute_type_options_bool_exp {
  _and: [product_attribute_type_options_bool_exp!]
  _not: product_attribute_type_options_bool_exp
  _or: [product_attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  attribute_type_option: attribute_type_options_bool_exp
  attribute_type_option_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_attribute_type_options\""
input product_attribute_type_options_max_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_attribute_type_options\""
input product_attribute_type_options_min_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_attribute_type_options\"."
input product_attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  attribute_type_option: attribute_type_options_order_by
  attribute_type_option_id: order_by
  created_at: order_by
  id: order_by
  product: products_order_by
  product_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"product_attribute_type_options\""
input product_attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  attribute_type_option_id: uuid
  created_at: timestamptz
  id: uuid
  product_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"product_colors\""
input product_colors_aggregate_order_by {
  count: order_by
  max: product_colors_max_order_by
  min: product_colors_min_order_by
}

"Boolean expression to filter rows from the table \"product_colors\". All fields are combined with a logical 'AND'."
input product_colors_bool_exp {
  _and: [product_colors_bool_exp!]
  _not: product_colors_bool_exp
  _or: [product_colors_bool_exp!]
  color: String_comparison_exp
  content: product_colors_translations_bool_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_colors_translations: product_colors_translations_bool_exp
  product_colors_translations_aggregate: product_colors_translations_aggregate_bool_exp
  product_id: uuid_comparison_exp
  uid: String_comparison_exp
}

"order by max() on columns of table \"product_colors\""
input product_colors_max_order_by {
  color: order_by
  id: order_by
  product_id: order_by
  uid: order_by
}

"order by min() on columns of table \"product_colors\""
input product_colors_min_order_by {
  color: order_by
  id: order_by
  product_id: order_by
  uid: order_by
}

"Ordering options when selecting data from \"product_colors\"."
input product_colors_order_by {
  color: order_by
  content_aggregate: product_colors_translations_aggregate_order_by
  id: order_by
  product: products_order_by
  product_colors_translations_aggregate: product_colors_translations_aggregate_order_by
  product_id: order_by
  uid: order_by
}

"Streaming cursor of the table \"product_colors\""
input product_colors_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_colors_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_colors_stream_cursor_value_input {
  color: String
  id: uuid
  product_id: uuid
  uid: String
}

input product_colors_translations_aggregate_bool_exp {
  count: product_colors_translations_aggregate_bool_exp_count
}

input product_colors_translations_aggregate_bool_exp_count {
  arguments: [product_colors_translations_select_column!]
  distinct: Boolean
  filter: product_colors_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_colors_translations\""
input product_colors_translations_aggregate_order_by {
  avg: product_colors_translations_avg_order_by
  count: order_by
  max: product_colors_translations_max_order_by
  min: product_colors_translations_min_order_by
  stddev: product_colors_translations_stddev_order_by
  stddev_pop: product_colors_translations_stddev_pop_order_by
  stddev_samp: product_colors_translations_stddev_samp_order_by
  sum: product_colors_translations_sum_order_by
  var_pop: product_colors_translations_var_pop_order_by
  var_samp: product_colors_translations_var_samp_order_by
  variance: product_colors_translations_variance_order_by
}

"order by avg() on columns of table \"product_colors_translations\""
input product_colors_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_colors_translations\". All fields are combined with a logical 'AND'."
input product_colors_translations_bool_exp {
  _and: [product_colors_translations_bool_exp!]
  _not: product_colors_translations_bool_exp
  _or: [product_colors_translations_bool_exp!]
  color: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  product_color_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_colors_translations\""
input product_colors_translations_max_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"order by min() on columns of table \"product_colors_translations\""
input product_colors_translations_min_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"Ordering options when selecting data from \"product_colors_translations\"."
input product_colors_translations_order_by {
  color: order_by
  id: order_by
  lang: order_by
  product_color_id: order_by
}

"order by stddev() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_colors_translations\""
input product_colors_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_colors_translations\""
input product_colors_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_colors_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_colors_translations_stream_cursor_value_input {
  color: String
  id: Int
  lang: String
  product_color_id: uuid
}

"order by sum() on columns of table \"product_colors_translations\""
input product_colors_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_colors_translations\""
input product_colors_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_colors_translations\""
input product_colors_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_colors_translations\""
input product_colors_translations_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"product_images\""
input product_images_aggregate_order_by {
  avg: product_images_avg_order_by
  count: order_by
  max: product_images_max_order_by
  min: product_images_min_order_by
  stddev: product_images_stddev_order_by
  stddev_pop: product_images_stddev_pop_order_by
  stddev_samp: product_images_stddev_samp_order_by
  sum: product_images_sum_order_by
  var_pop: product_images_var_pop_order_by
  var_samp: product_images_var_samp_order_by
  variance: product_images_variance_order_by
}

"order by avg() on columns of table \"product_images\""
input product_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"product_images\". All fields are combined with a logical 'AND'."
input product_images_bool_exp {
  _and: [product_images_bool_exp!]
  _not: product_images_bool_exp
  _or: [product_images_bool_exp!]
  alt: String_comparison_exp
  content: product_images_translations_bool_exp
  created_at: timestamptz_comparison_exp
  detail: Boolean_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  primary: Boolean_comparison_exp
  primary_hover: Boolean_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_images_translations: product_images_translations_bool_exp
  product_images_translations_aggregate: product_images_translations_aggregate_bool_exp
  src: String_comparison_exp
  swatch: Boolean_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_images\""
input product_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  product_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_images\""
input product_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  product_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_images\"."
input product_images_order_by {
  alt: order_by
  content_aggregate: product_images_translations_aggregate_order_by
  created_at: order_by
  detail: order_by
  id: order_by
  index: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  primary: order_by
  primary_hover: order_by
  product: products_order_by
  product_id: order_by
  product_images_translations_aggregate: product_images_translations_aggregate_order_by
  src: order_by
  swatch: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"product_images\""
input product_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"product_images\""
input product_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"product_images\""
input product_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"product_images\""
input product_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  detail: Boolean
  id: uuid
  index: Int
  primary: Boolean
  primary_hover: Boolean
  product_id: uuid
  src: String
  swatch: Boolean
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"product_images\""
input product_images_sum_order_by {
  index: order_by
}

input product_images_translations_aggregate_bool_exp {
  count: product_images_translations_aggregate_bool_exp_count
}

input product_images_translations_aggregate_bool_exp_count {
  arguments: [product_images_translations_select_column!]
  distinct: Boolean
  filter: product_images_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_images_translations\""
input product_images_translations_aggregate_order_by {
  avg: product_images_translations_avg_order_by
  count: order_by
  max: product_images_translations_max_order_by
  min: product_images_translations_min_order_by
  stddev: product_images_translations_stddev_order_by
  stddev_pop: product_images_translations_stddev_pop_order_by
  stddev_samp: product_images_translations_stddev_samp_order_by
  sum: product_images_translations_sum_order_by
  var_pop: product_images_translations_var_pop_order_by
  var_samp: product_images_translations_var_samp_order_by
  variance: product_images_translations_variance_order_by
}

"order by avg() on columns of table \"product_images_translations\""
input product_images_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_images_translations\". All fields are combined with a logical 'AND'."
input product_images_translations_bool_exp {
  _and: [product_images_translations_bool_exp!]
  _not: product_images_translations_bool_exp
  _or: [product_images_translations_bool_exp!]
  alt: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  product_image_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_images_translations\""
input product_images_translations_max_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"order by min() on columns of table \"product_images_translations\""
input product_images_translations_min_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"Ordering options when selecting data from \"product_images_translations\"."
input product_images_translations_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  product_image_id: order_by
}

"order by stddev() on columns of table \"product_images_translations\""
input product_images_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_images_translations\""
input product_images_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_images_translations\""
input product_images_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_images_translations\""
input product_images_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_images_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_images_translations_stream_cursor_value_input {
  alt: String
  id: Int
  lang: String
  product_image_id: uuid
}

"order by sum() on columns of table \"product_images_translations\""
input product_images_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_images_translations\""
input product_images_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_images_translations\""
input product_images_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_images_translations\""
input product_images_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_images\""
input product_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"product_images\""
input product_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"product_images\""
input product_images_variance_order_by {
  index: order_by
}

"order by aggregate values of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_aggregate_order_by {
  count: order_by
  max: product_style_attribute_type_options_max_order_by
  min: product_style_attribute_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_attribute_type_options\". All fields are combined with a logical 'AND'."
input product_style_attribute_type_options_bool_exp {
  _and: [product_style_attribute_type_options_bool_exp!]
  _not: product_style_attribute_type_options_bool_exp
  _or: [product_style_attribute_type_options_bool_exp!]
  attribute_type: attribute_types_bool_exp
  attribute_type_id: uuid_comparison_exp
  attribute_type_option: attribute_type_options_bool_exp
  attribute_type_option_id: uuid_comparison_exp
  id: uuid_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_max_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style_id: order_by
}

"order by min() on columns of table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_min_order_by {
  attribute_type_id: order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style_id: order_by
}

"Ordering options when selecting data from \"product_style_attribute_type_options\"."
input product_style_attribute_type_options_order_by {
  attribute_type: attribute_types_order_by
  attribute_type_id: order_by
  attribute_type_option: attribute_type_options_order_by
  attribute_type_option_id: order_by
  id: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
}

"Streaming cursor of the table \"product_style_attribute_type_options\""
input product_style_attribute_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_attribute_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_attribute_type_options_stream_cursor_value_input {
  attribute_type_id: uuid
  attribute_type_option_id: uuid
  id: uuid
  product_style_id: uuid
}

"Boolean expression to compare columns of type \"product_style_sources_enum\". All fields are combined with logical 'AND'."
input product_style_sources_enum_comparison_exp {
  _eq: product_style_sources_enum
  _in: [product_style_sources_enum!]
  _is_null: Boolean
  _neq: product_style_sources_enum
  _nin: [product_style_sources_enum!]
}

"order by aggregate values of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_aggregate_order_by {
  count: order_by
  max: product_style_variant_media_groups_max_order_by
  min: product_style_variant_media_groups_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_variant_media_groups\". All fields are combined with a logical 'AND'."
input product_style_variant_media_groups_bool_exp {
  _and: [product_style_variant_media_groups_bool_exp!]
  _not: product_style_variant_media_groups_bool_exp
  _or: [product_style_variant_media_groups_bool_exp!]
  created_at: timestamptz_comparison_exp
  media_group: media_groups_bool_exp
  media_group_id: uuid_comparison_exp
  product_style_variant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_max_order_by {
  created_at: order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_min_order_by {
  created_at: order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_style_variant_media_groups\"."
input product_style_variant_media_groups_order_by {
  created_at: order_by
  media_group: media_groups_order_by
  media_group_id: order_by
  product_style_variant_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"product_style_variant_media_groups\""
input product_style_variant_media_groups_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variant_media_groups_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variant_media_groups_stream_cursor_value_input {
  created_at: timestamptz
  media_group_id: uuid
  product_style_variant_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"product_style_variant_options\""
input product_style_variant_options_aggregate_order_by {
  count: order_by
  max: product_style_variant_options_max_order_by
  min: product_style_variant_options_min_order_by
}

"Boolean expression to filter rows from the table \"product_style_variant_options\". All fields are combined with a logical 'AND'."
input product_style_variant_options_bool_exp {
  _and: [product_style_variant_options_bool_exp!]
  _not: product_style_variant_options_bool_exp
  _or: [product_style_variant_options_bool_exp!]
  product_style_variant_id: uuid_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_option: variant_type_options_bool_exp
  variant_type_option_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_style_variant_options\""
input product_style_variant_options_max_order_by {
  product_style_variant_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"product_style_variant_options\""
input product_style_variant_options_min_order_by {
  product_style_variant_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"product_style_variant_options\"."
input product_style_variant_options_order_by {
  product_style_variant_id: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_option: variant_type_options_order_by
  variant_type_option_id: order_by
}

"Streaming cursor of the table \"product_style_variant_options\""
input product_style_variant_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variant_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variant_options_stream_cursor_value_input {
  product_style_variant_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"order by aggregate values of table \"product_style_variants\""
input product_style_variants_aggregate_order_by {
  avg: product_style_variants_avg_order_by
  count: order_by
  max: product_style_variants_max_order_by
  min: product_style_variants_min_order_by
  stddev: product_style_variants_stddev_order_by
  stddev_pop: product_style_variants_stddev_pop_order_by
  stddev_samp: product_style_variants_stddev_samp_order_by
  sum: product_style_variants_sum_order_by
  var_pop: product_style_variants_var_pop_order_by
  var_samp: product_style_variants_var_samp_order_by
  variance: product_style_variants_variance_order_by
}

"order by avg() on columns of table \"product_style_variants\""
input product_style_variants_avg_order_by {
  price: order_by
}

"Boolean expression to filter rows from the table \"product_style_variants\". All fields are combined with a logical 'AND'."
input product_style_variants_bool_exp {
  _and: [product_style_variants_bool_exp!]
  _not: product_style_variants_bool_exp
  _or: [product_style_variants_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  media_groups: product_style_variant_media_groups_bool_exp
  price: Int_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  product_style_variant: String_comparison_exp
  product_style_variant_options: product_style_variant_options_bool_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"product_style_variants\""
input product_style_variants_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
  product_style_id: order_by
  product_style_variant: order_by
  updated_at: order_by
}

"order by min() on columns of table \"product_style_variants\""
input product_style_variants_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
  product_style_id: order_by
  product_style_variant: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"product_style_variants\"."
input product_style_variants_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  id: order_by
  media_groups_aggregate: product_style_variant_media_groups_aggregate_order_by
  price: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  product_style_variant: order_by
  product_style_variant_options_aggregate: product_style_variant_options_aggregate_order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"product_style_variants\""
input product_style_variants_stddev_order_by {
  price: order_by
}

"order by stddev_pop() on columns of table \"product_style_variants\""
input product_style_variants_stddev_pop_order_by {
  price: order_by
}

"order by stddev_samp() on columns of table \"product_style_variants\""
input product_style_variants_stddev_samp_order_by {
  price: order_by
}

"Streaming cursor of the table \"product_style_variants\""
input product_style_variants_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_style_variants_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_style_variants_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  price: Int
  product_style_id: uuid
  product_style_variant: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"product_style_variants\""
input product_style_variants_sum_order_by {
  price: order_by
}

"order by var_pop() on columns of table \"product_style_variants\""
input product_style_variants_var_pop_order_by {
  price: order_by
}

"order by var_samp() on columns of table \"product_style_variants\""
input product_style_variants_var_samp_order_by {
  price: order_by
}

"order by variance() on columns of table \"product_style_variants\""
input product_style_variants_variance_order_by {
  price: order_by
}

"Boolean expression to filter rows from the table \"product_styles\". All fields are combined with a logical 'AND'."
input product_styles_bool_exp {
  _and: [product_styles_bool_exp!]
  _not: product_styles_bool_exp
  _or: [product_styles_bool_exp!]
  attribute_type_options: product_style_attribute_type_options_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  content: product_styles_translations_bool_exp
  disallow_listing: Boolean_comparison_exp
  id: uuid_comparison_exp
  price: Int_comparison_exp
  product_style: String_comparison_exp
  product_style_variants: product_style_variants_bool_exp
  product_styles_translations: product_styles_translations_bool_exp
  product_styles_translations_aggregate: product_styles_translations_aggregate_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  skus: skus_bool_exp
  source: product_style_sources_enum_comparison_exp
}

"Boolean expression to filter rows from the table \"product_styles_listed\". All fields are combined with a logical 'AND'."
input product_styles_listed_bool_exp {
  _and: [product_styles_listed_bool_exp!]
  _not: product_styles_listed_bool_exp
  _or: [product_styles_listed_bool_exp!]
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  sizes: String_comparison_exp
}

"Ordering options when selecting data from \"product_styles_listed\"."
input product_styles_listed_order_by {
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  sizes: order_by
}

"Streaming cursor of the table \"product_styles_listed\""
input product_styles_listed_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_listed_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_listed_stream_cursor_value_input {
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  product_style_id: uuid
  sizes: String
}

"Ordering options when selecting data from \"product_styles\"."
input product_styles_order_by {
  attribute_type_options_aggregate: product_style_attribute_type_options_aggregate_order_by
  brand: brands_order_by
  brand_id: order_by
  category: brand_categories_order_by
  category_id: order_by
  content_aggregate: product_styles_translations_aggregate_order_by
  disallow_listing: order_by
  id: order_by
  price: order_by
  product_style: order_by
  product_style_variants_aggregate: product_style_variants_aggregate_order_by
  product_styles_translations_aggregate: product_styles_translations_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  skus_aggregate: skus_aggregate_order_by
  source: order_by
}

"Streaming cursor of the table \"product_styles\""
input product_styles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  disallow_listing: Boolean
  id: uuid
  price: Int
  product_style: String
  source: product_style_sources_enum
}

input product_styles_translations_aggregate_bool_exp {
  count: product_styles_translations_aggregate_bool_exp_count
}

input product_styles_translations_aggregate_bool_exp_count {
  arguments: [product_styles_translations_select_column!]
  distinct: Boolean
  filter: product_styles_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_styles_translations\""
input product_styles_translations_aggregate_order_by {
  avg: product_styles_translations_avg_order_by
  count: order_by
  max: product_styles_translations_max_order_by
  min: product_styles_translations_min_order_by
  stddev: product_styles_translations_stddev_order_by
  stddev_pop: product_styles_translations_stddev_pop_order_by
  stddev_samp: product_styles_translations_stddev_samp_order_by
  sum: product_styles_translations_sum_order_by
  var_pop: product_styles_translations_var_pop_order_by
  var_samp: product_styles_translations_var_samp_order_by
  variance: product_styles_translations_variance_order_by
}

"order by avg() on columns of table \"product_styles_translations\""
input product_styles_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"product_styles_translations\". All fields are combined with a logical 'AND'."
input product_styles_translations_bool_exp {
  _and: [product_styles_translations_bool_exp!]
  _not: product_styles_translations_bool_exp
  _or: [product_styles_translations_bool_exp!]
  description: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  product_style_id: uuid_comparison_exp
}

"order by max() on columns of table \"product_styles_translations\""
input product_styles_translations_max_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"order by min() on columns of table \"product_styles_translations\""
input product_styles_translations_min_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"Ordering options when selecting data from \"product_styles_translations\"."
input product_styles_translations_order_by {
  description: order_by
  id: order_by
  lang: order_by
  name: order_by
  product_style_id: order_by
}

"order by stddev() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"product_styles_translations\""
input product_styles_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"product_styles_translations\""
input product_styles_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_styles_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_styles_translations_stream_cursor_value_input {
  description: String
  id: Int
  lang: String
  name: String
  product_style_id: uuid
}

"order by sum() on columns of table \"product_styles_translations\""
input product_styles_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"product_styles_translations\""
input product_styles_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"product_styles_translations\""
input product_styles_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"product_styles_translations\""
input product_styles_translations_variance_order_by {
  id: order_by
}

input product_tags_aggregate_bool_exp {
  count: product_tags_aggregate_bool_exp_count
}

input product_tags_aggregate_bool_exp_count {
  arguments: [product_tags_select_column!]
  distinct: Boolean
  filter: product_tags_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"product_tags\""
input product_tags_aggregate_order_by {
  count: order_by
  max: product_tags_max_order_by
  min: product_tags_min_order_by
}

"Boolean expression to filter rows from the table \"product_tags\". All fields are combined with a logical 'AND'."
input product_tags_bool_exp {
  _and: [product_tags_bool_exp!]
  _not: product_tags_bool_exp
  _or: [product_tags_bool_exp!]
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  value: String_comparison_exp
}

"order by max() on columns of table \"product_tags\""
input product_tags_max_order_by {
  id: order_by
  product_id: order_by
  value: order_by
}

"order by min() on columns of table \"product_tags\""
input product_tags_min_order_by {
  id: order_by
  product_id: order_by
  value: order_by
}

"Ordering options when selecting data from \"product_tags\"."
input product_tags_order_by {
  id: order_by
  product: products_order_by
  product_id: order_by
  value: order_by
}

"Streaming cursor of the table \"product_tags\""
input product_tags_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: product_tags_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input product_tags_stream_cursor_value_input {
  id: uuid
  product_id: uuid
  value: String
}

input products_aggregate_bool_exp {
  bool_and: products_aggregate_bool_exp_bool_and
  bool_or: products_aggregate_bool_exp_bool_or
  count: products_aggregate_bool_exp_count
}

input products_aggregate_bool_exp_bool_and {
  arguments: products_select_column_products_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_bool_or {
  arguments: products_select_column_products_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: products_bool_exp
  predicate: Boolean_comparison_exp!
}

input products_aggregate_bool_exp_count {
  arguments: [products_select_column!]
  distinct: Boolean
  filter: products_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"products\""
input products_aggregate_order_by {
  avg: products_avg_order_by
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
  stddev: products_stddev_order_by
  stddev_pop: products_stddev_pop_order_by
  stddev_samp: products_stddev_samp_order_by
  sum: products_sum_order_by
  var_pop: products_var_pop_order_by
  var_samp: products_var_samp_order_by
  variance: products_variance_order_by
}

"order by avg() on columns of table \"products\""
input products_avg_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Boolean expression to filter rows from the table \"products\". All fields are combined with a logical 'AND'."
input products_bool_exp {
  _and: [products_bool_exp!]
  _not: products_bool_exp
  _or: [products_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  care: String_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  color: String_comparison_exp
  content: products_translations_bool_exp
  created_at: timestamptz_comparison_exp
  current_price: Int_comparison_exp
  default_price_multiplier: numeric_comparison_exp
  description: String_comparison_exp
  disallow_listing: Boolean_comparison_exp
  fit: String_comparison_exp
  id: uuid_comparison_exp
  images: product_images_bool_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  lowest_price: Int_comparison_exp
  material: String_comparison_exp
  name: String_comparison_exp
  normalized_name: String_comparison_exp
  original_price: Int_comparison_exp
  parent_product: products_bool_exp
  parent_product_id: uuid_comparison_exp
  product_attribute_type_options: product_attribute_type_options_bool_exp
  product_colors: product_colors_bool_exp
  product_style_id: uuid_comparison_exp
  product_tags: product_tags_bool_exp
  product_tags_aggregate: product_tags_aggregate_bool_exp
  products: products_bool_exp
  products_aggregate: products_aggregate_bool_exp
  products_translations: products_translations_bool_exp
  products_translations_aggregate: products_translations_aggregate_bool_exp
  question_set: question_sets_bool_exp
  question_set_id: uuid_comparison_exp
  sale_price: Int_comparison_exp
  searchable_products_results: searchable_products_results_bool_exp
  searchable_products_results_aggregate: searchable_products_results_aggregate_bool_exp
  skus: skus_bool_exp
  style: product_styles_bool_exp
  super_category: brand_categories_bool_exp
  super_category_id: uuid_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"order by max() on columns of table \"products\""
input products_max_order_by {
  brand_id: order_by
  care: order_by
  category_id: order_by
  color: order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  fit: order_by
  id: order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product_id: order_by
  product_style_id: order_by
  question_set_id: order_by
  sale_price: order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"order by min() on columns of table \"products\""
input products_min_order_by {
  brand_id: order_by
  care: order_by
  category_id: order_by
  color: order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  fit: order_by
  id: order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product_id: order_by
  product_style_id: order_by
  question_set_id: order_by
  sale_price: order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"Ordering options when selecting data from \"products\"."
input products_order_by {
  brand: brands_order_by
  brand_id: order_by
  care: order_by
  category: brand_categories_order_by
  category_id: order_by
  color: order_by
  content_aggregate: products_translations_aggregate_order_by
  created_at: order_by
  current_price: order_by
  default_price_multiplier: order_by
  description: order_by
  disallow_listing: order_by
  fit: order_by
  id: order_by
  images_aggregate: product_images_aggregate_order_by
  listings_aggregate: listings_aggregate_order_by
  lowest_price: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  original_price: order_by
  parent_product: products_order_by
  parent_product_id: order_by
  product_attribute_type_options_aggregate: product_attribute_type_options_aggregate_order_by
  product_colors_aggregate: product_colors_aggregate_order_by
  product_style_id: order_by
  product_tags_aggregate: product_tags_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  products_translations_aggregate: products_translations_aggregate_order_by
  question_set: question_sets_order_by
  question_set_id: order_by
  sale_price: order_by
  searchable_products_results_aggregate: searchable_products_results_aggregate_order_by
  skus_aggregate: skus_aggregate_order_by
  style: product_styles_order_by
  super_category: brand_categories_order_by
  super_category_id: order_by
  uid: order_by
  updated_at: order_by
  url: order_by
}

"order by stddev() on columns of table \"products\""
input products_stddev_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by stddev_pop() on columns of table \"products\""
input products_stddev_pop_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by stddev_samp() on columns of table \"products\""
input products_stddev_samp_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Streaming cursor of the table \"products\""
input products_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: products_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input products_stream_cursor_value_input {
  brand_id: uuid
  care: String
  category_id: uuid
  color: String
  created_at: timestamptz
  current_price: Int
  default_price_multiplier: numeric
  description: String
  disallow_listing: Boolean
  fit: String
  id: uuid
  lowest_price: Int
  material: String
  name: String
  normalized_name: String
  original_price: Int
  parent_product_id: uuid
  product_style_id: uuid
  question_set_id: uuid
  sale_price: Int
  super_category_id: uuid
  uid: String
  updated_at: timestamptz
  url: String
}

"order by sum() on columns of table \"products\""
input products_sum_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

input products_translations_aggregate_bool_exp {
  count: products_translations_aggregate_bool_exp_count
}

input products_translations_aggregate_bool_exp_count {
  arguments: [products_translations_select_column!]
  distinct: Boolean
  filter: products_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"products_translations\""
input products_translations_aggregate_order_by {
  avg: products_translations_avg_order_by
  count: order_by
  max: products_translations_max_order_by
  min: products_translations_min_order_by
  stddev: products_translations_stddev_order_by
  stddev_pop: products_translations_stddev_pop_order_by
  stddev_samp: products_translations_stddev_samp_order_by
  sum: products_translations_sum_order_by
  var_pop: products_translations_var_pop_order_by
  var_samp: products_translations_var_samp_order_by
  variance: products_translations_variance_order_by
}

"order by avg() on columns of table \"products_translations\""
input products_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"products_translations\". All fields are combined with a logical 'AND'."
input products_translations_bool_exp {
  _and: [products_translations_bool_exp!]
  _not: products_translations_bool_exp
  _or: [products_translations_bool_exp!]
  care: String_comparison_exp
  color: String_comparison_exp
  description: String_comparison_exp
  fit: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  material: String_comparison_exp
  name: String_comparison_exp
  normalized_name: String_comparison_exp
  product_id: uuid_comparison_exp
}

"order by max() on columns of table \"products_translations\""
input products_translations_max_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"order by min() on columns of table \"products_translations\""
input products_translations_min_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"Ordering options when selecting data from \"products_translations\"."
input products_translations_order_by {
  care: order_by
  color: order_by
  description: order_by
  fit: order_by
  id: order_by
  lang: order_by
  material: order_by
  name: order_by
  normalized_name: order_by
  product_id: order_by
}

"order by stddev() on columns of table \"products_translations\""
input products_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"products_translations\""
input products_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"products_translations\""
input products_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"products_translations\""
input products_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: products_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input products_translations_stream_cursor_value_input {
  care: String
  color: String
  description: String
  fit: String
  id: Int
  lang: String
  material: String
  name: String
  normalized_name: String
  product_id: uuid
}

"order by sum() on columns of table \"products_translations\""
input products_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"products_translations\""
input products_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"products_translations\""
input products_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"products_translations\""
input products_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"products\""
input products_var_pop_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by var_samp() on columns of table \"products\""
input products_var_samp_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"order by variance() on columns of table \"products\""
input products_variance_order_by {
  current_price: order_by
  default_price_multiplier: order_by
  lowest_price: order_by
  original_price: order_by
  sale_price: order_by
}

"Boolean expression to filter rows from the table \"question_sets\". All fields are combined with a logical 'AND'."
input question_sets_bool_exp {
  _and: [question_sets_bool_exp!]
  _not: question_sets_bool_exp
  _or: [question_sets_bool_exp!]
  brand_id: uuid_comparison_exp
  condition_questions: condition_questions_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"question_sets\"."
input question_sets_order_by {
  brand_id: order_by
  condition_questions_aggregate: condition_questions_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  notes: order_by
  uid: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"question_sets\""
input question_sets_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: question_sets_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input question_sets_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  notes: String
  uid: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"retail_associates\". All fields are combined with a logical 'AND'."
input retail_associates_bool_exp {
  _and: [retail_associates_bool_exp!]
  _not: retail_associates_bool_exp
  _or: [retail_associates_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  retail_store_id: uuid_comparison_exp
  store_number: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"Ordering options when selecting data from \"retail_associates\"."
input retail_associates_order_by {
  brand: brands_order_by
  brand_id: order_by
  id: order_by
  retail_store_id: order_by
  store_number: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"retail_associates\""
input retail_associates_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_associates_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_associates_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  retail_store_id: uuid
  store_number: String
  user_id: String
}

"Boolean expression to filter rows from the table \"retail_store_addresses\". All fields are combined with a logical 'AND'."
input retail_store_addresses_bool_exp {
  _and: [retail_store_addresses_bool_exp!]
  _not: retail_store_addresses_bool_exp
  _or: [retail_store_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  country: String_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  postal_code: String_comparison_exp
}

"Ordering options when selecting data from \"retail_store_addresses\"."
input retail_store_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  id: order_by
  locality: order_by
  name: order_by
  postal_code: order_by
}

"Streaming cursor of the table \"retail_store_addresses\""
input retail_store_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_store_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_store_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  country: String
  id: uuid
  locality: String
  name: String
  postal_code: String
}

"Boolean expression to filter rows from the table \"retail_store_brand_uses\". All fields are combined with a logical 'AND'."
input retail_store_brand_uses_bool_exp {
  _and: [retail_store_brand_uses_bool_exp!]
  _not: retail_store_brand_uses_bool_exp
  _or: [retail_store_brand_uses_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  retail_store: retail_stores_bool_exp
  retail_store_id: uuid_comparison_exp
  use_case: retail_store_use_cases_enum_comparison_exp
}

"Ordering options when selecting data from \"retail_store_brand_uses\"."
input retail_store_brand_uses_order_by {
  brand: brands_order_by
  brand_id: order_by
  retail_store: retail_stores_order_by
  retail_store_id: order_by
  use_case: order_by
}

"Streaming cursor of the table \"retail_store_brand_uses\""
input retail_store_brand_uses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_store_brand_uses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_store_brand_uses_stream_cursor_value_input {
  brand_id: uuid
  retail_store_id: uuid
  use_case: retail_store_use_cases_enum
}

"Boolean expression to compare columns of type \"retail_store_use_cases_enum\". All fields are combined with logical 'AND'."
input retail_store_use_cases_enum_comparison_exp {
  _eq: retail_store_use_cases_enum
  _in: [retail_store_use_cases_enum!]
  _is_null: Boolean
  _neq: retail_store_use_cases_enum
  _nin: [retail_store_use_cases_enum!]
}

"Boolean expression to filter rows from the table \"retail_stores\". All fields are combined with a logical 'AND'."
input retail_stores_bool_exp {
  _and: [retail_stores_bool_exp!]
  _not: retail_stores_bool_exp
  _or: [retail_stores_bool_exp!]
  address: addresses_bool_exp
  address_id: uuid_comparison_exp
  content: retail_stores_translations_bool_exp
  created_at: timestamptz_comparison_exp
  external_identifier: String_comparison_exp
  id: uuid_comparison_exp
  pos_stations: pos_stations_bool_exp
  public_address: retail_store_addresses_bool_exp
  translations: retail_stores_translations_bool_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"retail_stores\"."
input retail_stores_order_by {
  address: addresses_order_by
  address_id: order_by
  content_aggregate: retail_stores_translations_aggregate_order_by
  created_at: order_by
  external_identifier: order_by
  id: order_by
  pos_stations_aggregate: pos_stations_aggregate_order_by
  public_address: retail_store_addresses_order_by
  translations_aggregate: retail_stores_translations_aggregate_order_by
  updated_at: order_by
}

"Streaming cursor of the table \"retail_stores\""
input retail_stores_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_stores_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_stores_stream_cursor_value_input {
  address_id: uuid
  created_at: timestamptz
  external_identifier: String
  id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"retail_stores_translations\""
input retail_stores_translations_aggregate_order_by {
  avg: retail_stores_translations_avg_order_by
  count: order_by
  max: retail_stores_translations_max_order_by
  min: retail_stores_translations_min_order_by
  stddev: retail_stores_translations_stddev_order_by
  stddev_pop: retail_stores_translations_stddev_pop_order_by
  stddev_samp: retail_stores_translations_stddev_samp_order_by
  sum: retail_stores_translations_sum_order_by
  var_pop: retail_stores_translations_var_pop_order_by
  var_samp: retail_stores_translations_var_samp_order_by
  variance: retail_stores_translations_variance_order_by
}

"order by avg() on columns of table \"retail_stores_translations\""
input retail_stores_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"retail_stores_translations\". All fields are combined with a logical 'AND'."
input retail_stores_translations_bool_exp {
  _and: [retail_stores_translations_bool_exp!]
  _not: retail_stores_translations_bool_exp
  _or: [retail_stores_translations_bool_exp!]
  id: Int_comparison_exp
  lang: String_comparison_exp
  name: String_comparison_exp
  retail_store_id: uuid_comparison_exp
}

"order by max() on columns of table \"retail_stores_translations\""
input retail_stores_translations_max_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"order by min() on columns of table \"retail_stores_translations\""
input retail_stores_translations_min_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"Ordering options when selecting data from \"retail_stores_translations\"."
input retail_stores_translations_order_by {
  id: order_by
  lang: order_by
  name: order_by
  retail_store_id: order_by
}

"order by stddev() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"retail_stores_translations\""
input retail_stores_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"retail_stores_translations\""
input retail_stores_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: retail_stores_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input retail_stores_translations_stream_cursor_value_input {
  id: Int
  lang: String
  name: String
  retail_store_id: uuid
}

"order by sum() on columns of table \"retail_stores_translations\""
input retail_stores_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"retail_stores_translations\""
input retail_stores_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"retail_stores_translations\""
input retail_stores_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"retail_stores_translations\""
input retail_stores_translations_variance_order_by {
  id: order_by
}

"Boolean expression to compare columns of type \"return_item_statuses_enum\". All fields are combined with logical 'AND'."
input return_item_statuses_enum_comparison_exp {
  _eq: return_item_statuses_enum
  _in: [return_item_statuses_enum!]
  _is_null: Boolean
  _neq: return_item_statuses_enum
  _nin: [return_item_statuses_enum!]
}

"order by aggregate values of table \"return_items\""
input return_items_aggregate_order_by {
  count: order_by
  max: return_items_max_order_by
  min: return_items_min_order_by
}

"input type for inserting array relation for remote table \"return_items\""
input return_items_arr_rel_insert_input {
  data: [return_items_insert_input!]!
  "upsert condition"
  on_conflict: return_items_on_conflict
}

"Boolean expression to filter rows from the table \"return_items\". All fields are combined with a logical 'AND'."
input return_items_bool_exp {
  _and: [return_items_bool_exp!]
  _not: return_items_bool_exp
  _or: [return_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  damage_type: String_comparison_exp
  id: uuid_comparison_exp
  order_item: order_items_bool_exp
  order_item_id: uuid_comparison_exp
  return: returns_bool_exp
  return_id: uuid_comparison_exp
  return_reason: String_comparison_exp
  status: return_item_statuses_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"return_items\""
input return_items_insert_input {
  created_at: timestamptz
  damage_type: String
  id: uuid
  order_item: order_items_obj_rel_insert_input
  order_item_id: uuid
  return: returns_obj_rel_insert_input
  return_id: uuid
  return_reason: String
  status: return_item_statuses_enum
  updated_at: timestamptz
}

"order by max() on columns of table \"return_items\""
input return_items_max_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item_id: order_by
  return_id: order_by
  return_reason: order_by
  updated_at: order_by
}

"order by min() on columns of table \"return_items\""
input return_items_min_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item_id: order_by
  return_id: order_by
  return_reason: order_by
  updated_at: order_by
}

"on_conflict condition type for table \"return_items\""
input return_items_on_conflict {
  constraint: return_items_constraint!
  update_columns: [return_items_update_column!]! = []
  where: return_items_bool_exp
}

"Ordering options when selecting data from \"return_items\"."
input return_items_order_by {
  created_at: order_by
  damage_type: order_by
  id: order_by
  order_item: order_items_order_by
  order_item_id: order_by
  return: returns_order_by
  return_id: order_by
  return_reason: order_by
  status: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"return_items\""
input return_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: return_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input return_items_stream_cursor_value_input {
  created_at: timestamptz
  damage_type: String
  id: uuid
  order_item_id: uuid
  return_id: uuid
  return_reason: String
  status: return_item_statuses_enum
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"return_statuses_enum\". All fields are combined with logical 'AND'."
input return_statuses_enum_comparison_exp {
  _eq: return_statuses_enum
  _in: [return_statuses_enum!]
  _is_null: Boolean
  _neq: return_statuses_enum
  _nin: [return_statuses_enum!]
}

"Boolean expression to filter rows from the table \"returns\". All fields are combined with a logical 'AND'."
input returns_bool_exp {
  _and: [returns_bool_exp!]
  _not: returns_bool_exp
  _or: [returns_bool_exp!]
  address: order_addresses_bool_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  items: return_items_bool_exp
  preferred_language: String_comparison_exp
  return_shipping_address_id: uuid_comparison_exp
  return_shipping_label_id: uuid_comparison_exp
  shipping_label: shipping_labels_bool_exp
  status: return_statuses_enum_comparison_exp
  stripe_refund_id: String_comparison_exp
  subtotal: Int_comparison_exp
  tax: Int_comparison_exp
  total: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"returns\""
input returns_insert_input {
  address: order_addresses_obj_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  items: return_items_arr_rel_insert_input
  preferred_language: String
  return_shipping_address_id: uuid
  return_shipping_label_id: uuid
  status: return_statuses_enum
  stripe_refund_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

"input type for inserting object relation for remote table \"returns\""
input returns_obj_rel_insert_input {
  data: returns_insert_input!
  "upsert condition"
  on_conflict: returns_on_conflict
}

"on_conflict condition type for table \"returns\""
input returns_on_conflict {
  constraint: returns_constraint!
  update_columns: [returns_update_column!]! = []
  where: returns_bool_exp
}

"Ordering options when selecting data from \"returns\"."
input returns_order_by {
  address: order_addresses_order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  items_aggregate: return_items_aggregate_order_by
  preferred_language: order_by
  return_shipping_address_id: order_by
  return_shipping_label_id: order_by
  shipping_label: shipping_labels_order_by
  status: order_by
  stripe_refund_id: order_by
  subtotal: order_by
  tax: order_by
  total: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"returns\""
input returns_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: returns_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input returns_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  preferred_language: String
  return_shipping_address_id: uuid
  return_shipping_label_id: uuid
  status: return_statuses_enum
  stripe_refund_id: String
  subtotal: Int
  tax: Int
  total: Int
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"review_statuses_enum\". All fields are combined with logical 'AND'."
input review_statuses_enum_comparison_exp {
  _eq: review_statuses_enum
  _in: [review_statuses_enum!]
  _is_null: Boolean
  _neq: review_statuses_enum
  _nin: [review_statuses_enum!]
}

"Boolean expression to filter rows from the table \"roles\". All fields are combined with a logical 'AND'."
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  role: String_comparison_exp
}

"Boolean expression to compare columns of type \"roles_enum\". All fields are combined with logical 'AND'."
input roles_enum_comparison_exp {
  _eq: roles_enum
  _in: [roles_enum!]
  _is_null: Boolean
  _neq: roles_enum
  _nin: [roles_enum!]
}

"Ordering options when selecting data from \"roles\"."
input roles_order_by {
  role: order_by
}

"Streaming cursor of the table \"roles\""
input roles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: roles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input roles_stream_cursor_value_input {
  role: String
}

input search_listings_31pl_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_listings_args {
  brand_id: uuid
  search: String
}

input search_listings_tnf_args {
  brand_id: uuid
  search: String
  tag_search: json
}

"order by aggregate values of table \"search_page_translations\""
input search_page_translations_aggregate_order_by {
  avg: search_page_translations_avg_order_by
  count: order_by
  max: search_page_translations_max_order_by
  min: search_page_translations_min_order_by
  stddev: search_page_translations_stddev_order_by
  stddev_pop: search_page_translations_stddev_pop_order_by
  stddev_samp: search_page_translations_stddev_samp_order_by
  sum: search_page_translations_sum_order_by
  var_pop: search_page_translations_var_pop_order_by
  var_samp: search_page_translations_var_samp_order_by
  variance: search_page_translations_variance_order_by
}

"order by avg() on columns of table \"search_page_translations\""
input search_page_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"search_page_translations\". All fields are combined with a logical 'AND'."
input search_page_translations_bool_exp {
  _and: [search_page_translations_bool_exp!]
  _not: search_page_translations_bool_exp
  _or: [search_page_translations_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: Int_comparison_exp
  locale: String_comparison_exp
  search_page: search_pages_bool_exp
  search_page_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"search_page_translations\""
input search_page_translations_max_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"search_page_translations\""
input search_page_translations_min_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"search_page_translations\"."
input search_page_translations_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  locale: order_by
  search_page: search_pages_order_by
  search_page_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"search_page_translations\""
input search_page_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"search_page_translations\""
input search_page_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"search_page_translations\""
input search_page_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"search_page_translations\""
input search_page_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: search_page_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input search_page_translations_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: Int
  locale: String
  search_page_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"search_page_translations\""
input search_page_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"search_page_translations\""
input search_page_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"search_page_translations\""
input search_page_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"search_page_translations\""
input search_page_translations_variance_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"search_pages\". All fields are combined with a logical 'AND'."
input search_pages_bool_exp {
  _and: [search_pages_bool_exp!]
  _not: search_pages_bool_exp
  _or: [search_pages_bool_exp!]
  active: Boolean_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  collection: collections_bool_exp
  collection_id: uuid_comparison_exp
  content: search_page_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  search_page_translations: search_page_translations_bool_exp
  slug: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"search_pages\"."
input search_pages_order_by {
  active: order_by
  brand: brands_order_by
  brand_id: order_by
  collection: collections_order_by
  collection_id: order_by
  content_aggregate: search_page_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  search_page_translations_aggregate: search_page_translations_aggregate_order_by
  slug: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"search_pages\""
input search_pages_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: search_pages_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input search_pages_stream_cursor_value_input {
  active: Boolean
  brand_id: uuid
  collection_id: uuid
  created_at: timestamptz
  id: uuid
  slug: String
  updated_at: timestamptz
}

input search_products_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_products_by_sku_args {
  brand_id: uuid
  sku_text: String
}

input search_products_by_sku_collapsed_args {
  brand_id: uuid
  sku_text: String
}

input search_products_collapsed_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_styles_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_unique_listed_product_styles_tnf_args {
  brand_id: uuid
  search: String
  tag_search: json
}

input search_users_args {
  search: String
}

"Boolean expression to filter rows from the table \"searchable_products\". All fields are combined with a logical 'AND'."
input searchable_products_bool_exp {
  _and: [searchable_products_bool_exp!]
  _not: searchable_products_bool_exp
  _or: [searchable_products_bool_exp!]
  brand: brands_bool_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product: products_bool_exp
  product_brand_id: uuid_comparison_exp
  sizes: String_comparison_exp
  skus: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"searchable_products\"."
input searchable_products_order_by {
  brand: brands_order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  product: products_order_by
  product_brand_id: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

input searchable_products_results_aggregate_bool_exp {
  count: searchable_products_results_aggregate_bool_exp_count
}

input searchable_products_results_aggregate_bool_exp_count {
  arguments: [searchable_products_results_select_column!]
  distinct: Boolean
  filter: searchable_products_results_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"searchable_products_results\""
input searchable_products_results_aggregate_order_by {
  count: order_by
  max: searchable_products_results_max_order_by
  min: searchable_products_results_min_order_by
}

"Boolean expression to filter rows from the table \"searchable_products_results\". All fields are combined with a logical 'AND'."
input searchable_products_results_bool_exp {
  _and: [searchable_products_results_bool_exp!]
  _not: searchable_products_results_bool_exp
  _or: [searchable_products_results_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product: products_bool_exp
  sizes: String_comparison_exp
  skus: String_comparison_exp
  type: String_comparison_exp
}

"order by max() on columns of table \"searchable_products_results\""
input searchable_products_results_max_order_by {
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"order by min() on columns of table \"searchable_products_results\""
input searchable_products_results_min_order_by {
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"Ordering options when selecting data from \"searchable_products_results\"."
input searchable_products_results_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  id: order_by
  name: order_by
  product: products_order_by
  sizes: order_by
  skus: order_by
  type: order_by
}

"Streaming cursor of the table \"searchable_products_results\""
input searchable_products_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: searchable_products_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input searchable_products_results_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  id: uuid
  name: String
  sizes: String
  skus: String
  type: String
}

"Streaming cursor of the table \"searchable_products\""
input searchable_products_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: searchable_products_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input searchable_products_stream_cursor_value_input {
  color: String
  color_mapping: String
  id: uuid
  name: String
  product_brand_id: uuid
  sizes: String
  skus: String
  type: String
}

"Boolean expression to filter rows from the table \"seller_ratings\". All fields are combined with a logical 'AND'."
input seller_ratings_bool_exp {
  _and: [seller_ratings_bool_exp!]
  _not: seller_ratings_bool_exp
  _or: [seller_ratings_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing_id: uuid_comparison_exp
  rating: Int_comparison_exp
  seller_id: String_comparison_exp
  storefront_id: uuid_comparison_exp
  user_id: String_comparison_exp
  user_rated: Boolean_comparison_exp
}

"input type for incrementing numeric columns in table \"seller_ratings\""
input seller_ratings_inc_input {
  rating: Int
}

"input type for inserting data into table \"seller_ratings\""
input seller_ratings_insert_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

"on_conflict condition type for table \"seller_ratings\""
input seller_ratings_on_conflict {
  constraint: seller_ratings_constraint!
  update_columns: [seller_ratings_update_column!]! = []
  where: seller_ratings_bool_exp
}

"Ordering options when selecting data from \"seller_ratings\"."
input seller_ratings_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  listing_id: order_by
  rating: order_by
  seller_id: order_by
  storefront_id: order_by
  user_id: order_by
  user_rated: order_by
}

"primary key columns input for table: seller_ratings"
input seller_ratings_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"seller_ratings\""
input seller_ratings_set_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

"Streaming cursor of the table \"seller_ratings\""
input seller_ratings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: seller_ratings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input seller_ratings_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  rating: Int
  seller_id: String
  storefront_id: uuid
  user_id: String
  user_rated: Boolean
}

input seller_ratings_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: seller_ratings_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: seller_ratings_set_input
  "filter the rows which have to be updated"
  where: seller_ratings_bool_exp!
}

"Boolean expression to filter rows from the table \"shipping_carriers\". All fields are combined with a logical 'AND'."
input shipping_carriers_bool_exp {
  _and: [shipping_carriers_bool_exp!]
  _not: shipping_carriers_bool_exp
  _or: [shipping_carriers_bool_exp!]
  carrier: String_comparison_exp
}

"Boolean expression to compare columns of type \"shipping_carriers_enum\". All fields are combined with logical 'AND'."
input shipping_carriers_enum_comparison_exp {
  _eq: shipping_carriers_enum
  _in: [shipping_carriers_enum!]
  _is_null: Boolean
  _neq: shipping_carriers_enum
  _nin: [shipping_carriers_enum!]
}

"Ordering options when selecting data from \"shipping_carriers\"."
input shipping_carriers_order_by {
  carrier: order_by
}

"Streaming cursor of the table \"shipping_carriers\""
input shipping_carriers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_carriers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_carriers_stream_cursor_value_input {
  carrier: String
}

"Boolean expression to filter rows from the table \"shipping_information\". All fields are combined with a logical 'AND'."
input shipping_information_bool_exp {
  _and: [shipping_information_bool_exp!]
  _not: shipping_information_bool_exp
  _or: [shipping_information_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  in_store_pickups: in_store_pickups_bool_exp
  order_items: order_items_bool_exp
  order_items_aggregate: order_items_aggregate_bool_exp
  shipping_method: shipping_methods_enum_comparison_exp
  shipping_method_identifier: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"shipping_information\""
input shipping_information_insert_input {
  created_at: timestamptz
  id: uuid
  order_items: order_items_arr_rel_insert_input
  shipping_method: shipping_methods_enum
  shipping_method_identifier: String
  updated_at: timestamptz
}

"input type for inserting object relation for remote table \"shipping_information\""
input shipping_information_obj_rel_insert_input {
  data: shipping_information_insert_input!
  "upsert condition"
  on_conflict: shipping_information_on_conflict
}

"on_conflict condition type for table \"shipping_information\""
input shipping_information_on_conflict {
  constraint: shipping_information_constraint!
  update_columns: [shipping_information_update_column!]! = []
  where: shipping_information_bool_exp
}

"Ordering options when selecting data from \"shipping_information\"."
input shipping_information_order_by {
  created_at: order_by
  id: order_by
  in_store_pickups_aggregate: in_store_pickups_aggregate_order_by
  order_items_aggregate: order_items_aggregate_order_by
  shipping_method: order_by
  shipping_method_identifier: order_by
  updated_at: order_by
}

"primary key columns input for table: shipping_information"
input shipping_information_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"shipping_information\""
input shipping_information_set_input {
  updated_at: timestamptz
}

"Streaming cursor of the table \"shipping_information\""
input shipping_information_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_information_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_information_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  shipping_method: shipping_methods_enum
  shipping_method_identifier: String
  updated_at: timestamptz
}

input shipping_information_updates {
  "sets the columns of the filtered rows to the given values"
  _set: shipping_information_set_input
  "filter the rows which have to be updated"
  where: shipping_information_bool_exp!
}

"order by aggregate values of table \"shipping_labels\""
input shipping_labels_aggregate_order_by {
  count: order_by
  max: shipping_labels_max_order_by
  min: shipping_labels_min_order_by
}

"Boolean expression to filter rows from the table \"shipping_labels\". All fields are combined with a logical 'AND'."
input shipping_labels_bool_exp {
  _and: [shipping_labels_bool_exp!]
  _not: shipping_labels_bool_exp
  _or: [shipping_labels_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  mail_takebacks: mail_takebacks_bool_exp
  private: shipping_labels_private_bool_exp
  return_listings: listings_bool_exp
  return_listings_aggregate: listings_aggregate_bool_exp
  shipping_carrier: shipping_carriers_enum_comparison_exp
  shipping_service: shipping_services_enum_comparison_exp
  shipping_service_id: String_comparison_exp
  status: shipping_statuses_enum_comparison_exp
  tracking_number: String_comparison_exp
  tracking_url: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"shipping_labels\""
input shipping_labels_max_order_by {
  created_at: order_by
  id: order_by
  listing_id: order_by
  shipping_service_id: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"shipping_labels\""
input shipping_labels_min_order_by {
  created_at: order_by
  id: order_by
  listing_id: order_by
  shipping_service_id: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"shipping_labels\"."
input shipping_labels_order_by {
  created_at: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  listings_aggregate: listings_aggregate_order_by
  mail_takebacks_aggregate: mail_takebacks_aggregate_order_by
  private: shipping_labels_private_order_by
  return_listings_aggregate: listings_aggregate_order_by
  shipping_carrier: order_by
  shipping_service: order_by
  shipping_service_id: order_by
  status: order_by
  tracking_number: order_by
  tracking_url: order_by
  updated_at: order_by
  user_id: order_by
}

"Boolean expression to filter rows from the table \"shipping_labels_private\". All fields are combined with a logical 'AND'."
input shipping_labels_private_bool_exp {
  _and: [shipping_labels_private_bool_exp!]
  _not: shipping_labels_private_bool_exp
  _or: [shipping_labels_private_bool_exp!]
  id: uuid_comparison_exp
  label_url: String_comparison_exp
  metadata: jsonb_comparison_exp
  shipping_label: shipping_labels_bool_exp
}

"Ordering options when selecting data from \"shipping_labels_private\"."
input shipping_labels_private_order_by {
  id: order_by
  label_url: order_by
  metadata: order_by
  shipping_label: shipping_labels_order_by
}

"Streaming cursor of the table \"shipping_labels_private\""
input shipping_labels_private_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_labels_private_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_labels_private_stream_cursor_value_input {
  id: uuid
  label_url: String
  metadata: jsonb
}

"Streaming cursor of the table \"shipping_labels\""
input shipping_labels_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_labels_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_labels_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  shipping_carrier: shipping_carriers_enum
  shipping_service: shipping_services_enum
  shipping_service_id: String
  status: shipping_statuses_enum
  tracking_number: String
  tracking_url: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"shipping_methods_enum\". All fields are combined with logical 'AND'."
input shipping_methods_enum_comparison_exp {
  _eq: shipping_methods_enum
  _in: [shipping_methods_enum!]
  _is_null: Boolean
  _neq: shipping_methods_enum
  _nin: [shipping_methods_enum!]
}

"Boolean expression to compare columns of type \"shipping_services_enum\". All fields are combined with logical 'AND'."
input shipping_services_enum_comparison_exp {
  _eq: shipping_services_enum
  _in: [shipping_services_enum!]
  _is_null: Boolean
  _neq: shipping_services_enum
  _nin: [shipping_services_enum!]
}

"Boolean expression to filter rows from the table \"shipping_statuses\". All fields are combined with a logical 'AND'."
input shipping_statuses_bool_exp {
  _and: [shipping_statuses_bool_exp!]
  _not: shipping_statuses_bool_exp
  _or: [shipping_statuses_bool_exp!]
  status: String_comparison_exp
}

"Boolean expression to compare columns of type \"shipping_statuses_enum\". All fields are combined with logical 'AND'."
input shipping_statuses_enum_comparison_exp {
  _eq: shipping_statuses_enum
  _in: [shipping_statuses_enum!]
  _is_null: Boolean
  _neq: shipping_statuses_enum
  _nin: [shipping_statuses_enum!]
}

"Ordering options when selecting data from \"shipping_statuses\"."
input shipping_statuses_order_by {
  status: order_by
}

"Streaming cursor of the table \"shipping_statuses\""
input shipping_statuses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: shipping_statuses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input shipping_statuses_stream_cursor_value_input {
  status: String
}

"Boolean expression to filter rows from the table \"short_links\". All fields are combined with a logical 'AND'."
input short_links_bool_exp {
  _and: [short_links_bool_exp!]
  _not: short_links_bool_exp
  _or: [short_links_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  identifier: String_comparison_exp
  path: String_comparison_exp
  query_params: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"short_links\"."
input short_links_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  identifier: order_by
  path: order_by
  query_params: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"short_links\""
input short_links_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: short_links_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input short_links_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  identifier: String
  path: String
  query_params: jsonb
  updated_at: timestamptz
}

"order by aggregate values of table \"sku_images\""
input sku_images_aggregate_order_by {
  avg: sku_images_avg_order_by
  count: order_by
  max: sku_images_max_order_by
  min: sku_images_min_order_by
  stddev: sku_images_stddev_order_by
  stddev_pop: sku_images_stddev_pop_order_by
  stddev_samp: sku_images_stddev_samp_order_by
  sum: sku_images_sum_order_by
  var_pop: sku_images_var_pop_order_by
  var_samp: sku_images_var_samp_order_by
  variance: sku_images_variance_order_by
}

"order by avg() on columns of table \"sku_images\""
input sku_images_avg_order_by {
  index: order_by
}

"Boolean expression to filter rows from the table \"sku_images\". All fields are combined with a logical 'AND'."
input sku_images_bool_exp {
  _and: [sku_images_bool_exp!]
  _not: sku_images_bool_exp
  _or: [sku_images_bool_exp!]
  alt: String_comparison_exp
  content: sku_images_translations_bool_exp
  created_at: timestamptz_comparison_exp
  detail: Boolean_comparison_exp
  id: uuid_comparison_exp
  images_translations: sku_images_translations_bool_exp
  images_translations_aggregate: sku_images_translations_aggregate_bool_exp
  index: Int_comparison_exp
  photo_enhancement_requests: photo_enhancement_requests_bool_exp
  primary: Boolean_comparison_exp
  primary_hover: Boolean_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  src: String_comparison_exp
  swatch: Boolean_comparison_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"sku_images\""
input sku_images_max_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  sku_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"order by min() on columns of table \"sku_images\""
input sku_images_min_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  index: order_by
  sku_id: order_by
  src: order_by
  uid: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"sku_images\"."
input sku_images_order_by {
  alt: order_by
  content_aggregate: sku_images_translations_aggregate_order_by
  created_at: order_by
  detail: order_by
  id: order_by
  images_translations_aggregate: sku_images_translations_aggregate_order_by
  index: order_by
  photo_enhancement_requests_aggregate: photo_enhancement_requests_aggregate_order_by
  primary: order_by
  primary_hover: order_by
  sku: skus_order_by
  sku_id: order_by
  src: order_by
  swatch: order_by
  uid: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"sku_images\""
input sku_images_stddev_order_by {
  index: order_by
}

"order by stddev_pop() on columns of table \"sku_images\""
input sku_images_stddev_pop_order_by {
  index: order_by
}

"order by stddev_samp() on columns of table \"sku_images\""
input sku_images_stddev_samp_order_by {
  index: order_by
}

"Streaming cursor of the table \"sku_images\""
input sku_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  detail: Boolean
  id: uuid
  index: Int
  primary: Boolean
  primary_hover: Boolean
  sku_id: uuid
  src: String
  swatch: Boolean
  uid: String
  updated_at: timestamptz
}

"order by sum() on columns of table \"sku_images\""
input sku_images_sum_order_by {
  index: order_by
}

input sku_images_translations_aggregate_bool_exp {
  count: sku_images_translations_aggregate_bool_exp_count
}

input sku_images_translations_aggregate_bool_exp_count {
  arguments: [sku_images_translations_select_column!]
  distinct: Boolean
  filter: sku_images_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"sku_images_translations\""
input sku_images_translations_aggregate_order_by {
  avg: sku_images_translations_avg_order_by
  count: order_by
  max: sku_images_translations_max_order_by
  min: sku_images_translations_min_order_by
  stddev: sku_images_translations_stddev_order_by
  stddev_pop: sku_images_translations_stddev_pop_order_by
  stddev_samp: sku_images_translations_stddev_samp_order_by
  sum: sku_images_translations_sum_order_by
  var_pop: sku_images_translations_var_pop_order_by
  var_samp: sku_images_translations_var_samp_order_by
  variance: sku_images_translations_variance_order_by
}

"order by avg() on columns of table \"sku_images_translations\""
input sku_images_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"sku_images_translations\". All fields are combined with a logical 'AND'."
input sku_images_translations_bool_exp {
  _and: [sku_images_translations_bool_exp!]
  _not: sku_images_translations_bool_exp
  _or: [sku_images_translations_bool_exp!]
  alt: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  sku_image_id: uuid_comparison_exp
}

"order by max() on columns of table \"sku_images_translations\""
input sku_images_translations_max_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"order by min() on columns of table \"sku_images_translations\""
input sku_images_translations_min_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"Ordering options when selecting data from \"sku_images_translations\"."
input sku_images_translations_order_by {
  alt: order_by
  id: order_by
  lang: order_by
  sku_image_id: order_by
}

"order by stddev() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"sku_images_translations\""
input sku_images_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"sku_images_translations\""
input sku_images_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_images_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_images_translations_stream_cursor_value_input {
  alt: String
  id: Int
  lang: String
  sku_image_id: uuid
}

"order by sum() on columns of table \"sku_images_translations\""
input sku_images_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"sku_images_translations\""
input sku_images_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"sku_images_translations\""
input sku_images_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"sku_images_translations\""
input sku_images_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"sku_images\""
input sku_images_var_pop_order_by {
  index: order_by
}

"order by var_samp() on columns of table \"sku_images\""
input sku_images_var_samp_order_by {
  index: order_by
}

"order by variance() on columns of table \"sku_images\""
input sku_images_variance_order_by {
  index: order_by
}

input sku_variant_type_options_aggregate_bool_exp {
  count: sku_variant_type_options_aggregate_bool_exp_count
}

input sku_variant_type_options_aggregate_bool_exp_count {
  arguments: [sku_variant_type_options_select_column!]
  distinct: Boolean
  filter: sku_variant_type_options_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"sku_variant_type_options\""
input sku_variant_type_options_aggregate_order_by {
  count: order_by
  max: sku_variant_type_options_max_order_by
  min: sku_variant_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"sku_variant_type_options\". All fields are combined with a logical 'AND'."
input sku_variant_type_options_bool_exp {
  _and: [sku_variant_type_options_bool_exp!]
  _not: sku_variant_type_options_bool_exp
  _or: [sku_variant_type_options_bool_exp!]
  id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_option: variant_type_options_bool_exp
  variant_type_option_id: uuid_comparison_exp
  variant_type_options_translations: variant_type_options_translations_bool_exp
  variant_types_translations: variant_types_translations_bool_exp
}

"order by max() on columns of table \"sku_variant_type_options\""
input sku_variant_type_options_max_order_by {
  id: order_by
  sku_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"sku_variant_type_options\""
input sku_variant_type_options_min_order_by {
  id: order_by
  sku_id: order_by
  variant_type_id: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"sku_variant_type_options\"."
input sku_variant_type_options_order_by {
  id: order_by
  sku: skus_order_by
  sku_id: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_option: variant_type_options_order_by
  variant_type_option_id: order_by
  variant_type_options_translations_aggregate: variant_type_options_translations_aggregate_order_by
  variant_types_translations_aggregate: variant_types_translations_aggregate_order_by
}

"Streaming cursor of the table \"sku_variant_type_options\""
input sku_variant_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: sku_variant_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input sku_variant_type_options_stream_cursor_value_input {
  id: uuid
  sku_id: uuid
  variant_type_id: uuid
  variant_type_option_id: uuid
}

"order by aggregate values of table \"skus\""
input skus_aggregate_order_by {
  avg: skus_avg_order_by
  count: order_by
  max: skus_max_order_by
  min: skus_min_order_by
  stddev: skus_stddev_order_by
  stddev_pop: skus_stddev_pop_order_by
  stddev_samp: skus_stddev_samp_order_by
  sum: skus_sum_order_by
  var_pop: skus_var_pop_order_by
  var_samp: skus_var_samp_order_by
  variance: skus_variance_order_by
}

"order by avg() on columns of table \"skus\""
input skus_avg_order_by {
  original_price: order_by
  weight: order_by
}

"Boolean expression to filter rows from the table \"skus\". All fields are combined with a logical 'AND'."
input skus_bool_exp {
  _and: [skus_bool_exp!]
  _not: skus_bool_exp
  _or: [skus_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  care: String_comparison_exp
  content: skus_translations_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  dimensions: String_comparison_exp
  dimensions_lite: String_comparison_exp
  external_sku_ids: external_sku_ids_bool_exp
  id: uuid_comparison_exp
  images: sku_images_bool_exp
  is_material: Boolean_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  luggage_sleeve: Boolean_comparison_exp
  new_logo: Boolean_comparison_exp
  original_price: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_style: product_styles_bool_exp
  product_style_id: uuid_comparison_exp
  size: String_comparison_exp
  sku: String_comparison_exp
  sku_variant_type_options: sku_variant_type_options_bool_exp
  sku_variant_type_options_aggregate: sku_variant_type_options_aggregate_bool_exp
  skus_translations: skus_translations_bool_exp
  skus_translations_aggregate: skus_translations_aggregate_bool_exp
  uid: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  weight: numeric_comparison_exp
  weight_unit: String_comparison_exp
}

"order by max() on columns of table \"skus\""
input skus_max_order_by {
  brand_id: order_by
  care: order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  original_price: order_by
  product_id: order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"order by min() on columns of table \"skus\""
input skus_min_order_by {
  brand_id: order_by
  care: order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  original_price: order_by
  product_id: order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"Ordering options when selecting data from \"skus\"."
input skus_order_by {
  brand: brands_order_by
  brand_id: order_by
  care: order_by
  content_aggregate: skus_translations_aggregate_order_by
  created_at: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  external_sku_ids_aggregate: external_sku_ids_aggregate_order_by
  id: order_by
  images_aggregate: sku_images_aggregate_order_by
  is_material: order_by
  listings_aggregate: listings_aggregate_order_by
  luggage_sleeve: order_by
  new_logo: order_by
  original_price: order_by
  product: products_order_by
  product_id: order_by
  product_style: product_styles_order_by
  product_style_id: order_by
  size: order_by
  sku: order_by
  sku_variant_type_options_aggregate: sku_variant_type_options_aggregate_order_by
  skus_translations_aggregate: skus_translations_aggregate_order_by
  uid: order_by
  updated_at: order_by
  weight: order_by
  weight_unit: order_by
}

"order by stddev() on columns of table \"skus\""
input skus_stddev_order_by {
  original_price: order_by
  weight: order_by
}

"order by stddev_pop() on columns of table \"skus\""
input skus_stddev_pop_order_by {
  original_price: order_by
  weight: order_by
}

"order by stddev_samp() on columns of table \"skus\""
input skus_stddev_samp_order_by {
  original_price: order_by
  weight: order_by
}

"Streaming cursor of the table \"skus\""
input skus_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: skus_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input skus_stream_cursor_value_input {
  brand_id: uuid
  care: String
  created_at: timestamptz
  description: String
  dimensions: String
  dimensions_lite: String
  id: uuid
  is_material: Boolean
  luggage_sleeve: Boolean
  new_logo: Boolean
  original_price: Int
  product_id: uuid
  product_style_id: uuid
  size: String
  sku: String
  uid: String
  updated_at: timestamptz
  weight: numeric
  weight_unit: String
}

"order by sum() on columns of table \"skus\""
input skus_sum_order_by {
  original_price: order_by
  weight: order_by
}

input skus_translations_aggregate_bool_exp {
  count: skus_translations_aggregate_bool_exp_count
}

input skus_translations_aggregate_bool_exp_count {
  arguments: [skus_translations_select_column!]
  distinct: Boolean
  filter: skus_translations_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"skus_translations\""
input skus_translations_aggregate_order_by {
  avg: skus_translations_avg_order_by
  count: order_by
  max: skus_translations_max_order_by
  min: skus_translations_min_order_by
  stddev: skus_translations_stddev_order_by
  stddev_pop: skus_translations_stddev_pop_order_by
  stddev_samp: skus_translations_stddev_samp_order_by
  sum: skus_translations_sum_order_by
  var_pop: skus_translations_var_pop_order_by
  var_samp: skus_translations_var_samp_order_by
  variance: skus_translations_variance_order_by
}

"order by avg() on columns of table \"skus_translations\""
input skus_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"skus_translations\". All fields are combined with a logical 'AND'."
input skus_translations_bool_exp {
  _and: [skus_translations_bool_exp!]
  _not: skus_translations_bool_exp
  _or: [skus_translations_bool_exp!]
  care: String_comparison_exp
  description: String_comparison_exp
  dimensions: String_comparison_exp
  dimensions_lite: String_comparison_exp
  id: bigint_comparison_exp
  lang: String_comparison_exp
  size: String_comparison_exp
  sku_id: uuid_comparison_exp
}

"order by max() on columns of table \"skus_translations\""
input skus_translations_max_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"order by min() on columns of table \"skus_translations\""
input skus_translations_min_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"Ordering options when selecting data from \"skus_translations\"."
input skus_translations_order_by {
  care: order_by
  description: order_by
  dimensions: order_by
  dimensions_lite: order_by
  id: order_by
  lang: order_by
  size: order_by
  sku_id: order_by
}

"order by stddev() on columns of table \"skus_translations\""
input skus_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"skus_translations\""
input skus_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"skus_translations\""
input skus_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"skus_translations\""
input skus_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: skus_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input skus_translations_stream_cursor_value_input {
  care: String
  description: String
  dimensions: String
  dimensions_lite: String
  id: bigint
  lang: String
  size: String
  sku_id: uuid
}

"order by sum() on columns of table \"skus_translations\""
input skus_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"skus_translations\""
input skus_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"skus_translations\""
input skus_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"skus_translations\""
input skus_translations_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"skus\""
input skus_var_pop_order_by {
  original_price: order_by
  weight: order_by
}

"order by var_samp() on columns of table \"skus\""
input skus_var_samp_order_by {
  original_price: order_by
  weight: order_by
}

"order by variance() on columns of table \"skus\""
input skus_variance_order_by {
  original_price: order_by
  weight: order_by
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"order by aggregate values of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_aggregate_order_by {
  avg: storefront_fulfillment_in_store_options_avg_order_by
  count: order_by
  max: storefront_fulfillment_in_store_options_max_order_by
  min: storefront_fulfillment_in_store_options_min_order_by
  stddev: storefront_fulfillment_in_store_options_stddev_order_by
  stddev_pop: storefront_fulfillment_in_store_options_stddev_pop_order_by
  stddev_samp: storefront_fulfillment_in_store_options_stddev_samp_order_by
  sum: storefront_fulfillment_in_store_options_sum_order_by
  var_pop: storefront_fulfillment_in_store_options_var_pop_order_by
  var_samp: storefront_fulfillment_in_store_options_var_samp_order_by
  variance: storefront_fulfillment_in_store_options_variance_order_by
}

"order by avg() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_in_store_options\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_in_store_options_bool_exp {
  _and: [storefront_fulfillment_in_store_options_bool_exp!]
  _not: storefront_fulfillment_in_store_options_bool_exp
  _or: [storefront_fulfillment_in_store_options_bool_exp!]
  brand_fulfillment_in_store_option: brand_fulfillment_in_store_options_bool_exp
  brand_fulfillment_in_store_options_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  storefront_fulfillment_in_store_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_max_order_by {
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_min_order_by {
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_in_store_options\"."
input storefront_fulfillment_in_store_options_order_by {
  brand_fulfillment_in_store_option: brand_fulfillment_in_store_options_order_by
  brand_fulfillment_in_store_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_in_store_settings_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_in_store_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_in_store_options_stream_cursor_value_input {
  brand_fulfillment_in_store_options_id: uuid
  created_at: timestamptz
  id: uuid
  shipping_fee: Int
  storefront_fulfillment_in_store_settings_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"storefront_fulfillment_in_store_options\""
input storefront_fulfillment_in_store_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_in_store_settings_max_order_by
  min: storefront_fulfillment_in_store_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_in_store_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_in_store_settings_bool_exp {
  _and: [storefront_fulfillment_in_store_settings_bool_exp!]
  _not: storefront_fulfillment_in_store_settings_bool_exp
  _or: [storefront_fulfillment_in_store_settings_bool_exp!]
  brand_fulfillment_in_store_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: storefront_fulfillment_in_store_options_bool_exp
  storefront_fulfillment_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_max_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_min_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_in_store_settings\"."
input storefront_fulfillment_in_store_settings_order_by {
  brand_fulfillment_in_store_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: storefront_fulfillment_in_store_options_aggregate_order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_in_store_settings\""
input storefront_fulfillment_in_store_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_in_store_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_in_store_settings_stream_cursor_value_input {
  brand_fulfillment_in_store_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_fulfillment_settings_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_aggregate_order_by {
  avg: storefront_fulfillment_postal_options_avg_order_by
  count: order_by
  max: storefront_fulfillment_postal_options_max_order_by
  min: storefront_fulfillment_postal_options_min_order_by
  stddev: storefront_fulfillment_postal_options_stddev_order_by
  stddev_pop: storefront_fulfillment_postal_options_stddev_pop_order_by
  stddev_samp: storefront_fulfillment_postal_options_stddev_samp_order_by
  sum: storefront_fulfillment_postal_options_sum_order_by
  var_pop: storefront_fulfillment_postal_options_var_pop_order_by
  var_samp: storefront_fulfillment_postal_options_var_samp_order_by
  variance: storefront_fulfillment_postal_options_variance_order_by
}

"order by avg() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_avg_order_by {
  shipping_fee: order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_postal_options\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_postal_options_bool_exp {
  _and: [storefront_fulfillment_postal_options_bool_exp!]
  _not: storefront_fulfillment_postal_options_bool_exp
  _or: [storefront_fulfillment_postal_options_bool_exp!]
  brand_fulfillment_postal_options_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  shipping_fee: Int_comparison_exp
  storefront_fulfillment_postal_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_max_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_min_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_postal_options\"."
input storefront_fulfillment_postal_options_order_by {
  brand_fulfillment_postal_options_id: order_by
  created_at: order_by
  id: order_by
  shipping_fee: order_by
  storefront_fulfillment_postal_settings_id: order_by
  updated_at: order_by
}

"order by stddev() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_order_by {
  shipping_fee: order_by
}

"order by stddev_pop() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_pop_order_by {
  shipping_fee: order_by
}

"order by stddev_samp() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stddev_samp_order_by {
  shipping_fee: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_postal_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_postal_options_stream_cursor_value_input {
  brand_fulfillment_postal_options_id: uuid
  created_at: timestamptz
  id: uuid
  shipping_fee: Int
  storefront_fulfillment_postal_settings_id: uuid
  updated_at: timestamptz
}

"order by sum() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_sum_order_by {
  shipping_fee: order_by
}

"order by var_pop() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_var_pop_order_by {
  shipping_fee: order_by
}

"order by var_samp() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_var_samp_order_by {
  shipping_fee: order_by
}

"order by variance() on columns of table \"storefront_fulfillment_postal_options\""
input storefront_fulfillment_postal_options_variance_order_by {
  shipping_fee: order_by
}

"order by aggregate values of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_postal_settings_max_order_by
  min: storefront_fulfillment_postal_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_postal_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_postal_settings_bool_exp {
  _and: [storefront_fulfillment_postal_settings_bool_exp!]
  _not: storefront_fulfillment_postal_settings_bool_exp
  _or: [storefront_fulfillment_postal_settings_bool_exp!]
  brand_fulfillment_postal_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  options: storefront_fulfillment_postal_options_bool_exp
  storefront_fulfillment_settings_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_max_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_min_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_postal_settings\"."
input storefront_fulfillment_postal_settings_order_by {
  brand_fulfillment_postal_settings_id: order_by
  created_at: order_by
  id: order_by
  options_aggregate: storefront_fulfillment_postal_options_aggregate_order_by
  storefront_fulfillment_settings_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_postal_settings\""
input storefront_fulfillment_postal_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_postal_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_postal_settings_stream_cursor_value_input {
  brand_fulfillment_postal_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_fulfillment_settings_id: uuid
  updated_at: timestamptz
}

"order by aggregate values of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_aggregate_order_by {
  count: order_by
  max: storefront_fulfillment_settings_max_order_by
  min: storefront_fulfillment_settings_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_fulfillment_settings\". All fields are combined with a logical 'AND'."
input storefront_fulfillment_settings_bool_exp {
  _and: [storefront_fulfillment_settings_bool_exp!]
  _not: storefront_fulfillment_settings_bool_exp
  _or: [storefront_fulfillment_settings_bool_exp!]
  brand_fulfillment_settings_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  in_store_settings: storefront_fulfillment_in_store_settings_bool_exp
  postal_settings: storefront_fulfillment_postal_settings_bool_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_max_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_min_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  storefront_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"storefront_fulfillment_settings\"."
input storefront_fulfillment_settings_order_by {
  brand_fulfillment_settings_id: order_by
  created_at: order_by
  id: order_by
  in_store_settings_aggregate: storefront_fulfillment_in_store_settings_aggregate_order_by
  postal_settings_aggregate: storefront_fulfillment_postal_settings_aggregate_order_by
  storefront_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_fulfillment_settings\""
input storefront_fulfillment_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_fulfillment_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_fulfillment_settings_stream_cursor_value_input {
  brand_fulfillment_settings_id: uuid
  created_at: timestamptz
  id: uuid
  storefront_id: uuid
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"storefront_images\". All fields are combined with a logical 'AND'."
input storefront_images_bool_exp {
  _and: [storefront_images_bool_exp!]
  _not: storefront_images_bool_exp
  _or: [storefront_images_bool_exp!]
  alt: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  src: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"storefront_images\"."
input storefront_images_order_by {
  alt: order_by
  created_at: order_by
  id: order_by
  path: order_by
  src: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_images\""
input storefront_images_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_images_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_images_stream_cursor_value_input {
  alt: String
  created_at: timestamptz
  id: uuid
  path: String
  src: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"storefront_payout_settings\". All fields are combined with a logical 'AND'."
input storefront_payout_settings_bool_exp {
  _and: [storefront_payout_settings_bool_exp!]
  _not: storefront_payout_settings_bool_exp
  _or: [storefront_payout_settings_bool_exp!]
  cashout_percent: numeric_comparison_exp
  store_credit_percent: numeric_comparison_exp
  storefronts: storefronts_bool_exp
  stripe_account_id: String_comparison_exp
}

"Ordering options when selecting data from \"storefront_payout_settings\"."
input storefront_payout_settings_order_by {
  cashout_percent: order_by
  store_credit_percent: order_by
  storefronts_aggregate: storefronts_aggregate_order_by
  stripe_account_id: order_by
}

"Streaming cursor of the table \"storefront_payout_settings\""
input storefront_payout_settings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_payout_settings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_payout_settings_stream_cursor_value_input {
  cashout_percent: numeric
  store_credit_percent: numeric
  stripe_account_id: String
}

"Boolean expression to filter rows from the table \"storefront_reviews\". All fields are combined with a logical 'AND'."
input storefront_reviews_bool_exp {
  _and: [storefront_reviews_bool_exp!]
  _not: storefront_reviews_bool_exp
  _or: [storefront_reviews_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
  rating: Int_comparison_exp
  status: review_statuses_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"storefront_reviews\""
input storefront_reviews_insert_input {
  comment: String
  order: orders_obj_rel_insert_input
  order_id: uuid
  rating: Int
  storefront_id: uuid
}

"on_conflict condition type for table \"storefront_reviews\""
input storefront_reviews_on_conflict {
  constraint: storefront_reviews_constraint!
  update_columns: [storefront_reviews_update_column!]! = []
  where: storefront_reviews_bool_exp
}

"Ordering options when selecting data from \"storefront_reviews\"."
input storefront_reviews_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  order: orders_order_by
  order_id: order_by
  rating: order_by
  status: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"storefront_reviews\""
input storefront_reviews_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_reviews_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_reviews_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  order_id: uuid
  rating: Int
  status: review_statuses_enum
  storefront_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"storefront_statuses_enum\". All fields are combined with logical 'AND'."
input storefront_statuses_enum_comparison_exp {
  _eq: storefront_statuses_enum
  _in: [storefront_statuses_enum!]
  _is_null: Boolean
  _neq: storefront_statuses_enum
  _nin: [storefront_statuses_enum!]
}

"Boolean expression to compare columns of type \"storefront_types_enum\". All fields are combined with logical 'AND'."
input storefront_types_enum_comparison_exp {
  _eq: storefront_types_enum
  _in: [storefront_types_enum!]
  _is_null: Boolean
  _neq: storefront_types_enum
  _nin: [storefront_types_enum!]
}

"order by aggregate values of table \"storefront_verified_attributes\""
input storefront_verified_attributes_aggregate_order_by {
  count: order_by
  max: storefront_verified_attributes_max_order_by
  min: storefront_verified_attributes_min_order_by
}

"Boolean expression to filter rows from the table \"storefront_verified_attributes\". All fields are combined with a logical 'AND'."
input storefront_verified_attributes_bool_exp {
  _and: [storefront_verified_attributes_bool_exp!]
  _not: storefront_verified_attributes_bool_exp
  _or: [storefront_verified_attributes_bool_exp!]
  attribute: verified_identity_attributes_enum_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
}

"order by max() on columns of table \"storefront_verified_attributes\""
input storefront_verified_attributes_max_order_by {
  storefront_id: order_by
}

"order by min() on columns of table \"storefront_verified_attributes\""
input storefront_verified_attributes_min_order_by {
  storefront_id: order_by
}

"Ordering options when selecting data from \"storefront_verified_attributes\"."
input storefront_verified_attributes_order_by {
  attribute: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
}

"Streaming cursor of the table \"storefront_verified_attributes\""
input storefront_verified_attributes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefront_verified_attributes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefront_verified_attributes_stream_cursor_value_input {
  attribute: verified_identity_attributes_enum
  storefront_id: uuid
}

"order by aggregate values of table \"storefronts\""
input storefronts_aggregate_order_by {
  count: order_by
  max: storefronts_max_order_by
  min: storefronts_min_order_by
}

"Boolean expression to filter rows from the table \"storefronts\". All fields are combined with a logical 'AND'."
input storefronts_bool_exp {
  _and: [storefronts_bool_exp!]
  _not: storefronts_bool_exp
  _or: [storefronts_bool_exp!]
  address: addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  balances: user_balances_bool_exp
  balances_aggregate: user_balances_aggregate_bool_exp
  bio: String_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  dac7_verified: dac7_verified_storefronts_bool_exp
  fulfillment_settings: storefront_fulfillment_settings_bool_exp
  hide_address: Boolean_comparison_exp
  id: uuid_comparison_exp
  links: jsonb_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  logo: storefront_images_bool_exp
  logo_id: uuid_comparison_exp
  name: String_comparison_exp
  owner: users_bool_exp
  payout_settings: storefront_payout_settings_bool_exp
  primary_address_id: uuid_comparison_exp
  slug: String_comparison_exp
  status: storefront_statuses_enum_comparison_exp
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  type: storefront_types_enum_comparison_exp
  verified: Boolean_comparison_exp
  verified_attributes: storefront_verified_attributes_bool_exp
}

"order by max() on columns of table \"storefronts\""
input storefronts_max_order_by {
  bio: order_by
  brand_id: order_by
  id: order_by
  logo_id: order_by
  name: order_by
  primary_address_id: order_by
  slug: order_by
}

"order by min() on columns of table \"storefronts\""
input storefronts_min_order_by {
  bio: order_by
  brand_id: order_by
  id: order_by
  logo_id: order_by
  name: order_by
  primary_address_id: order_by
  slug: order_by
}

"Ordering options when selecting data from \"storefronts\"."
input storefronts_order_by {
  address: addresses_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  balances_aggregate: user_balances_aggregate_order_by
  bio: order_by
  brand: brands_order_by
  brand_id: order_by
  dac7_verified: dac7_verified_storefronts_order_by
  fulfillment_settings_aggregate: storefront_fulfillment_settings_aggregate_order_by
  hide_address: order_by
  id: order_by
  links: order_by
  listings_aggregate: listings_aggregate_order_by
  logo: storefront_images_order_by
  logo_id: order_by
  name: order_by
  owner: users_order_by
  payout_settings: storefront_payout_settings_order_by
  primary_address_id: order_by
  slug: order_by
  status: order_by
  transactions_aggregate: transactions_aggregate_order_by
  type: order_by
  verified: order_by
  verified_attributes_aggregate: storefront_verified_attributes_aggregate_order_by
}

"primary key columns input for table: storefronts"
input storefronts_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"storefronts\""
input storefronts_set_input {
  primary_address_id: uuid
}

"Streaming cursor of the table \"storefronts\""
input storefronts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: storefronts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input storefronts_stream_cursor_value_input {
  bio: String
  brand_id: uuid
  hide_address: Boolean
  id: uuid
  links: jsonb
  logo_id: uuid
  name: String
  primary_address_id: uuid
  slug: String
  status: storefront_statuses_enum
  type: storefront_types_enum
  verified: Boolean
}

input storefronts_updates {
  "sets the columns of the filtered rows to the given values"
  _set: storefronts_set_input
  "filter the rows which have to be updated"
  where: storefronts_bool_exp!
}

"Boolean expression to compare columns of type \"takeback_item_statuses_enum\". All fields are combined with logical 'AND'."
input takeback_item_statuses_enum_comparison_exp {
  _eq: takeback_item_statuses_enum
  _in: [takeback_item_statuses_enum!]
  _is_null: Boolean
  _neq: takeback_item_statuses_enum
  _nin: [takeback_item_statuses_enum!]
}

"order by aggregate values of table \"takeback_items\""
input takeback_items_aggregate_order_by {
  count: order_by
  max: takeback_items_max_order_by
  min: takeback_items_min_order_by
}

"Boolean expression to filter rows from the table \"takeback_items\". All fields are combined with a logical 'AND'."
input takeback_items_bool_exp {
  _and: [takeback_items_bool_exp!]
  _not: takeback_items_bool_exp
  _or: [takeback_items_bool_exp!]
  created_at: timestamptz_comparison_exp
  credit: credit_bool_exp
  credit_id: uuid_comparison_exp
  estimate_credit: credit_bool_exp
  estimate_credit_id: uuid_comparison_exp
  form_submission: form_submissions_bool_exp
  form_submission_id: uuid_comparison_exp
  id: uuid_comparison_exp
  lpn: String_comparison_exp
  product: products_bool_exp
  product_style: product_styles_bool_exp
  status: takeback_item_statuses_enum_comparison_exp
  style_code: String_comparison_exp
  takeback: takebacks_bool_exp
  takeback_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"takeback_items\""
input takeback_items_max_order_by {
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  style_code: order_by
  takeback_id: order_by
  updated_at: order_by
}

"order by min() on columns of table \"takeback_items\""
input takeback_items_min_order_by {
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  style_code: order_by
  takeback_id: order_by
  updated_at: order_by
}

"Ordering options when selecting data from \"takeback_items\"."
input takeback_items_order_by {
  created_at: order_by
  credit: credit_order_by
  credit_id: order_by
  estimate_credit: credit_order_by
  estimate_credit_id: order_by
  form_submission: form_submissions_order_by
  form_submission_id: order_by
  id: order_by
  lpn: order_by
  product: products_order_by
  product_style: product_styles_order_by
  status: order_by
  style_code: order_by
  takeback: takebacks_order_by
  takeback_id: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"takeback_items\""
input takeback_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: takeback_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input takeback_items_stream_cursor_value_input {
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  form_submission_id: uuid
  id: uuid
  lpn: String
  status: takeback_item_statuses_enum
  style_code: String
  takeback_id: uuid
  updated_at: timestamptz
}

"Boolean expression to compare columns of type \"takeback_statuses_enum\". All fields are combined with logical 'AND'."
input takeback_statuses_enum_comparison_exp {
  _eq: takeback_statuses_enum
  _in: [takeback_statuses_enum!]
  _is_null: Boolean
  _neq: takeback_statuses_enum
  _nin: [takeback_statuses_enum!]
}

input takebacks_aggregate_bool_exp {
  count: takebacks_aggregate_bool_exp_count
}

input takebacks_aggregate_bool_exp_count {
  arguments: [takebacks_select_column!]
  distinct: Boolean
  filter: takebacks_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"takebacks\""
input takebacks_aggregate_order_by {
  count: order_by
  max: takebacks_max_order_by
  min: takebacks_min_order_by
}

"Boolean expression to filter rows from the table \"takebacks\". All fields are combined with a logical 'AND'."
input takebacks_bool_exp {
  _and: [takebacks_bool_exp!]
  _not: takebacks_bool_exp
  _or: [takebacks_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  credit: credit_bool_exp
  credit_id: uuid_comparison_exp
  estimate_credit: credit_bool_exp
  estimate_credit_id: uuid_comparison_exp
  id: uuid_comparison_exp
  status: takeback_statuses_enum_comparison_exp
  store_number: String_comparison_exp
  storefront: storefronts_bool_exp
  takeback_items: takeback_items_bool_exp
  takeback_mail_takeback: mail_takebacks_bool_exp
  takeback_number: String_comparison_exp
  transaction: transactions_bool_exp
  transaction_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"takebacks\""
input takebacks_max_order_by {
  brand_id: order_by
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  id: order_by
  store_number: order_by
  takeback_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"takebacks\""
input takebacks_min_order_by {
  brand_id: order_by
  created_at: order_by
  credit_id: order_by
  estimate_credit_id: order_by
  id: order_by
  store_number: order_by
  takeback_number: order_by
  transaction_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"takebacks\"."
input takebacks_order_by {
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  credit: credit_order_by
  credit_id: order_by
  estimate_credit: credit_order_by
  estimate_credit_id: order_by
  id: order_by
  status: order_by
  store_number: order_by
  storefront: storefronts_order_by
  takeback_items_aggregate: takeback_items_aggregate_order_by
  takeback_mail_takeback_aggregate: mail_takebacks_aggregate_order_by
  takeback_number: order_by
  transaction: transactions_order_by
  transaction_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"Streaming cursor of the table \"takebacks\""
input takebacks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: takebacks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input takebacks_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  credit_id: uuid
  estimate_credit_id: uuid
  id: uuid
  status: takeback_statuses_enum
  store_number: String
  takeback_number: String
  transaction_id: uuid
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"transaction_types\". All fields are combined with a logical 'AND'."
input transaction_types_bool_exp {
  _and: [transaction_types_bool_exp!]
  _not: transaction_types_bool_exp
  _or: [transaction_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"transaction_types_enum\". All fields are combined with logical 'AND'."
input transaction_types_enum_comparison_exp {
  _eq: transaction_types_enum
  _in: [transaction_types_enum!]
  _is_null: Boolean
  _neq: transaction_types_enum
  _nin: [transaction_types_enum!]
}

"Ordering options when selecting data from \"transaction_types\"."
input transaction_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"transaction_types\""
input transaction_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: transaction_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input transaction_types_stream_cursor_value_input {
  type: String
}

input transactions_aggregate_bool_exp {
  count: transactions_aggregate_bool_exp_count
}

input transactions_aggregate_bool_exp_count {
  arguments: [transactions_select_column!]
  distinct: Boolean
  filter: transactions_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"transactions\""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"order by avg() on columns of table \"transactions\""
input transactions_avg_order_by {
  amount: order_by
  fee: order_by
}

"Boolean expression to filter rows from the table \"transactions\". All fields are combined with a logical 'AND'."
input transactions_bool_exp {
  _and: [transactions_bool_exp!]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp!]
  amount: Int_comparison_exp
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  fee: Int_comparison_exp
  gift_cards: gift_cards_bool_exp
  gift_cards_aggregate: gift_cards_aggregate_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  type: transaction_types_enum_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"transactions\""
input transactions_max_order_by {
  amount: order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  id: order_by
  listing_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"transactions\""
input transactions_min_order_by {
  amount: order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  id: order_by
  listing_id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"transactions\"."
input transactions_order_by {
  amount: order_by
  brand: brands_order_by
  brand_id: order_by
  created_at: order_by
  fee: order_by
  gift_cards_aggregate: gift_cards_aggregate_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"transactions\""
input transactions_stddev_order_by {
  amount: order_by
  fee: order_by
}

"order by stddev_pop() on columns of table \"transactions\""
input transactions_stddev_pop_order_by {
  amount: order_by
  fee: order_by
}

"order by stddev_samp() on columns of table \"transactions\""
input transactions_stddev_samp_order_by {
  amount: order_by
  fee: order_by
}

"Streaming cursor of the table \"transactions\""
input transactions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: transactions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input transactions_stream_cursor_value_input {
  amount: Int
  brand_id: uuid
  created_at: timestamptz
  fee: Int
  id: uuid
  listing_id: uuid
  type: transaction_types_enum
  user_id: String
}

"order by sum() on columns of table \"transactions\""
input transactions_sum_order_by {
  amount: order_by
  fee: order_by
}

"order by var_pop() on columns of table \"transactions\""
input transactions_var_pop_order_by {
  amount: order_by
  fee: order_by
}

"order by var_samp() on columns of table \"transactions\""
input transactions_var_samp_order_by {
  amount: order_by
  fee: order_by
}

"order by variance() on columns of table \"transactions\""
input transactions_variance_order_by {
  amount: order_by
  fee: order_by
}

"Boolean expression to filter rows from the table \"unassociated_listing_data\". All fields are combined with a logical 'AND'."
input unassociated_listing_data_bool_exp {
  _and: [unassociated_listing_data_bool_exp!]
  _not: unassociated_listing_data_bool_exp
  _or: [unassociated_listing_data_bool_exp!]
  brand_id: uuid_comparison_exp
  category: brand_categories_bool_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_metadata: jsonb_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  original_price: Int_comparison_exp
  storefront_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  variant_data: jsonb_comparison_exp
}

"Ordering options when selecting data from \"unassociated_listing_data\"."
input unassociated_listing_data_order_by {
  brand_id: order_by
  category: brand_categories_order_by
  category_id: order_by
  created_at: order_by
  custom_metadata: order_by
  description: order_by
  id: order_by
  name: order_by
  original_price: order_by
  storefront_id: order_by
  updated_at: order_by
  user_id: order_by
  variant_data: order_by
}

"Boolean expression to filter rows from the table \"unassociated_listing_data_schemas\". All fields are combined with a logical 'AND'."
input unassociated_listing_data_schemas_bool_exp {
  _and: [unassociated_listing_data_schemas_bool_exp!]
  _not: unassociated_listing_data_schemas_bool_exp
  _or: [unassociated_listing_data_schemas_bool_exp!]
  brand_id: uuid_comparison_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  question_set_id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Ordering options when selecting data from \"unassociated_listing_data_schemas\"."
input unassociated_listing_data_schemas_order_by {
  brand_id: order_by
  category_id: order_by
  created_at: order_by
  id: order_by
  question_set_id: order_by
  schema: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"unassociated_listing_data_schemas\""
input unassociated_listing_data_schemas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unassociated_listing_data_schemas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unassociated_listing_data_schemas_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  created_at: timestamptz
  id: uuid
  question_set_id: uuid
  schema: jsonb
  updated_at: timestamptz
}

"Streaming cursor of the table \"unassociated_listing_data\""
input unassociated_listing_data_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unassociated_listing_data_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unassociated_listing_data_stream_cursor_value_input {
  brand_id: uuid
  category_id: uuid
  created_at: timestamptz
  custom_metadata: jsonb
  description: String
  id: uuid
  name: String
  original_price: Int
  storefront_id: uuid
  updated_at: timestamptz
  user_id: String
  variant_data: jsonb
}

input unique_listed_product_styles_tnf_args {
  brand_id: uuid
  tag_search: json
}

input unique_listing_tags_by_brand_args {
  brand_id: uuid
  prefix: String
}

input unique_listing_tags_by_brand_collection_args {
  brand_id: uuid
  collection: String
  prefix: String
}

input unique_listings_31pl_args {
  brand_id: uuid
  tag_search: json
}

input unique_listings_by_brand_args {
  brand_id: uuid
}

input unique_listings_by_brand_tnf_args {
  brand_id: uuid
  tag_search: json
}

"Boolean expression to filter rows from the table \"unique_listings_results\". All fields are combined with a logical 'AND'."
input unique_listings_results_bool_exp {
  _and: [unique_listings_results_bool_exp!]
  _not: unique_listings_results_bool_exp
  _or: [unique_listings_results_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  sizes: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"unique_listings_results\"."
input unique_listings_results_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  name: order_by
  priority: order_by
  product: products_order_by
  product_id: order_by
  sizes: order_by
  type: order_by
}

"Streaming cursor of the table \"unique_listings_results\""
input unique_listings_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_listings_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_listings_results_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  sizes: String
  type: String
}

"Boolean expression to filter rows from the table \"unique_listings_results_tnf\". All fields are combined with a logical 'AND'."
input unique_listings_results_tnf_bool_exp {
  _and: [unique_listings_results_tnf_bool_exp!]
  _not: unique_listings_results_tnf_bool_exp
  _or: [unique_listings_results_tnf_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  color: String_comparison_exp
  color_mapping: String_comparison_exp
  latest_created_at: timestamptz_comparison_exp
  max_price: Int_comparison_exp
  min_price: Int_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  size_groupings: String_comparison_exp
  sizes: String_comparison_exp
  tags: String_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"unique_listings_results_tnf\"."
input unique_listings_results_tnf_order_by {
  brand: brands_order_by
  brand_id: order_by
  color: order_by
  color_mapping: order_by
  latest_created_at: order_by
  max_price: order_by
  min_price: order_by
  name: order_by
  priority: order_by
  product: products_order_by
  product_id: order_by
  size_groupings: order_by
  sizes: order_by
  tags: order_by
  type: order_by
}

"Streaming cursor of the table \"unique_listings_results_tnf\""
input unique_listings_results_tnf_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_listings_results_tnf_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_listings_results_tnf_stream_cursor_value_input {
  brand_id: uuid
  color: String
  color_mapping: String
  latest_created_at: timestamptz
  max_price: Int
  min_price: Int
  name: String
  priority: Int
  product_id: uuid
  size_groupings: String
  sizes: String
  tags: String
  type: String
}

"Boolean expression to filter rows from the table \"unique_tags_results\". All fields are combined with a logical 'AND'."
input unique_tags_results_bool_exp {
  _and: [unique_tags_results_bool_exp!]
  _not: unique_tags_results_bool_exp
  _or: [unique_tags_results_bool_exp!]
  value: String_comparison_exp
}

"Ordering options when selecting data from \"unique_tags_results\"."
input unique_tags_results_order_by {
  value: order_by
}

"Streaming cursor of the table \"unique_tags_results\""
input unique_tags_results_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: unique_tags_results_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input unique_tags_results_stream_cursor_value_input {
  value: String
}

"order by aggregate values of table \"user_addresses\""
input user_addresses_aggregate_order_by {
  avg: user_addresses_avg_order_by
  count: order_by
  max: user_addresses_max_order_by
  min: user_addresses_min_order_by
  stddev: user_addresses_stddev_order_by
  stddev_pop: user_addresses_stddev_pop_order_by
  stddev_samp: user_addresses_stddev_samp_order_by
  sum: user_addresses_sum_order_by
  var_pop: user_addresses_var_pop_order_by
  var_samp: user_addresses_var_samp_order_by
  variance: user_addresses_variance_order_by
}

"input type for inserting array relation for remote table \"user_addresses\""
input user_addresses_arr_rel_insert_input {
  data: [user_addresses_insert_input!]!
  "upsert condition"
  on_conflict: user_addresses_on_conflict
}

"order by avg() on columns of table \"user_addresses\""
input user_addresses_avg_order_by {
  floors: order_by
}

"Boolean expression to filter rows from the table \"user_addresses\". All fields are combined with a logical 'AND'."
input user_addresses_bool_exp {
  _and: [user_addresses_bool_exp!]
  _not: user_addresses_bool_exp
  _or: [user_addresses_bool_exp!]
  address_line_1: String_comparison_exp
  address_line_2: String_comparison_exp
  administrative_area: String_comparison_exp
  building_access: building_access_types_enum_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  floors: Int_comparison_exp
  id: uuid_comparison_exp
  locality: String_comparison_exp
  name: String_comparison_exp
  organization: String_comparison_exp
  phone_number: String_comparison_exp
  postal_code: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"user_addresses\""
input user_addresses_inc_input {
  floors: Int
}

"input type for inserting data into table \"user_addresses\""
input user_addresses_insert_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
}

"order by max() on columns of table \"user_addresses\""
input user_addresses_max_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_addresses\""
input user_addresses_min_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"user_addresses\""
input user_addresses_obj_rel_insert_input {
  data: user_addresses_insert_input!
  "upsert condition"
  on_conflict: user_addresses_on_conflict
}

"on_conflict condition type for table \"user_addresses\""
input user_addresses_on_conflict {
  constraint: user_addresses_constraint!
  update_columns: [user_addresses_update_column!]! = []
  where: user_addresses_bool_exp
}

"Ordering options when selecting data from \"user_addresses\"."
input user_addresses_order_by {
  address_line_1: order_by
  address_line_2: order_by
  administrative_area: order_by
  building_access: order_by
  country: order_by
  created_at: order_by
  floors: order_by
  id: order_by
  locality: order_by
  name: order_by
  organization: order_by
  phone_number: order_by
  postal_code: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_addresses"
input user_addresses_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_addresses\""
input user_addresses_set_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
}

"order by stddev() on columns of table \"user_addresses\""
input user_addresses_stddev_order_by {
  floors: order_by
}

"order by stddev_pop() on columns of table \"user_addresses\""
input user_addresses_stddev_pop_order_by {
  floors: order_by
}

"order by stddev_samp() on columns of table \"user_addresses\""
input user_addresses_stddev_samp_order_by {
  floors: order_by
}

"Streaming cursor of the table \"user_addresses\""
input user_addresses_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_addresses_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_addresses_stream_cursor_value_input {
  address_line_1: String
  address_line_2: String
  administrative_area: String
  building_access: building_access_types_enum
  country: String
  created_at: timestamptz
  floors: Int
  id: uuid
  locality: String
  name: String
  organization: String
  phone_number: String
  postal_code: String
  updated_at: timestamptz
  user_id: String
}

"order by sum() on columns of table \"user_addresses\""
input user_addresses_sum_order_by {
  floors: order_by
}

input user_addresses_updates {
  "increments the numeric columns with given value of the filtered values"
  _inc: user_addresses_inc_input
  "sets the columns of the filtered rows to the given values"
  _set: user_addresses_set_input
  "filter the rows which have to be updated"
  where: user_addresses_bool_exp!
}

"order by var_pop() on columns of table \"user_addresses\""
input user_addresses_var_pop_order_by {
  floors: order_by
}

"order by var_samp() on columns of table \"user_addresses\""
input user_addresses_var_samp_order_by {
  floors: order_by
}

"order by variance() on columns of table \"user_addresses\""
input user_addresses_variance_order_by {
  floors: order_by
}

"Boolean expression to filter rows from the table \"user_alerts\". All fields are combined with a logical 'AND'."
input user_alerts_bool_exp {
  _and: [user_alerts_bool_exp!]
  _not: user_alerts_bool_exp
  _or: [user_alerts_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  sku: skus_bool_exp
  sku_id: uuid_comparison_exp
  uid: String_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_alerts\""
input user_alerts_insert_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"user_alerts\""
input user_alerts_on_conflict {
  constraint: user_alerts_constraint!
  update_columns: [user_alerts_update_column!]! = []
  where: user_alerts_bool_exp
}

"Ordering options when selecting data from \"user_alerts\"."
input user_alerts_order_by {
  created_at: order_by
  id: order_by
  product: products_order_by
  product_id: order_by
  sku: skus_order_by
  sku_id: order_by
  uid: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_alerts"
input user_alerts_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_alerts\""
input user_alerts_set_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user_id: String
}

"Streaming cursor of the table \"user_alerts\""
input user_alerts_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_alerts_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_alerts_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  product_id: uuid
  sku_id: uuid
  uid: String
  user_id: String
}

input user_alerts_updates {
  "sets the columns of the filtered rows to the given values"
  _set: user_alerts_set_input
  "filter the rows which have to be updated"
  where: user_alerts_bool_exp!
}

input user_balances_aggregate_bool_exp {
  count: user_balances_aggregate_bool_exp_count
}

input user_balances_aggregate_bool_exp_count {
  arguments: [user_balances_select_column!]
  distinct: Boolean
  filter: user_balances_bool_exp
  predicate: Int_comparison_exp!
}

"order by aggregate values of table \"user_balances\""
input user_balances_aggregate_order_by {
  avg: user_balances_avg_order_by
  count: order_by
  max: user_balances_max_order_by
  min: user_balances_min_order_by
  stddev: user_balances_stddev_order_by
  stddev_pop: user_balances_stddev_pop_order_by
  stddev_samp: user_balances_stddev_samp_order_by
  sum: user_balances_sum_order_by
  var_pop: user_balances_var_pop_order_by
  var_samp: user_balances_var_samp_order_by
  variance: user_balances_variance_order_by
}

"order by avg() on columns of table \"user_balances\""
input user_balances_avg_order_by {
  current_balance: order_by
}

"Boolean expression to filter rows from the table \"user_balances\". All fields are combined with a logical 'AND'."
input user_balances_bool_exp {
  _and: [user_balances_bool_exp!]
  _not: user_balances_bool_exp
  _or: [user_balances_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  current_balance: Int_comparison_exp
  id: uuid_comparison_exp
  storefront: storefronts_bool_exp
  storefront_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"user_balances\""
input user_balances_max_order_by {
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront_id: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_balances\""
input user_balances_min_order_by {
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront_id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"user_balances\"."
input user_balances_order_by {
  brand: brands_order_by
  brand_id: order_by
  current_balance: order_by
  id: order_by
  storefront: storefronts_order_by
  storefront_id: order_by
  user: users_order_by
  user_id: order_by
}

"order by stddev() on columns of table \"user_balances\""
input user_balances_stddev_order_by {
  current_balance: order_by
}

"order by stddev_pop() on columns of table \"user_balances\""
input user_balances_stddev_pop_order_by {
  current_balance: order_by
}

"order by stddev_samp() on columns of table \"user_balances\""
input user_balances_stddev_samp_order_by {
  current_balance: order_by
}

"Streaming cursor of the table \"user_balances\""
input user_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_balances_stream_cursor_value_input {
  brand_id: uuid
  current_balance: Int
  id: uuid
  storefront_id: uuid
  user_id: String
}

"order by sum() on columns of table \"user_balances\""
input user_balances_sum_order_by {
  current_balance: order_by
}

"order by var_pop() on columns of table \"user_balances\""
input user_balances_var_pop_order_by {
  current_balance: order_by
}

"order by var_samp() on columns of table \"user_balances\""
input user_balances_var_samp_order_by {
  current_balance: order_by
}

"order by variance() on columns of table \"user_balances\""
input user_balances_variance_order_by {
  current_balance: order_by
}

"Boolean expression to filter rows from the table \"user_favorites\". All fields are combined with a logical 'AND'."
input user_favorites_bool_exp {
  _and: [user_favorites_bool_exp!]
  _not: user_favorites_bool_exp
  _or: [user_favorites_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_favorites\""
input user_favorites_insert_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user: users_obj_rel_insert_input
  user_id: String
}

"on_conflict condition type for table \"user_favorites\""
input user_favorites_on_conflict {
  constraint: user_favorites_constraint!
  update_columns: [user_favorites_update_column!]! = []
  where: user_favorites_bool_exp
}

"Ordering options when selecting data from \"user_favorites\"."
input user_favorites_order_by {
  created_at: order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  product: products_order_by
  product_id: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: user_favorites"
input user_favorites_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user_favorites\""
input user_favorites_set_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user_id: String
}

"Streaming cursor of the table \"user_favorites\""
input user_favorites_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_favorites_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_favorites_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  listing_id: uuid
  product_id: uuid
  user_id: String
}

input user_favorites_updates {
  "sets the columns of the filtered rows to the given values"
  _set: user_favorites_set_input
  "filter the rows which have to be updated"
  where: user_favorites_bool_exp!
}

"Boolean expression to filter rows from the table \"user_metadata\". All fields are combined with a logical 'AND'."
input user_metadata_bool_exp {
  _and: [user_metadata_bool_exp!]
  _not: user_metadata_bool_exp
  _or: [user_metadata_bool_exp!]
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  user_id: String_comparison_exp
  value: jsonb_comparison_exp
}

"Ordering options when selecting data from \"user_metadata\"."
input user_metadata_order_by {
  brand_id: order_by
  id: order_by
  key: order_by
  user_id: order_by
  value: order_by
}

"Streaming cursor of the table \"user_metadata\""
input user_metadata_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_metadata_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_metadata_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  key: String
  user_id: String
  value: jsonb
}

"order by aggregate values of table \"user_roles\""
input user_roles_aggregate_order_by {
  count: order_by
  max: user_roles_max_order_by
  min: user_roles_min_order_by
}

"Boolean expression to filter rows from the table \"user_roles\". All fields are combined with a logical 'AND'."
input user_roles_bool_exp {
  _and: [user_roles_bool_exp!]
  _not: user_roles_bool_exp
  _or: [user_roles_bool_exp!]
  brand_id: uuid_comparison_exp
  id: uuid_comparison_exp
  role: roles_enum_comparison_exp
  user_id: String_comparison_exp
}

"order by max() on columns of table \"user_roles\""
input user_roles_max_order_by {
  brand_id: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_roles\""
input user_roles_min_order_by {
  brand_id: order_by
  id: order_by
  user_id: order_by
}

"Ordering options when selecting data from \"user_roles\"."
input user_roles_order_by {
  brand_id: order_by
  id: order_by
  role: order_by
  user_id: order_by
}

"Streaming cursor of the table \"user_roles\""
input user_roles_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_roles_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_roles_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  role: roles_enum
  user_id: String
}

"Boolean expression to compare columns of type \"user_verification_check_statuses_enum\". All fields are combined with logical 'AND'."
input user_verification_check_statuses_enum_comparison_exp {
  _eq: user_verification_check_statuses_enum
  _in: [user_verification_check_statuses_enum!]
  _is_null: Boolean
  _neq: user_verification_check_statuses_enum
  _nin: [user_verification_check_statuses_enum!]
}

"order by aggregate values of table \"user_verification_checks\""
input user_verification_checks_aggregate_order_by {
  count: order_by
  max: user_verification_checks_max_order_by
  min: user_verification_checks_min_order_by
}

"input type for inserting array relation for remote table \"user_verification_checks\""
input user_verification_checks_arr_rel_insert_input {
  data: [user_verification_checks_insert_input!]!
  "upsert condition"
  on_conflict: user_verification_checks_on_conflict
}

"Boolean expression to filter rows from the table \"user_verification_checks\". All fields are combined with a logical 'AND'."
input user_verification_checks_bool_exp {
  _and: [user_verification_checks_bool_exp!]
  _not: user_verification_checks_bool_exp
  _or: [user_verification_checks_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  status: user_verification_check_statuses_enum_comparison_exp
  stripe_verification_response_id: String_comparison_exp
  stripe_verification_session_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"input type for inserting data into table \"user_verification_checks\""
input user_verification_checks_insert_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  status: user_verification_check_statuses_enum
  stripe_verification_response_id: String
  stripe_verification_session_id: String
  updated_at: timestamptz
  user_id: String
}

"order by max() on columns of table \"user_verification_checks\""
input user_verification_checks_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"order by min() on columns of table \"user_verification_checks\""
input user_verification_checks_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"on_conflict condition type for table \"user_verification_checks\""
input user_verification_checks_on_conflict {
  constraint: user_verification_checks_constraint!
  update_columns: [user_verification_checks_update_column!]! = []
  where: user_verification_checks_bool_exp
}

"Ordering options when selecting data from \"user_verification_checks\"."
input user_verification_checks_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  stripe_verification_response_id: order_by
  stripe_verification_session_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"user_verification_checks\""
input user_verification_checks_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_verification_checks_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_verification_checks_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  status: user_verification_check_statuses_enum
  stripe_verification_response_id: String
  stripe_verification_session_id: String
  updated_at: timestamptz
  user_id: String
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  addresses: user_addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  brand: brands_bool_exp
  default_shipping_address: user_addresses_bool_exp
  first_name: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
  listings: listings_bool_exp
  listings_aggregate: listings_aggregate_bool_exp
  orders: orders_bool_exp
  orders_aggregate: orders_aggregate_bool_exp
  owned_storefronts: storefronts_bool_exp
  private: users_private_bool_exp
  roles: user_roles_bool_exp
  state: String_comparison_exp
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  user_balances: user_balances_bool_exp
  user_balances_aggregate: user_balances_aggregate_bool_exp
  verification_checks: user_verification_checks_bool_exp
}

"input type for inserting data into table \"users\""
input users_insert_input {
  addresses: user_addresses_arr_rel_insert_input
  brand_id: uuid
  created_at: timestamptz
  default_shipping_address: user_addresses_obj_rel_insert_input
  default_shipping_address_id: uuid
  email: String
  first_name: String
  id: String
  last_name: String
  orders: orders_arr_rel_insert_input
  state: String
  stripe_account_id: String
  updated_at: timestamptz
  verification_checks: user_verification_checks_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
  data: users_insert_input!
  "upsert condition"
  on_conflict: users_on_conflict
}

"on_conflict condition type for table \"users\""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"Ordering options when selecting data from \"users\"."
input users_order_by {
  addresses_aggregate: user_addresses_aggregate_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  brand: brands_order_by
  default_shipping_address: user_addresses_order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  listings_aggregate: listings_aggregate_order_by
  orders_aggregate: orders_aggregate_order_by
  owned_storefronts_aggregate: storefronts_aggregate_order_by
  private: users_private_order_by
  roles_aggregate: user_roles_aggregate_order_by
  state: order_by
  transactions_aggregate: transactions_aggregate_order_by
  user_balances_aggregate: user_balances_aggregate_order_by
  verification_checks_aggregate: user_verification_checks_aggregate_order_by
}

"primary key columns input for table: users"
input users_pk_columns_input {
  id: String!
}

"Boolean expression to filter rows from the table \"users_private\". All fields are combined with a logical 'AND'."
input users_private_bool_exp {
  _and: [users_private_bool_exp!]
  _not: users_private_bool_exp
  _or: [users_private_bool_exp!]
  addresses: user_addresses_bool_exp
  annual_sales_totals: annual_sales_totals_bool_exp
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_bool_exp
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  current_balance: Int_comparison_exp
  default_shipping_address: user_addresses_bool_exp
  default_shipping_address_id: uuid_comparison_exp
  email: String_comparison_exp
  is_manager: Boolean_comparison_exp
  roles: user_roles_bool_exp
  stripe_account_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"Ordering options when selecting data from \"users_private\"."
input users_private_order_by {
  addresses_aggregate: user_addresses_aggregate_order_by
  annual_sales_totals_aggregate: annual_sales_totals_aggregate_order_by
  brand_id: order_by
  created_at: order_by
  current_balance: order_by
  default_shipping_address: user_addresses_order_by
  default_shipping_address_id: order_by
  email: order_by
  is_manager: order_by
  roles_aggregate: user_roles_aggregate_order_by
  stripe_account_id: order_by
  updated_at: order_by
  user_id: order_by
}

"Streaming cursor of the table \"users_private\""
input users_private_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: users_private_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input users_private_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  current_balance: Int
  default_shipping_address_id: uuid
  email: String
  is_manager: Boolean
  stripe_account_id: String
  updated_at: timestamptz
  user_id: String
}

"input type for updating data in table \"users\""
input users_set_input {
  brand_id: uuid
  created_at: timestamptz
  default_shipping_address_id: uuid
  email: String
  first_name: String
  id: String
  last_name: String
  state: String
  stripe_account_id: String
  updated_at: timestamptz
}

"Streaming cursor of the table \"users\""
input users_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: users_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input users_stream_cursor_value_input {
  first_name: String
  id: String
  last_name: String
  state: String
}

input users_updates {
  "sets the columns of the filtered rows to the given values"
  _set: users_set_input
  "filter the rows which have to be updated"
  where: users_bool_exp!
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"order by aggregate values of table \"variant_type_options\""
input variant_type_options_aggregate_order_by {
  count: order_by
  max: variant_type_options_max_order_by
  min: variant_type_options_min_order_by
}

"Boolean expression to filter rows from the table \"variant_type_options\". All fields are combined with a logical 'AND'."
input variant_type_options_bool_exp {
  _and: [variant_type_options_bool_exp!]
  _not: variant_type_options_bool_exp
  _or: [variant_type_options_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: variant_type_options_translations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  option: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant_type: variant_types_bool_exp
  variant_type_id: uuid_comparison_exp
  variant_type_options_translations: variant_type_options_translations_bool_exp
}

"order by max() on columns of table \"variant_type_options\""
input variant_type_options_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type_id: order_by
}

"order by min() on columns of table \"variant_type_options\""
input variant_type_options_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type_id: order_by
}

"Ordering options when selecting data from \"variant_type_options\"."
input variant_type_options_order_by {
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: variant_type_options_translations_aggregate_order_by
  created_at: order_by
  id: order_by
  option: order_by
  updated_at: order_by
  variant_type: variant_types_order_by
  variant_type_id: order_by
  variant_type_options_translations_aggregate: variant_type_options_translations_aggregate_order_by
}

"Streaming cursor of the table \"variant_type_options\""
input variant_type_options_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_type_options_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_type_options_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  option: String
  updated_at: timestamptz
  variant_type_id: uuid
}

"order by aggregate values of table \"variant_type_options_translations\""
input variant_type_options_translations_aggregate_order_by {
  avg: variant_type_options_translations_avg_order_by
  count: order_by
  max: variant_type_options_translations_max_order_by
  min: variant_type_options_translations_min_order_by
  stddev: variant_type_options_translations_stddev_order_by
  stddev_pop: variant_type_options_translations_stddev_pop_order_by
  stddev_samp: variant_type_options_translations_stddev_samp_order_by
  sum: variant_type_options_translations_sum_order_by
  var_pop: variant_type_options_translations_var_pop_order_by
  var_samp: variant_type_options_translations_var_samp_order_by
  variance: variant_type_options_translations_variance_order_by
}

"order by avg() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_type_options_translations\". All fields are combined with a logical 'AND'."
input variant_type_options_translations_bool_exp {
  _and: [variant_type_options_translations_bool_exp!]
  _not: variant_type_options_translations_bool_exp
  _or: [variant_type_options_translations_bool_exp!]
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  variant_type_option_id: uuid_comparison_exp
}

"order by max() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_max_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"order by min() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_min_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"Ordering options when selecting data from \"variant_type_options_translations\"."
input variant_type_options_translations_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_option_id: order_by
}

"order by stddev() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"variant_type_options_translations\""
input variant_type_options_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_type_options_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_type_options_translations_stream_cursor_value_input {
  display: String
  id: Int
  lang: String
  variant_type_option_id: uuid
}

"order by sum() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"variant_type_options_translations\""
input variant_type_options_translations_variance_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_types\". All fields are combined with a logical 'AND'."
input variant_types_bool_exp {
  _and: [variant_types_bool_exp!]
  _not: variant_types_bool_exp
  _or: [variant_types_bool_exp!]
  brand: brands_bool_exp
  brand_id: uuid_comparison_exp
  content: variant_types_translations_bool_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
  variant_type_options: variant_type_options_bool_exp
  variant_types_translations: variant_types_translations_bool_exp
}

"Ordering options when selecting data from \"variant_types\"."
input variant_types_order_by {
  brand: brands_order_by
  brand_id: order_by
  content_aggregate: variant_types_translations_aggregate_order_by
  id: order_by
  type: order_by
  variant_type_options_aggregate: variant_type_options_aggregate_order_by
  variant_types_translations_aggregate: variant_types_translations_aggregate_order_by
}

"Streaming cursor of the table \"variant_types\""
input variant_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_types_stream_cursor_value_input {
  brand_id: uuid
  id: uuid
  type: String
}

"order by aggregate values of table \"variant_types_translations\""
input variant_types_translations_aggregate_order_by {
  avg: variant_types_translations_avg_order_by
  count: order_by
  max: variant_types_translations_max_order_by
  min: variant_types_translations_min_order_by
  stddev: variant_types_translations_stddev_order_by
  stddev_pop: variant_types_translations_stddev_pop_order_by
  stddev_samp: variant_types_translations_stddev_samp_order_by
  sum: variant_types_translations_sum_order_by
  var_pop: variant_types_translations_var_pop_order_by
  var_samp: variant_types_translations_var_samp_order_by
  variance: variant_types_translations_variance_order_by
}

"order by avg() on columns of table \"variant_types_translations\""
input variant_types_translations_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"variant_types_translations\". All fields are combined with a logical 'AND'."
input variant_types_translations_bool_exp {
  _and: [variant_types_translations_bool_exp!]
  _not: variant_types_translations_bool_exp
  _or: [variant_types_translations_bool_exp!]
  display: String_comparison_exp
  id: Int_comparison_exp
  lang: String_comparison_exp
  variant_type_id: uuid_comparison_exp
}

"order by max() on columns of table \"variant_types_translations\""
input variant_types_translations_max_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"order by min() on columns of table \"variant_types_translations\""
input variant_types_translations_min_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"Ordering options when selecting data from \"variant_types_translations\"."
input variant_types_translations_order_by {
  display: order_by
  id: order_by
  lang: order_by
  variant_type_id: order_by
}

"order by stddev() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"variant_types_translations\""
input variant_types_translations_stddev_samp_order_by {
  id: order_by
}

"Streaming cursor of the table \"variant_types_translations\""
input variant_types_translations_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: variant_types_translations_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input variant_types_translations_stream_cursor_value_input {
  display: String
  id: Int
  lang: String
  variant_type_id: uuid
}

"order by sum() on columns of table \"variant_types_translations\""
input variant_types_translations_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"variant_types_translations\""
input variant_types_translations_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"variant_types_translations\""
input variant_types_translations_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"variant_types_translations\""
input variant_types_translations_variance_order_by {
  id: order_by
}

"Boolean expression to compare columns of type \"verified_identity_attributes_enum\". All fields are combined with logical 'AND'."
input verified_identity_attributes_enum_comparison_exp {
  _eq: verified_identity_attributes_enum
  _in: [verified_identity_attributes_enum!]
  _is_null: Boolean
  _neq: verified_identity_attributes_enum
  _nin: [verified_identity_attributes_enum!]
}

"order by aggregate values of table \"wms_items\""
input wms_items_aggregate_order_by {
  count: order_by
  max: wms_items_max_order_by
  min: wms_items_min_order_by
}

"Boolean expression to filter rows from the table \"wms_items\". All fields are combined with a logical 'AND'."
input wms_items_bool_exp {
  _and: [wms_items_bool_exp!]
  _not: wms_items_bool_exp
  _or: [wms_items_bool_exp!]
  brand: brands_bool_exp
  brand_category: brand_categories_bool_exp
  id: uuid_comparison_exp
  listing: listings_bool_exp
  listing_id: uuid_comparison_exp
  lpn: String_comparison_exp
  product: products_bool_exp
  product_style: product_styles_bool_exp
  sku: skus_bool_exp
}

"order by max() on columns of table \"wms_items\""
input wms_items_max_order_by {
  id: order_by
  listing_id: order_by
  lpn: order_by
}

"order by min() on columns of table \"wms_items\""
input wms_items_min_order_by {
  id: order_by
  listing_id: order_by
  lpn: order_by
}

"Ordering options when selecting data from \"wms_items\"."
input wms_items_order_by {
  brand: brands_order_by
  brand_category: brand_categories_order_by
  id: order_by
  listing: listings_order_by
  listing_id: order_by
  lpn: order_by
  product: products_order_by
  product_style: product_styles_order_by
  sku: skus_order_by
}

"Streaming cursor of the table \"wms_items\""
input wms_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: wms_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input wms_items_stream_cursor_value_input {
  id: uuid
  listing_id: uuid
  lpn: String
}

"Boolean expression to filter rows from the table \"workflow_definitions\". All fields are combined with a logical 'AND'."
input workflow_definitions_bool_exp {
  _and: [workflow_definitions_bool_exp!]
  _not: workflow_definitions_bool_exp
  _or: [workflow_definitions_bool_exp!]
  callbacks: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  schema: jsonb_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow_items: workflow_items_bool_exp
  workflows: workflows_bool_exp
}

"Ordering options when selecting data from \"workflow_definitions\"."
input workflow_definitions_order_by {
  callbacks: order_by
  created_at: order_by
  id: order_by
  schema: order_by
  type: order_by
  updated_at: order_by
  workflow_items_aggregate: workflow_items_aggregate_order_by
  workflows_aggregate: workflows_aggregate_order_by
}

"Streaming cursor of the table \"workflow_definitions\""
input workflow_definitions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_definitions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_definitions_stream_cursor_value_input {
  callbacks: jsonb
  created_at: timestamptz
  id: uuid
  schema: jsonb
  type: String
  updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"workflow_item_event_types\". All fields are combined with a logical 'AND'."
input workflow_item_event_types_bool_exp {
  _and: [workflow_item_event_types_bool_exp!]
  _not: workflow_item_event_types_bool_exp
  _or: [workflow_item_event_types_bool_exp!]
  type: String_comparison_exp
}

"Boolean expression to compare columns of type \"workflow_item_event_types_enum\". All fields are combined with logical 'AND'."
input workflow_item_event_types_enum_comparison_exp {
  _eq: workflow_item_event_types_enum
  _in: [workflow_item_event_types_enum!]
  _is_null: Boolean
  _neq: workflow_item_event_types_enum
  _nin: [workflow_item_event_types_enum!]
}

"Ordering options when selecting data from \"workflow_item_event_types\"."
input workflow_item_event_types_order_by {
  type: order_by
}

"Streaming cursor of the table \"workflow_item_event_types\""
input workflow_item_event_types_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_item_event_types_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_item_event_types_stream_cursor_value_input {
  type: String
}

"order by aggregate values of table \"workflow_item_events\""
input workflow_item_events_aggregate_order_by {
  count: order_by
  max: workflow_item_events_max_order_by
  min: workflow_item_events_min_order_by
}

"Boolean expression to filter rows from the table \"workflow_item_events\". All fields are combined with a logical 'AND'."
input workflow_item_events_bool_exp {
  _and: [workflow_item_events_bool_exp!]
  _not: workflow_item_events_bool_exp
  _or: [workflow_item_events_bool_exp!]
  event_type: workflow_item_event_types_enum_comparison_exp
  id: uuid_comparison_exp
  payload: jsonb_comparison_exp
  timestamp: timestamptz_comparison_exp
  user: users_bool_exp
  value: String_comparison_exp
  workflow_item: workflow_items_bool_exp
  workflow_item_event_type: workflow_item_event_types_bool_exp
  workflow_item_id: uuid_comparison_exp
}

"order by max() on columns of table \"workflow_item_events\""
input workflow_item_events_max_order_by {
  id: order_by
  timestamp: order_by
  value: order_by
  workflow_item_id: order_by
}

"order by min() on columns of table \"workflow_item_events\""
input workflow_item_events_min_order_by {
  id: order_by
  timestamp: order_by
  value: order_by
  workflow_item_id: order_by
}

"Ordering options when selecting data from \"workflow_item_events\"."
input workflow_item_events_order_by {
  event_type: order_by
  id: order_by
  payload: order_by
  timestamp: order_by
  user: users_order_by
  value: order_by
  workflow_item: workflow_items_order_by
  workflow_item_event_type: workflow_item_event_types_order_by
  workflow_item_id: order_by
}

"Streaming cursor of the table \"workflow_item_events\""
input workflow_item_events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_item_events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_item_events_stream_cursor_value_input {
  event_type: workflow_item_event_types_enum
  id: uuid
  payload: jsonb
  timestamp: timestamptz
  value: String
  workflow_item_id: uuid
}

"order by aggregate values of table \"workflow_items\""
input workflow_items_aggregate_order_by {
  count: order_by
  max: workflow_items_max_order_by
  min: workflow_items_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input workflow_items_append_input {
  data: jsonb
}

"Boolean expression to filter rows from the table \"workflow_items\". All fields are combined with a logical 'AND'."
input workflow_items_bool_exp {
  _and: [workflow_items_bool_exp!]
  _not: workflow_items_bool_exp
  _or: [workflow_items_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  id: uuid_comparison_exp
  state: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow: workflows_bool_exp
  workflow_definition: workflow_definitions_bool_exp
  workflow_definition_id: uuid_comparison_exp
  workflow_id: uuid_comparison_exp
  workflow_item_events: workflow_item_events_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input workflow_items_delete_at_path_input {
  data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input workflow_items_delete_elem_input {
  data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input workflow_items_delete_key_input {
  data: String
}

"order by max() on columns of table \"workflow_items\""
input workflow_items_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow_definition_id: order_by
  workflow_id: order_by
}

"order by min() on columns of table \"workflow_items\""
input workflow_items_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow_definition_id: order_by
  workflow_id: order_by
}

"Ordering options when selecting data from \"workflow_items\"."
input workflow_items_order_by {
  brand_id: order_by
  created_at: order_by
  data: order_by
  id: order_by
  state: order_by
  updated_at: order_by
  workflow: workflows_order_by
  workflow_definition: workflow_definitions_order_by
  workflow_definition_id: order_by
  workflow_id: order_by
  workflow_item_events_aggregate: workflow_item_events_aggregate_order_by
}

"primary key columns input for table: workflow_items"
input workflow_items_pk_columns_input {
  id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input workflow_items_prepend_input {
  data: jsonb
}

"input type for updating data in table \"workflow_items\""
input workflow_items_set_input {
  brand_id: uuid
  created_at: timestamptz
  data: jsonb
  id: uuid
  state: String
  updated_at: timestamptz
  workflow_definition_id: uuid
  workflow_id: uuid
}

"Streaming cursor of the table \"workflow_items\""
input workflow_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflow_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflow_items_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  data: jsonb
  id: uuid
  state: String
  updated_at: timestamptz
  workflow_definition_id: uuid
  workflow_id: uuid
}

input workflow_items_updates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: workflow_items_append_input
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _delete_at_path: workflow_items_delete_at_path_input
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _delete_elem: workflow_items_delete_elem_input
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _delete_key: workflow_items_delete_key_input
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: workflow_items_prepend_input
  "sets the columns of the filtered rows to the given values"
  _set: workflow_items_set_input
  "filter the rows which have to be updated"
  where: workflow_items_bool_exp!
}

"order by aggregate values of table \"workflows\""
input workflows_aggregate_order_by {
  count: order_by
  max: workflows_max_order_by
  min: workflows_min_order_by
}

"Boolean expression to filter rows from the table \"workflows\". All fields are combined with a logical 'AND'."
input workflows_bool_exp {
  _and: [workflows_bool_exp!]
  _not: workflows_bool_exp
  _or: [workflows_bool_exp!]
  brand_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  workflow_definition: workflow_definitions_bool_exp
  workflow_definition_id: uuid_comparison_exp
  workflow_items: workflow_items_bool_exp
}

"order by max() on columns of table \"workflows\""
input workflows_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition_id: order_by
}

"order by min() on columns of table \"workflows\""
input workflows_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition_id: order_by
}

"Ordering options when selecting data from \"workflows\"."
input workflows_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  workflow_definition: workflow_definitions_order_by
  workflow_definition_id: order_by
  workflow_items_aggregate: workflow_items_aggregate_order_by
}

"Streaming cursor of the table \"workflows\""
input workflows_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: workflows_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input workflows_stream_cursor_value_input {
  brand_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  workflow_definition_id: uuid
}
